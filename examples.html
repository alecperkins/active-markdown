<!doctype html>
<html>
<head>
<!--
This file was generated by Active Markdown, v0.4.2 - https://activemarkdown.alecperkins.net

examples.md - 2024-09-06T22:13:28.521Z
-->
  <title>Active Markdown examples</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <style>
:root {
  --color-active-highlight: rgb(209, 180, 237);
  --color-inactive-highlight: rgb(239, 225, 255);
  --color-tag-bg: rgb(209, 180, 237);
  --color-tag-border: rgba(96,88,57,1);
  --color-code-bg: rgba(245,245,245,1);
  --color-border: rgba(200,200,200,1);
  --radius: 4px;
  --color-doc-bg: rgba(250,250,248,1);
  --color-chart-bg: white;
  --color-element-decoration: rebeccapurple;
  --color-readonly-element-decoration: rgb(190, 140, 240);
  --color-text: rgba(5,5,10,1);
  --gutter: 1rem;
  --font-sans: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
  --font-mono: Consolas,Monaco,Andale Mono,Ubuntu Mono,monospace;
  --color-table-odd: rgba(255,255,255,1);
  --color-table-even: rgba(245,245,250,1);
}

/* @media (prefers-color-scheme: dark) {
  :root {
    --color-active-highlight: yellow;
    --color-tag-bg: rgba(96,88,57,1);
    --color-tag-border: rgba(247,230,143,1);
    --color-doc-bg: rgba(5,5,10,1);
    --color-chart-bg: black;
    --color-element-decoration: #d8d0f6;
    --color-text: rgba(250,250,248,1);
  }
} */

html,
body {
  padding: 0;
  background-color: var(--color-doc-bg);
}

body {
  color: var(--color-text);
  font-family: var(--font-sans);
  &[data-dragging_x="true"] {
    cursor: col-resize;
  }
}

main {
  line-height : 1.35;
  max-width: 690px;
  margin: 0 auto;
  padding-left: var(--gutter);
  padding-right: var(--gutter);
}

hr {
  margin      : 2rem 0;
  border      : 0;
  border-top  : 1px solid var(--color-border);
}

h1, h2, h3, h4, h5, h6 {
  margin-top: 0;
}
p, h1, h2, h3, h4, h5, h6, blockquote {
  code {
    font-size           : 0.8em;
    background-color    : var(--color-code-bg);
    border              : 1px solid var(--color-border);
    border-radius       : var(--radius);
    padding             : 0 0.2em;
    font-family         : var(--font-mono);
  }
}


table {
  width           : 100%;
  max-height      : 80vh;
  overflow        : scroll;
  border          : 1px solid var(--color-border);
  border-spacing  : 0;
  border-radius   : var(--radius);
  td, th {
    padding: 0.5em 1em;
  }
  p {
    margin: 0;
  }
  tbody {
    tr:nth-of-type(odd) {
      td {
        background: var(--color-table-odd);
      }
    }
    tr:nth-of-type(even) {
      td {
        background: var(--color-table-even);
      }
    }

  }
  th {
    font-size: 0.8em;
    /* background-color: $light_border_color; */
  }

}

blockquote {
  border-left: 2px solid var(--color-text);
  margin-left: 2px;
  padding-left: var(--gutter);
}

.BaseElement {
  position: relative;
  text-decoration-style: dotted;
  text-decoration-line: underline;
  text-decoration-thickness: 0.1em;
  text-decoration-color: var(--color-element-decoration);

  &[data-is_active="false"] {
    background-color    : unset;
    transition-duration : 1s;
    transition-property : background-color;
  }
  &[data-is_active="true"] {
    background-color    : var(--color-active-highlight);
  }

  ._Name {
    display: none;
    position: absolute;
    bottom: calc(100% - 0.2em);
    left: 0;
    background-color: var(--color-tag-bg);
    border: 0.5px solid var(--color-tag-border);
    border-radius: var(--radius);
    font-size: 0.6em;
    font-family: var(--font-mono);
    font-weight: 500;
    font-style: normal;
    padding: 0.2em;
  }
  &:hover,
  &:focus {
    ._Name {
      display: block;
    }
  }
}

.StringElement {
  cursor          : text;
  text-decoration-color: var(--color-readonly-element-decoration);
}
.RangeElement {
  cursor          : col-resize;
  &:hover,
  &:focus {
    background-color: var(--color-inactive-highlight);
  }
  &[data-is_active="true"] {
    background-color: var(--color-active-highlight);
    ._Indicator {
      background-color: var(--color-element-decoration);
    }
  }
  ._Indicator {
    position: absolute;
    top: calc(100% - 1px);
    left: 0px;
    background-color: var(--color-readonly-element-decoration);
    height: 0.1em;
    display: inline-block;
  }
}
.SwitchElement {
  cursor          : pointer;
  margin-left     : 0.25em;

  ._Indicator {
    position: absolute;
    right: 100%;
  }

  &[aria-pressed="true"] {
    ._Indicator {
      color: rgb(0, 128, 102);
      top: -0.2em;
    }
  }
  &[aria-pressed="false"] {
    ._Indicator {
      color: rgb(255, 72, 0);
      top: 0.1em;
    }
  }
  &[aria-pressed="mixed"] {
    ._Indicator {
      color: grey;
      top: -0.05em;
    }
  }

}

.DatasetEmbed {
  position: relative;
  --editor__bg: white !important;
  ._Data {
    width: 100%;
    max-height: 392px; /* ensure the last line is cut off, as a hint to scroll */
    overflow: scroll;
    background-color: var(--color-chart-bg);
    white-space: pre;
    border-radius: 6px;
  }
  ._Config {
    display: none;
    position: absolute;
    bottom: calc(100% - 0.2em);
    left: 0;
    background-color: var(--color-tag-bg);
    border: 0.5px solid var(--color-tag-border);
    border-radius: var(--radius);
    font-size: 0.6em;
    font-family: var(--font-mono);
    font-weight: 500;
    font-style: normal;
    padding: 0.2em;
  }
  &:hover,
  &:focus {
    ._Config {
      display: block;
    }
  }
}
.ChartEmbed {
  border: 1px solid #ccc;
  display: inline-block;
  height: 400px;
  width: 100%;
  position: relative;
  ._Canvas {
    background-color: var(--color-chart-bg);
    height: 100%;
    width: 100%;
  }
  ._Config {
    display: none;
    position: absolute;
    bottom: calc(100% - 0.2em);
    left: 0;
    background-color: var(--color-tag-bg);
    border: 0.5px solid var(--color-tag-border);
    border-radius: var(--radius);
    font-size: 0.6em;
    font-family: var(--font-mono);
    font-weight: 500;
    font-style: normal;
    padding: 0.2em;
  }
  &:hover,
  &:focus {
    ._Config {
      display: block;
    }
  }
}

.prism-code-editor {
  font-size: 0.8rem;
}

.CodeEditor {
  display: inline-block;
  max-width: 50em;
  width: 100%;
}


#activemd_raw_source {
  background-color: white;
  color: black;
  border: 1px solid var(--color-border);
  padding: 0.5rem;
  display: none;
  position: absolute;
  left: 0.5rem;
  right: 0.5rem;
  top: 1rem;
  height: 92vh;
  overflow: scroll;
}
#activemd_controls_hide_source {
  display: none;
}
#activemd_controls {
  text-align: center;
  font-size: 0.7rem;
  border-bottom: 1px solid var(--color-border);
}

body[data-show_source="true"] {
  position: relative;
  overflow: hidden;
  #activemd_active_doc {
    visibility: hidden;
    pointer-events: none;
  }
  #activemd_raw_source {
    display: block;
  }
  #activemd_controls_hide_source {
    display: inline;
  }
  #activemd_controls_view_source {
    display: none;
  }
  #activemd_controls_download_source {

  }
}

.ActiveCodeBlock {
  border: 1px solid #ccc;
}

.SectionHeader {
  position: relative;
  margin-top: 1rem;
  ._Link {
    position: absolute;
    right: 100%;
    margin-right: 0.35em;
    top: 50%;
    margin-top: -0.65em;
    opacity: 0.5;
    text-decoration: none;
    &:hover {
      opacity: 1;
    }
  }
}
.ct-label{fill:rgba(0,0,0,.4);color:rgba(0,0,0,.4);font-size:.75rem;line-height:1}.ct-chart-bar .ct-label,.ct-chart-line .ct-label{display:flex}.ct-chart-donut .ct-label,.ct-chart-pie .ct-label{dominant-baseline:central}.ct-label.ct-horizontal.ct-start{align-items:flex-end;justify-content:flex-start;text-align:left}.ct-label.ct-horizontal.ct-end{align-items:flex-start;justify-content:flex-start;text-align:left}.ct-label.ct-vertical.ct-start{align-items:flex-end;justify-content:flex-end;text-align:right}.ct-label.ct-vertical.ct-end{align-items:flex-end;justify-content:flex-start;text-align:left}.ct-chart-bar .ct-label.ct-horizontal.ct-start{align-items:flex-end;justify-content:center;text-align:center}.ct-chart-bar .ct-label.ct-horizontal.ct-end{align-items:flex-start;justify-content:center;text-align:center}.ct-chart-bar.ct-horizontal-bars .ct-label.ct-horizontal.ct-start{align-items:flex-end;justify-content:flex-start;text-align:left}.ct-chart-bar.ct-horizontal-bars .ct-label.ct-horizontal.ct-end{align-items:flex-start;justify-content:flex-start;text-align:left}.ct-chart-bar.ct-horizontal-bars .ct-label.ct-vertical.ct-start{align-items:center;justify-content:flex-end;text-align:right}.ct-chart-bar.ct-horizontal-bars .ct-label.ct-vertical.ct-end{align-items:center;justify-content:flex-start;text-align:left}.ct-grid{stroke:rgba(0,0,0,.2);stroke-width:1px;stroke-dasharray:2px}.ct-grid-background{fill:none}.ct-point{stroke-width:10px;stroke-linecap:round}.ct-line{fill:none;stroke-width:4px}.ct-area{stroke:none;fill-opacity:.1}.ct-bar{fill:none;stroke-width:10px}.ct-slice-donut{fill:none;stroke-width:60px}.ct-series-a .ct-bar,.ct-series-a .ct-line,.ct-series-a .ct-point,.ct-series-a .ct-slice-donut{stroke:#d70206}.ct-series-a .ct-area,.ct-series-a .ct-slice-pie{fill:#d70206}.ct-series-b .ct-bar,.ct-series-b .ct-line,.ct-series-b .ct-point,.ct-series-b .ct-slice-donut{stroke:#f05b4f}.ct-series-b .ct-area,.ct-series-b .ct-slice-pie{fill:#f05b4f}.ct-series-c .ct-bar,.ct-series-c .ct-line,.ct-series-c .ct-point,.ct-series-c .ct-slice-donut{stroke:#f4c63d}.ct-series-c .ct-area,.ct-series-c .ct-slice-pie{fill:#f4c63d}.ct-series-d .ct-bar,.ct-series-d .ct-line,.ct-series-d .ct-point,.ct-series-d .ct-slice-donut{stroke:#d17905}.ct-series-d .ct-area,.ct-series-d .ct-slice-pie{fill:#d17905}.ct-series-e .ct-bar,.ct-series-e .ct-line,.ct-series-e .ct-point,.ct-series-e .ct-slice-donut{stroke:#453d3f}.ct-series-e .ct-area,.ct-series-e .ct-slice-pie{fill:#453d3f}.ct-series-f .ct-bar,.ct-series-f .ct-line,.ct-series-f .ct-point,.ct-series-f .ct-slice-donut{stroke:#59922b}.ct-series-f .ct-area,.ct-series-f .ct-slice-pie{fill:#59922b}.ct-series-g .ct-bar,.ct-series-g .ct-line,.ct-series-g .ct-point,.ct-series-g .ct-slice-donut{stroke:#0544d3}.ct-series-g .ct-area,.ct-series-g .ct-slice-pie{fill:#0544d3}.ct-series-h .ct-bar,.ct-series-h .ct-line,.ct-series-h .ct-point,.ct-series-h .ct-slice-donut{stroke:#6b0392}.ct-series-h .ct-area,.ct-series-h .ct-slice-pie{fill:#6b0392}.ct-series-i .ct-bar,.ct-series-i .ct-line,.ct-series-i .ct-point,.ct-series-i .ct-slice-donut{stroke:#e6805e}.ct-series-i .ct-area,.ct-series-i .ct-slice-pie{fill:#e6805e}.ct-series-j .ct-bar,.ct-series-j .ct-line,.ct-series-j .ct-point,.ct-series-j .ct-slice-donut{stroke:#dda458}.ct-series-j .ct-area,.ct-series-j .ct-slice-pie{fill:#dda458}.ct-series-k .ct-bar,.ct-series-k .ct-line,.ct-series-k .ct-point,.ct-series-k .ct-slice-donut{stroke:#eacf7d}.ct-series-k .ct-area,.ct-series-k .ct-slice-pie{fill:#eacf7d}.ct-series-l .ct-bar,.ct-series-l .ct-line,.ct-series-l .ct-point,.ct-series-l .ct-slice-donut{stroke:#86797d}.ct-series-l .ct-area,.ct-series-l .ct-slice-pie{fill:#86797d}.ct-series-m .ct-bar,.ct-series-m .ct-line,.ct-series-m .ct-point,.ct-series-m .ct-slice-donut{stroke:#b2c326}.ct-series-m .ct-area,.ct-series-m .ct-slice-pie{fill:#b2c326}.ct-series-n .ct-bar,.ct-series-n .ct-line,.ct-series-n .ct-point,.ct-series-n .ct-slice-donut{stroke:#6188e2}.ct-series-n .ct-area,.ct-series-n .ct-slice-pie{fill:#6188e2}.ct-series-o .ct-bar,.ct-series-o .ct-line,.ct-series-o .ct-point,.ct-series-o .ct-slice-donut{stroke:#a748ca}.ct-series-o .ct-area,.ct-series-o .ct-slice-pie{fill:#a748ca}.ct-square{display:block;position:relative;width:100%}.ct-square:before{display:block;float:left;content:"";width:0;height:0;padding-bottom:100%}.ct-square:after{content:"";display:table;clear:both}.ct-square>svg{display:block;position:absolute;top:0;left:0}.ct-minor-second{display:block;position:relative;width:100%}.ct-minor-second:before{display:block;float:left;content:"";width:0;height:0;padding-bottom:93.75%}.ct-minor-second:after{content:"";display:table;clear:both}.ct-minor-second>svg{display:block;position:absolute;top:0;left:0}.ct-major-second{display:block;position:relative;width:100%}.ct-major-second:before{display:block;float:left;content:"";width:0;height:0;padding-bottom:88.8888888889%}.ct-major-second:after{content:"";display:table;clear:both}.ct-major-second>svg{display:block;position:absolute;top:0;left:0}.ct-minor-third{display:block;position:relative;width:100%}.ct-minor-third:before{display:block;float:left;content:"";width:0;height:0;padding-bottom:83.3333333333%}.ct-minor-third:after{content:"";display:table;clear:both}.ct-minor-third>svg{display:block;position:absolute;top:0;left:0}.ct-major-third{display:block;position:relative;width:100%}.ct-major-third:before{display:block;float:left;content:"";width:0;height:0;padding-bottom:80%}.ct-major-third:after{content:"";display:table;clear:both}.ct-major-third>svg{display:block;position:absolute;top:0;left:0}.ct-perfect-fourth{display:block;position:relative;width:100%}.ct-perfect-fourth:before{display:block;float:left;content:"";width:0;height:0;padding-bottom:75%}.ct-perfect-fourth:after{content:"";display:table;clear:both}.ct-perfect-fourth>svg{display:block;position:absolute;top:0;left:0}.ct-perfect-fifth{display:block;position:relative;width:100%}.ct-perfect-fifth:before{display:block;float:left;content:"";width:0;height:0;padding-bottom:66.6666666667%}.ct-perfect-fifth:after{content:"";display:table;clear:both}.ct-perfect-fifth>svg{display:block;position:absolute;top:0;left:0}.ct-minor-sixth{display:block;position:relative;width:100%}.ct-minor-sixth:before{display:block;float:left;content:"";width:0;height:0;padding-bottom:62.5%}.ct-minor-sixth:after{content:"";display:table;clear:both}.ct-minor-sixth>svg{display:block;position:absolute;top:0;left:0}.ct-golden-section{display:block;position:relative;width:100%}.ct-golden-section:before{display:block;float:left;content:"";width:0;height:0;padding-bottom:61.804697157%}.ct-golden-section:after{content:"";display:table;clear:both}.ct-golden-section>svg{display:block;position:absolute;top:0;left:0}.ct-major-sixth{display:block;position:relative;width:100%}.ct-major-sixth:before{display:block;float:left;content:"";width:0;height:0;padding-bottom:60%}.ct-major-sixth:after{content:"";display:table;clear:both}.ct-major-sixth>svg{display:block;position:absolute;top:0;left:0}.ct-minor-seventh{display:block;position:relative;width:100%}.ct-minor-seventh:before{display:block;float:left;content:"";width:0;height:0;padding-bottom:56.25%}.ct-minor-seventh:after{content:"";display:table;clear:both}.ct-minor-seventh>svg{display:block;position:absolute;top:0;left:0}.ct-major-seventh{display:block;position:relative;width:100%}.ct-major-seventh:before{display:block;float:left;content:"";width:0;height:0;padding-bottom:53.3333333333%}.ct-major-seventh:after{content:"";display:table;clear:both}.ct-major-seventh>svg{display:block;position:absolute;top:0;left:0}.ct-octave{display:block;position:relative;width:100%}.ct-octave:before{display:block;float:left;content:"";width:0;height:0;padding-bottom:50%}.ct-octave:after{content:"";display:table;clear:both}.ct-octave>svg{display:block;position:absolute;top:0;left:0}.ct-major-tenth{display:block;position:relative;width:100%}.ct-major-tenth:before{display:block;float:left;content:"";width:0;height:0;padding-bottom:40%}.ct-major-tenth:after{content:"";display:table;clear:both}.ct-major-tenth>svg{display:block;position:absolute;top:0;left:0}.ct-major-eleventh{display:block;position:relative;width:100%}.ct-major-eleventh:before{display:block;float:left;content:"";width:0;height:0;padding-bottom:37.5%}.ct-major-eleventh:after{content:"";display:table;clear:both}.ct-major-eleventh>svg{display:block;position:absolute;top:0;left:0}.ct-major-twelfth{display:block;position:relative;width:100%}.ct-major-twelfth:before{display:block;float:left;content:"";width:0;height:0;padding-bottom:33.3333333333%}.ct-major-twelfth:after{content:"";display:table;clear:both}.ct-major-twelfth>svg{display:block;position:absolute;top:0;left:0}.ct-double-octave{display:block;position:relative;width:100%}.ct-double-octave:before{display:block;float:left;content:"";width:0;height:0;padding-bottom:25%}.ct-double-octave:after{content:"";display:table;clear:both}.ct-double-octave>svg{display:block;position:absolute;top:0;left:0}

.prism-code-editor{overflow:auto;display:grid;background:var(--editor__bg);line-height:1.4;--_pse: var(--padding-inline, .75em);--_ns: var(--number-spacing, .75em);--padding-left: var(--_pse);scroll-padding-left:var(--padding-left);-webkit-user-select:none;user-select:none;isolation:isolate;white-space:pre}.show-line-numbers{--padding-left: calc(var(--_pse) + var(--number-width) + var(--_ns));grid:1fr / 0 1fr}.pce-wrapper{margin:.5em 0;position:relative;pointer-events:none;-webkit-text-size-adjust:none;text-size-adjust:none}.prism-code-editor textarea{all:unset;box-sizing:border-box;height:100%;width:100%;color:#0000;-webkit-user-select:auto;user-select:auto;overflow:hidden;pointer-events:auto;padding:0 var(--_pse) 0 var(--padding-left)}.pce-no-selection textarea:focus{z-index:1}.pce-line{padding:0 var(--_pse) 0 0;margin:0 0 0 var(--padding-left);position:relative}.show-line-numbers .pce-line:before{content:attr(data-line);display:inline-block;margin:0 0 0 calc(-1 * var(--padding-left));padding:0 var(--_ns) 0 0;box-sizing:border-box;color:var(--editor__line-number);text-align:end}.show-line-numbers:before{content:"";background:inherit;pointer-events:none}.show-line-numbers:before,.pce-line:before{position:sticky;height:100%;z-index:2;left:0;width:var(--padding-left)}.pce-wrap .pce-line:before{position:absolute}.pce-overlays,div.pce-overlays>*,.pce-no-selection .active-line:after,.active-line.match-highlight:after{content:"";position:absolute;top:0;right:0;bottom:0;left:0}.active-line:after{border:var(--editor__border-highlight);background:var(--editor__bg-highlight);z-index:-2}.pce-wrap{white-space:pre-wrap;word-break:break-word}.selection-matches span{background:var(--editor__bg-selection-match)}.pce-nowrap .active-bracket{display:inline-block}
@media (hover: hover){.prism-code-editor::-webkit-scrollbar-corner,.prism-code-editor::-webkit-scrollbar-track,.prism-code-editor ::-webkit-scrollbar-corner,.prism-code-editor ::-webkit-scrollbar-track{background:#0000}.prism-code-editor::-webkit-scrollbar,.prism-code-editor ::-webkit-scrollbar{height:1em;width:1em}.prism-code-editor::-webkit-scrollbar-thumb,.prism-code-editor ::-webkit-scrollbar-thumb{background:hsla(var(--editor__bg-scrollbar),.36);width:2em;height:2em}.prism-code-editor::-webkit-scrollbar-thumb:hover,.prism-code-editor ::-webkit-scrollbar-thumb:hover{background:hsla(var(--editor__bg-scrollbar),.5)}.prism-code-editor::-webkit-scrollbar-thumb:active,.prism-code-editor ::-webkit-scrollbar-thumb:active{background:hsla(var(--editor__bg-scrollbar),.66)}}
.prism-code-editor{caret-color:#000;font-family:Consolas,Monaco,Andale Mono,Ubuntu Mono,monospace;--editor__bg: #f5f2f0;--widget__border: #bfbfbf;--widget__bg: #edeae8;--widget__color: #444;--widget__color-active: #000;--widget__color-options: #666;--widget__bg-input: #f5f2f0;--widget__bg-hover: #b8b8b84f;--widget__bg-active: #c2dff2;--widget__focus-ring: #0077f0;--search__bg-find: #ea5c0054;--widget__bg-error: #f2dede;--widget__error-ring: #be1100;--editor__bg-highlight: #eae8e6;--editor__bg-selection-match: #b6d5fc80;--editor__line-number: #9d897b;--editor__bg-scrollbar: 24, 7%, 35%;--editor__bg-fold: #424242;--bg-guide-indent: #4b413a33;--pce-ac-icon-class: #d67e00;--pce-ac-icon-enum: #d67e00;--pce-ac-icon-function: #652d90;--pce-ac-icon-interface: #007acc;--pce-ac-icon-variable: #007acc;--pce-ac-match: #0066bf;--pce-tabstop: #0a326433;--pce-invisibles: #3333;color-scheme:light}.prism-code-editor textarea::selection{background:#b6d5fc;color:#0000}.pce-matches .match{--search__bg-find: #c7ada9}.active-line{--editor__line-number: #4d3a2e}.guide-indents .active{--bg-guide-indent: #38322f66}[class*=language-]{color:#000}.token.comment,.token.prolog,.token.doctype,.token.cdata{color:#708090}.token.punctuation,.token.attr-equals{color:#999}.token.namespace{opacity:.7}.token.property,.token.tag,.token.boolean,.token.number,.token.constant,.token.symbol,.token.deleted{color:#905}.token.selector,.token.attr-name,.token.string,.token.char,.token.builtin,.token.inserted{color:#690}.token.operator,.token.entity,.token.url,.language-css .token.string,.style .token.string{color:#9a6e3a}.token.atrule,.token.attr-value,.token.keyword{color:#07a}.token.function,.token.class-name{color:#dd4a68}.token.regex,.language-regex,.token.important,.token.variable{color:#e90}.token.important,.token.bold{font-weight:700}.token.italic{font-style:italic}.token.bracket-level-0,.token.bracket-level-3,.token.bracket-level-6,.token.bracket-level-9{color:#0431fa}.token.bracket-level-1,.token.bracket-level-4,.token.bracket-level-7,.token.bracket-level-10{color:#319331}.token.bracket-level-2,.token.bracket-level-5,.token.bracket-level-8,.token.bracket-level-11{color:#7b3814}.token.bracket-error{color:#ff1212cc}.token.markup-bracket{color:inherit}.active-bracket{box-shadow:inset 0 0 0 1px #b9b9b9,inset 0 0 0 9in #0064001a}.active-tagname,.word-matches span{background:#57575740}
</style>
</head>
<body data-activemd="false" data-filename="examples.md">
  <main id="activemd_active_doc"><h1 id="active-markdown-examples">Active Markdown examples</h1>
<p>This is a series of examples authored using Active Markdown. They demonstrate: the various elements available; how they can be connected with logic using code blocks; how the elements, logic, and datasets can drive charts.</p>
<hr>
<h2 id="cookies">Cookies</h2>
<p>When you eat <span class="js-amd-element" data-config="cookies: 2..100">3 cookies</span>, you consume <strong><span class="js-amd-element" data-config="calories">150. calories</span></strong>. That’s <span class="js-amd-element" data-config="dailypct">7.%</span> of your recommended daily calories.</p>
<pre><code>let kcal_per_cookie = 50;
let daily_calories = 2_100;
calories = cookies * kcal_per_cookie;
dailypct = calories / daily_calories;
</code></pre>
<p>(This example is adapted from the <a href="https://worrydream.com/Tangle/guide.html">Tangle guide</a>, providing a comparison between the two. It shows simple interactivity with a range element, assumptions and logic in the code block, and formatting in the string element. The <code>&lt;strong&gt;</code> is currently necessary because the parser has a bug where it fails to wrap active markdown elements in markdown formatting.)</p>
<hr>
<h2 id="st-ives">St Ives</h2>
<p>An <a href="https://en.wikipedia.org/wiki/As_I_was_going_to_St_Ives">old riddle</a>.</p>
<blockquote>
<p>As <span class="js-amd-element" data-config="solo: I or we">I</span> <span class="js-amd-element" data-config="verb">was</span> going to <strong>St Ives</strong>,<br>I met a man with <span class="js-amd-element" data-config="wives: 1..10">7 wives</span>,<br>Every wife had <span class="js-amd-element" data-config="sacks: 1..10">7 sacks</span>,<br>Every sack had <span class="js-amd-element" data-config="cats: 1..10">7 cats</span>,<br>Every cat had <span class="js-amd-element" data-config="kits: 1..10">7 kits</span>:<br>Kits, cats, sacks, wives,<br>How many were going to St Ives?</p>
</blockquote>
<p>A <em>reasonable</em> guess is <span class="js-amd-element" data-config="first_guess">2752</span>, a sum of the beings the narrator met:</p>
<pre><code>const man   = 1;
total_sacks = wives * sacks;
total_cats  = total_sacks * cats;
total_kits  = total_cats * kits;

first_guess = man + wives + total_cats + total_kits;
</code></pre>
<p>And another guess might follow the second to last line more literally and sum <span class="js-amd-element" data-config="total_kits">2401 kits</span>, <span class="js-amd-element" data-config="total_cats">343 cats</span>, <span class="js-amd-element" data-config="total_sacks">49 sacks</span>, and <span class="js-amd-element" data-config="wives">7 wives</span> for an answer of <span class="js-amd-element" data-config="second_guess">2800</span>:</p>
<pre><code>second_guess = total_kits + total_cats + total_sacks + wives;
</code></pre>
<p>…but the correct answer is <span class="js-amd-element" data-config="answer">1</span>.</p>
<pre><code>if (solo) {
  travelers = 1;
  verb = &#39;was&#39;;
} else {
  travelers = 2;
  verb = &#39;were&#39;;
}

answer = travelers;
</code></pre>
<p>(This example shows switch, range, and string elements combined with logic in code blocks, plus regular markdown formatting.)</p>
<hr>
<h2 id="opposite-over-hypotenuse">Opposite over hypotenuse</h2>
<p>The classic <span class="js-amd-element" data-config="sine: sine or cosine">sine</span> wave is derived from right triangles. The <span class="js-amd-element" data-config="trig">sine</span> of an angle is the ratio of the side of the triangle <span class="js-amd-element" data-config="side">opposite</span> the angle to the hypotenuse of the triangle.</p>
<!-- [![Graphic showing a triangle in a unit circle and the relationship between sine and cosine](https://upload.wikimedia.org/wikipedia/commons/7/72/Sinus_und_Kosinus_am_Einheitskreis_1.svg)](https://commons.wikimedia.org/wiki/File:Sinus_und_Kosinus_am_Einheitskreis_1.svg) -->

<svg viewBox="0 0 10 10" style="max-width: 300px; margin: 0 auto; display: block">
    <path stroke="orange" d="M 3 7 A 4 4, 0, 0, 1, 4 9" fill="none" stroke-linecap="round" stroke-width="0.5" />
    <line id="hypotenuse" x1="1" y1="9" x2="9" y2="1" stroke="black" stroke-linecap="round" stroke-width="0.5" />
    <line id="opposite" x1="9" y1="1" x2="9" y2="9" stroke="black" stroke-linecap="round" stroke-width="0.5" />
    <line id="adjacent" x1="1" y1="9" x2="9" y2="9" stroke="black" stroke-linecap="round" stroke-width="0.5" />
</svg>

<p>Plotting that ratio for a range of angles produces an undulating <span class="js-amd-element" data-config="trig">sine</span> wave graph:</p>
<p><span class="js-amd-embed" data-config="line=trigResult: 0..2pi by 0.025pi">trig of x</span></p>
<p>By including parameters around the <span class="js-amd-element" data-config="trig">sine</span> function in different ways, we can manipulate the resulting wave:</p>
<pre><code>const trigFunction = sine ? Math.sin : Math.cos;
trigResult = function (rad) {
  return amplitude * trigFunction(frequency * rad + x_offset) + y_offset;
}
</code></pre>
<table>
<thead>
<tr>
<th>operation</th>
<th>to</th>
<th>affects</th>
</tr>
</thead>
<tbody><tr>
<td>multiply</td>
<td>trig result</td>
<td><span class="js-amd-element" data-config="amplitude: 0.1..10 by 0.1">amplitude: 1.00</span></td>
</tr>
<tr>
<td>multiply</td>
<td>the angle</td>
<td><span class="js-amd-element" data-config="frequency: 0..10 by 0.25">frequency: 1.00</span></td>
</tr>
<tr>
<td>add</td>
<td>the angle</td>
<td><span class="js-amd-element" data-config="x_offset: -4pi..4pi by 0.0625pi">x offset: 0.00</span></td>
</tr>
<tr>
<td>add</td>
<td>trig result</td>
<td><span class="js-amd-element" data-config="y_offset: -10..10 by 1">y offset: 0.00</span></td>
</tr>
</tbody></table>
<p>The <span class="js-amd-element" data-config="trig">sine</span> function’s companion is the <span class="js-amd-element" data-config="other">cosine</span> function.</p>
<pre><code>const opposite_el = document.getElementById(&#39;opposite&#39;);
const adjacent_el = document.getElementById(&#39;adjacent&#39;);
if (sine) {
  trig = &#39;sine&#39;;
  side = &#39;opposite&#39;;
  other = &#39;cosine&#39;;
  opposite_el.style.stroke = &#39;green&#39;;
  adjacent_el.style.stroke = &#39;black&#39;;
} else {
  trig = &#39;cosine&#39;;
  side = &#39;adjacent&#39;;
  other = &#39;sine&#39;;
  opposite_el.style.stroke = &#39;black&#39;;
  adjacent_el.style.stroke = &#39;red&#39;;
}
</code></pre>
<p>(This example shows: a chart embed; a table; how string elements can repeat the same variable; and manipulation of inline markup from a code block.)</p>
<hr>
<h2 id="crop-yields">Crop yields</h2>
<select name="country">
    <option value="Canada">Canada</option>
    <option value="Mexico" selected>Mexico</option>
    <option value="United States">United States</option>
</select>

<select name="crops" multiple>
    <option value="apples" selected>apples</option>
    <option value="bananas" selected>bananas</option>
    <option value="coffee">coffee</option>
    <option value="oats">oats</option>
    <option value="potatoes">potatoes</option>
    <option value="sugarcane">sugarcane</option>
    <option value="tomatoes">tomatoes</option>
    <option value="wheat">wheat</option>
</select>

<p><span class="js-amd-embed" data-config="bar=selectCrop: 2000..2022">apples,bananas,coffee,oats,potatoes,sugarcane,tomatoes,wheat by year</span></p>
<pre><code>const country_records_by_year = {}
yields.forEach(row =&gt; {
    if (row.country === country) {
        country_records_by_year[row.year] = row;
    }
});
selectCrop = (year) =&gt; {
    const point = { year: year.toString() };
    const record = country_records_by_year[year.toString()];
    crops.forEach(crop =&gt; {
        point[crop] = record[crop];
    })
    return point;
}
</code></pre>
<pre><code class="language-csv=yields">country,year,apples,bananas,coffee,oats,potatoes,sugarcane,tomatoes,wheat
Canada,2000,21.8419,,,2.6076999,11.6314,,51.890697,2.4445999
Canada,2001,21.6806,,,2.1727,10.2703,,52.6036,1.9452
Canada,2002,17.492699,,,2.1109,11.165199,,65.0225,1.8324
Canada,2003,19.431,,,2.3867,11.8424,,66.9062,2.2565
Canada,2004,19.3487,,,2.809,12.363,,74.688896,2.6409
Canada,2005,21.1301,,,2.5822,11.5053,,75.945,2.7380998
Canada,2006,20.2796,,,2.5066,13.0482,,73.8611,2.6095998
Canada,2007,24.3757,,,2.5897,12.649799,,75.0129,2.3316998
Canada,2008,23.97,,,2.9499,12.6065,,75.1541,2.8574998
Canada,2009,25.3975,,,2.9696999,12.745299,,76.4611,2.7897
Canada,2010,22.8393,,,2.7491,39.0809,,74.3847,2.8084998
Canada,2011,25.4084,,,2.9136999,36.6462,,68.0415,2.9568
Canada,2012,17.7194,,,2.8161,38.6092,,84.6532,2.8743
Canada,2013,26.636799,,,3.4803998,41.0606,,83.2355,3.5979998
Canada,2014,25.8183,,,3.1715,41.3836,,66.9768,3.0818
Canada,2015,22.1458,,,3.2684,42.7087,,66.698296,2.8925
Canada,2016,26.3333,,,3.4947,38.7791,,72.8319,3.5805
Canada,2017,25.7547,,,3.5488,39.378,,78.2447,3.3815
Canada,2018,25.6022,,,3.4192,38.9128,,80.361595,3.2742
Canada,2019,24.9704,,,3.6223998,38.775497,,82.511894,3.3834
Canada,2020,25.5739,,,3.4815,36.747997,,82.896194,3.5374
Canada,2021,22.6919,,,2.3883998,41.3325,,82.5077,2.4375
Canada,2022,24.751,,,3.7278998,41.9235,,85.936295,3.4055998
Mexico,2000,6.1765,25.8968,0.4822,1.4108,23.942,71.3267,21.403,4.9354997
Mexico,2001,7.2573,28.542398,0.40539998,1.2791,23.7799,75.7528,22.560099,4.7661
Mexico,2002,7.8771,29.354399,0.43199998,1.5033,23.7558,72.1832,22.4196,5.0999
Mexico,2003,9.0746,28.256498,0.41849998,2.0251,25.4312,73.6874,23.8099,4.4912
Mexico,2004,9.694699,29.9889,0.41079998,1.5374999,24.239899,74.6455,24.3158,4.4871
Mexico,2005,9.807899,29.2316,0.38619998,1.6610999,25.9662,77.1081,23.5938,4.7517
Mexico,2006,10.4179,29.542799,0.3663,2.0007,24.861,74.5303,22.9079,5.2274
Mexico,2007,9.0077,25.9685,0.3479,1.7243999,27.0565,75.443596,26.9893,5.0824
Mexico,2008,9.2607,27.6791,0.3396,1.4688,27.7258,73.8902,28.300798,5.0134
Mexico,2009,9.852099,29.446798,0.3454,1.8120999,27.7374,69.6506,27.1617,4.9688
Mexico,2010,10.125299,27.342299,0.3308,1.6646999,27.7578,71.627396,30.529299,5.4185
Mexico,2011,11.0921,28.790699,0.3445,0.97919995,26.2734,69.6744,28.5325,5.4778
Mexico,2012,6.4164,30.3491,0.354,1.7935,26.8098,69.303,35.5254,5.6568
Mexico,2013,14.503799,28.960299,0.3308,1.8448,26.7752,78.1579,37.6594,5.2934
Mexico,2014,12.9289,28.8331,0.30699998,1.7687,27.3384,74.39,37.143497,5.1935
Mexico,2015,13.6124,29.168999,0.28419998,1.7943,27.1435,73.0233,41.116898,4.5256
Mexico,2016,13.215699,30.448399,0.235,1.8535999,27.925999,72.27,43.3429,5.3388
Mexico,2017,13.3189,28.865599,0.2408,1.6645,28.950499,73.7756,45.6275,5.2967
Mexico,2018,12.592299,29.980799,0.2514,1.9897,29.892,72.326195,50.4785,5.4372997
Mexico,2019,14.3726,30.147,0.2633,2.0719,30.5241,74.5418,48.590298,5.5308
Mexico,2020,12.5948,30.9,0.276,2.2489,31.943499,69.4771,48.7171,5.3212
Mexico,2021,11.307,30.2006,0.2716,2.0527,31.7781,68.2644,45.946598,5.9944
Mexico,2022,14.8803,30.6342,0.2809,2.1376,31.2232,68.3484,46.3956,6.0933
United States,2000,27.348299,22.2572,1.4353,2.3011,42.7161,86.4468,74.9056,2.8237998
United States,2001,25.804499,21.063,1.4235,2.2072,40.180298,83.1538,66.7475,2.7017999
United States,2002,24.1996,16.8587,1.4225999,2.0217,40.5669,85.8602,75.418495,2.3567
United States,2003,25.321499,18.7747,1.5732,2.3327,41.0985,84.313194,68.2474,2.9712
United States,2004,30.5621,18.5926,1.0821999,2.3221,43.815197,76.4143,80.564995,2.9025998
United States,2005,29.3587,23.879099,1.5063,2.2598,43.730297,71.3137,72.5485,2.8230999
United States,2006,30.5857,19.036999,1.2983999,2.1447,44.0949,81.378494,72.182495,2.5986
United States,2007,29.034399,22.076,1.3126999,2.1566,44.433598,77.9588,83.1205,2.7045999
United States,2008,30.9247,17.730299,1.5489999,2.2842,44.437298,71.286896,84.6034,3.0175
United States,2009,31.483,18.853899,1.5489999,2.4369,46.4446,78.0623,87.7269,2.9896998
United States,2010,30.908699,18.143799,1.5647,2.3172,44.943798,69.895096,88.5396,3.1167
United States,2011,31.9842,19.4889,1.3518,2.0547,44.6923,75.076195,92.4535,2.9422
United States,2012,30.9933,18.1845,1.2859,2.1943998,45.7762,80.056496,94.8245,3.1153998
United States,2013,36.2135,18.192299,0.9569,2.2977998,46.3577,75.7099,90.732796,3.1673
United States,2014,41.6171,18.7701,0.9068,2.4338,47.1507,78.5279,97.1661,2.9378
United States,2015,34.7767,16.1994,0.8566,2.5168,46.899998,81.153496,89.461494,2.9299
United States,2016,39.1856,11.5204,0.6926,2.3676999,48.6408,79.7242,91.1398,3.5407999
United States,2017,39.456898,7.9473996,0.756,2.212,48.3887,82.4123,88.647995,3.1174998
United States,2018,39.4965,11.732699,0.86759996,2.3274,49.727398,86.0642,96.8227,3.2005
United States,2019,42.1498,10.2477,0.83089995,2.307,50.752197,78.397995,98.0384,3.4745998
United States,2020,38.971798,9.8925,0.7122,2.3351998,51.636497,85.4005,99.05019,3.3416998
United States,2021,38.5484,10.6138,0.779,2.1980999,49.7352,78.712,95.8863,2.9805
United States,2022,37.9376,10.248,0.8472,2.3235,49.0891,83.705795,95.541794,3.1273
</code></pre>
<p>Data sampled from the dataset by: Hannah Ritchie, Pablo Rosado and Max Roser (2022) - “Crop Yields”, <a href="https://ourworldindata.org/crop-yields">https://ourworldindata.org/crop-yields</a>.</p>
<p>(This example shows use of a native select element, a chart, and a dataset, all connected together through a code block.)</p>
<hr>
<h2 id="air-quality-readings">Air quality readings</h2>
<p>Air quality is a big concern as of late. A major contribution to poor air quality is particulate matter. Different particle sizes have different health impacts. Sensors can detect particles of different sizes.</p>
<p><span class="js-amd-embed" data-config="scatter=particulates: ..">p1_0_um,p2_5_um,p10_0_um by date</span></p>
<p>The readings are provided in particle counts per deciliter of air for a given particle size category, measured in micrometers, or μm.</p>
<p>The 2.5μm reading is important because particles at this size threshold are especially difficult to filter, artificially and by human respiratory systems. These particles can get deep into lungs or cross the blood–brain barrier, and are typically the most harmful. Air filters are rated by how well they filter this category.</p>
<p>Note that these sensors are measuring particles at a given size <em>or smaller</em>. This means the 10μm reading includes the 2.5μm and 1.0μm counts as well.</p>
<!-- TODO: Show readings from <input type="date" name="startdate"> to <input type="date" name="enddate"> -->

<pre><code class="language-json=particulates">[{&quot;date&quot;:&quot;2024-08-01&quot;,&quot;p1_0_um&quot;:43.8,&quot;p2_5_um&quot;:0.79,&quot;p10_0_um&quot;:0.18},
{&quot;date&quot;:&quot;2024-08-02&quot;,&quot;p1_0_um&quot;:128.93,&quot;p2_5_um&quot;:12.07,&quot;p10_0_um&quot;:4.76},
{&quot;date&quot;:&quot;2024-08-03&quot;,&quot;p1_0_um&quot;:42.7,&quot;p2_5_um&quot;:13.68,&quot;p10_0_um&quot;:5.47},
{&quot;date&quot;:&quot;2024-08-04&quot;,&quot;p1_0_um&quot;:13.9,&quot;p2_5_um&quot;:2.24,&quot;p10_0_um&quot;:0.37},
{&quot;date&quot;:&quot;2024-08-05&quot;,&quot;p1_0_um&quot;:17.93,&quot;p2_5_um&quot;:6.18,&quot;p10_0_um&quot;:1.02},
{&quot;date&quot;:&quot;2024-08-06&quot;,&quot;p1_0_um&quot;:91.2,&quot;p2_5_um&quot;:14.23,&quot;p10_0_um&quot;:7.3},
{&quot;date&quot;:&quot;2024-08-07&quot;,&quot;p1_0_um&quot;:49.05,&quot;p2_5_um&quot;:9.75,&quot;p10_0_um&quot;:1.64},
{&quot;date&quot;:&quot;2024-08-08&quot;,&quot;p1_0_um&quot;:19.32,&quot;p2_5_um&quot;:1.63,&quot;p10_0_um&quot;:0.44},
{&quot;date&quot;:&quot;2024-08-09&quot;,&quot;p1_0_um&quot;:36.96,&quot;p2_5_um&quot;:2.64,&quot;p10_0_um&quot;:0.89},
{&quot;date&quot;:&quot;2024-08-10&quot;,&quot;p1_0_um&quot;:41.49,&quot;p2_5_um&quot;:7.29,&quot;p10_0_um&quot;:1.59},
{&quot;date&quot;:&quot;2024-08-11&quot;,&quot;p1_0_um&quot;:47.33,&quot;p2_5_um&quot;:6.95,&quot;p10_0_um&quot;:1.26},
{&quot;date&quot;:&quot;2024-08-12&quot;,&quot;p1_0_um&quot;:30.93,&quot;p2_5_um&quot;:1.69,&quot;p10_0_um&quot;:0.76},
{&quot;date&quot;:&quot;2024-08-13&quot;,&quot;p1_0_um&quot;:15.86,&quot;p2_5_um&quot;:1.97,&quot;p10_0_um&quot;:0.37},
{&quot;date&quot;:&quot;2024-08-14&quot;,&quot;p1_0_um&quot;:32.86,&quot;p2_5_um&quot;:0.21,&quot;p10_0_um&quot;:0},
{&quot;date&quot;:&quot;2024-08-15&quot;,&quot;p1_0_um&quot;:143.12,&quot;p2_5_um&quot;:15.02,&quot;p10_0_um&quot;:5.12},
{&quot;date&quot;:&quot;2024-08-16&quot;,&quot;p1_0_um&quot;:113.05,&quot;p2_5_um&quot;:10.82,&quot;p10_0_um&quot;:5.18},
{&quot;date&quot;:&quot;2024-08-17&quot;,&quot;p1_0_um&quot;:237.41,&quot;p2_5_um&quot;:28.72,&quot;p10_0_um&quot;:13.66},
{&quot;date&quot;:&quot;2024-08-18&quot;,&quot;p1_0_um&quot;:171.52,&quot;p2_5_um&quot;:13.25,&quot;p10_0_um&quot;:5.43},
{&quot;date&quot;:&quot;2024-08-19&quot;,&quot;p1_0_um&quot;:21.02,&quot;p2_5_um&quot;:4.2,&quot;p10_0_um&quot;:0.98},
{&quot;date&quot;:&quot;2024-08-20&quot;,&quot;p1_0_um&quot;:7.83,&quot;p2_5_um&quot;:0.81,&quot;p10_0_um&quot;:0},
{&quot;date&quot;:&quot;2024-08-21&quot;,&quot;p1_0_um&quot;:7.04,&quot;p2_5_um&quot;:2.11,&quot;p10_0_um&quot;:0.86},
{&quot;date&quot;:&quot;2024-08-22&quot;,&quot;p1_0_um&quot;:19.29,&quot;p2_5_um&quot;:4,&quot;p10_0_um&quot;:0.46},
{&quot;date&quot;:&quot;2024-08-23&quot;,&quot;p1_0_um&quot;:47.35,&quot;p2_5_um&quot;:3.87,&quot;p10_0_um&quot;:0.47},
{&quot;date&quot;:&quot;2024-08-24&quot;,&quot;p1_0_um&quot;:57.76,&quot;p2_5_um&quot;:10.83,&quot;p10_0_um&quot;:2.34},
{&quot;date&quot;:&quot;2024-08-25&quot;,&quot;p1_0_um&quot;:98.42,&quot;p2_5_um&quot;:13.37,&quot;p10_0_um&quot;:8.28},
{&quot;date&quot;:&quot;2024-08-26&quot;,&quot;p1_0_um&quot;:99.53,&quot;p2_5_um&quot;:11.52,&quot;p10_0_um&quot;:5.17},
{&quot;date&quot;:&quot;2024-08-27&quot;,&quot;p1_0_um&quot;:93.81,&quot;p2_5_um&quot;:9.4,&quot;p10_0_um&quot;:3.12},
{&quot;date&quot;:&quot;2024-08-28&quot;,&quot;p1_0_um&quot;:76.58,&quot;p2_5_um&quot;:7.59,&quot;p10_0_um&quot;:1.86},
{&quot;date&quot;:&quot;2024-08-29&quot;,&quot;p1_0_um&quot;:53.47,&quot;p2_5_um&quot;:4.41,&quot;p10_0_um&quot;:1.07},
{&quot;date&quot;:&quot;2024-08-30&quot;,&quot;p1_0_um&quot;:23.48,&quot;p2_5_um&quot;:3.41,&quot;p10_0_um&quot;:1.28},
{&quot;date&quot;:&quot;2024-08-31&quot;,&quot;p1_0_um&quot;:12.4,&quot;p2_5_um&quot;:3.5,&quot;p10_0_um&quot;:0.67}]
</code></pre>
<p>(This example shows a scatter-type chart with multiple series, being driven directly from a JSON dataset, using the text content of the chart element definition to specify the axes. Note the x-axis labels are messy. The ChartEmbed currently does not automatically adjust the labeling well, so it’s best to stick to short labels.)</p>
</main>
  <textarea disabled id="activemd_raw_source">---%0Atitle%3A%20Active%20Markdown%20examples%0A---%0A%0A%23%20Active%20Markdown%20examples%0A%0AThis%20is%20a%20series%20of%20examples%20authored%20using%20Active%20Markdown.%20They%20demonstrate%3A%20the%20various%20elements%20available%3B%20how%20they%20can%20be%20connected%20with%20logic%20using%20code%20blocks%3B%20how%20the%20elements%2C%20logic%2C%20and%20datasets%20can%20drive%20charts.%0A%0A%0A-%20-%20-%0A%0A%0A%23%23%20Cookies%0A%0AWhen%20you%20eat%20%5B3%20cookies%5D%7Bcookies%3A%202..100%7D%2C%20you%20consume%20%3Cstrong%3E%5B150.%20calories%5D%7Bcalories%7D%3C%2Fstrong%3E.%20That%E2%80%99s%20%5B7.%25%5D%7Bdailypct%7D%20of%20your%20recommended%20daily%20calories.%0A%0A%20%20%20%20let%20kcal_per_cookie%20%3D%2050%3B%0A%20%20%20%20let%20daily_calories%20%3D%202_100%3B%0A%20%20%20%20calories%20%3D%20cookies%20*%20kcal_per_cookie%3B%0A%20%20%20%20dailypct%20%3D%20calories%20%2F%20daily_calories%3B%0A%0A(This%20example%20is%20adapted%20from%20the%20%5BTangle%20guide%5D(https%3A%2F%2Fworrydream.com%2FTangle%2Fguide.html)%2C%20providing%20a%20comparison%20between%20the%20two.%20It%20shows%20simple%20interactivity%20with%20a%20range%20element%2C%20assumptions%20and%20logic%20in%20the%20code%20block%2C%20and%20formatting%20in%20the%20string%20element.%20The%20%60%3Cstrong%3E%60%20is%20currently%20necessary%20because%20the%20parser%20has%20a%20bug%20where%20it%20fails%20to%20wrap%20active%20markdown%20elements%20in%20markdown%20formatting.)%0A%0A%0A-%20-%20-%0A%0A%0A%23%23%20St%20Ives%0A%0AAn%20%5Bold%20riddle%5D(https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FAs_I_was_going_to_St_Ives).%0A%0A%3E%20As%20%5BI%5D%7Bsolo%3A%20I%20or%20we%7D%20%5Bwas%5D%7Bverb%7D%20going%20to%20**St%20Ives**%2C%0A%3E%20I%20met%20a%20man%20with%20%5B7%20wives%5D%7Bwives%3A%201..10%7D%2C%0A%3E%20Every%20wife%20had%20%5B7%20sacks%5D%7Bsacks%3A%201..10%7D%2C%0A%3E%20Every%20sack%20had%20%5B7%20cats%5D%7Bcats%3A%201..10%7D%2C%0A%3E%20Every%20cat%20had%20%5B7%20kits%5D%7Bkits%3A%201..10%7D%3A%0A%3E%20Kits%2C%20cats%2C%20sacks%2C%20wives%2C%0A%3E%20How%20many%20were%20going%20to%20St%20Ives%3F%0A%0AA%20_reasonable_%20guess%20is%20%5B2752%5D%7Bfirst_guess%7D%2C%20a%20sum%20of%20the%20beings%20the%20narrator%20met%3A%0A%0A%20%20%20%20const%20man%20%20%20%3D%201%3B%0A%20%20%20%20total_sacks%20%3D%20wives%20*%20sacks%3B%0A%20%20%20%20total_cats%20%20%3D%20total_sacks%20*%20cats%3B%0A%20%20%20%20total_kits%20%20%3D%20total_cats%20*%20kits%3B%0A%0A%20%20%20%20first_guess%20%3D%20man%20%2B%20wives%20%2B%20total_cats%20%2B%20total_kits%3B%0A%0AAnd%20another%20guess%20might%20follow%20the%20second%20to%20last%20line%20more%20literally%20and%20sum%20%5B2401%20kits%5D%7Btotal_kits%7D%2C%20%5B343%20cats%5D%7Btotal_cats%7D%2C%20%5B49%20sacks%5D%7Btotal_sacks%7D%2C%20and%20%5B7%20wives%5D%7Bwives%7D%20for%20an%20answer%20of%20%5B2800%5D%7Bsecond_guess%7D%3A%0A%0A%20%20%20%20second_guess%20%3D%20total_kits%20%2B%20total_cats%20%2B%20total_sacks%20%2B%20wives%3B%0A%0A%E2%80%A6but%20the%20correct%20answer%20is%20%5B1%5D%7Banswer%7D.%0A%0A%20%20%20%20if%20(solo)%20%7B%0A%20%20%20%20%20%20travelers%20%3D%201%3B%0A%20%20%20%20%20%20verb%20%3D%20'was'%3B%0A%20%20%20%20%7D%20else%20%7B%0A%20%20%20%20%20%20travelers%20%3D%202%3B%0A%20%20%20%20%20%20verb%20%3D%20'were'%3B%0A%20%20%20%20%7D%0A%0A%20%20%20%20answer%20%3D%20travelers%3B%0A%0A(This%20example%20shows%20switch%2C%20range%2C%20and%20string%20elements%20combined%20with%20logic%20in%20code%20blocks%2C%20plus%20regular%20markdown%20formatting.)%0A%0A%0A-%20-%20-%0A%0A%0A%0A%23%23%20Opposite%20over%20hypotenuse%0A%0AThe%20classic%20%5Bsine%5D%7Bsine%3A%20sine%20or%20cosine%7D%20wave%20is%20derived%20from%20right%20triangles.%20The%20%5Bsine%5D%7Btrig%7D%20of%20an%20angle%20is%20the%20ratio%20of%20the%20side%20of%20the%20triangle%20%5Bopposite%5D%7Bside%7D%20the%20angle%20to%20the%20hypotenuse%20of%20the%20triangle.%0A%0A%3C!--%20%5B!%5BGraphic%20showing%20a%20triangle%20in%20a%20unit%20circle%20and%20the%20relationship%20between%20sine%20and%20cosine%5D(https%3A%2F%2Fupload.wikimedia.org%2Fwikipedia%2Fcommons%2F7%2F72%2FSinus_und_Kosinus_am_Einheitskreis_1.svg)%5D(https%3A%2F%2Fcommons.wikimedia.org%2Fwiki%2FFile%3ASinus_und_Kosinus_am_Einheitskreis_1.svg)%20--%3E%0A%0A%3Csvg%20viewBox%3D%220%200%2010%2010%22%20style%3D%22max-width%3A%20300px%3B%20margin%3A%200%20auto%3B%20display%3A%20block%22%3E%0A%20%20%20%20%3Cpath%20stroke%3D%22orange%22%20d%3D%22M%203%207%20A%204%204%2C%200%2C%200%2C%201%2C%204%209%22%20fill%3D%22none%22%20stroke-linecap%3D%22round%22%20stroke-width%3D%220.5%22%20%2F%3E%0A%20%20%20%20%3Cline%20id%3D%22hypotenuse%22%20x1%3D%221%22%20y1%3D%229%22%20x2%3D%229%22%20y2%3D%221%22%20stroke%3D%22black%22%20stroke-linecap%3D%22round%22%20stroke-width%3D%220.5%22%20%2F%3E%0A%20%20%20%20%3Cline%20id%3D%22opposite%22%20x1%3D%229%22%20y1%3D%221%22%20x2%3D%229%22%20y2%3D%229%22%20stroke%3D%22black%22%20stroke-linecap%3D%22round%22%20stroke-width%3D%220.5%22%20%2F%3E%0A%20%20%20%20%3Cline%20id%3D%22adjacent%22%20x1%3D%221%22%20y1%3D%229%22%20x2%3D%229%22%20y2%3D%229%22%20stroke%3D%22black%22%20stroke-linecap%3D%22round%22%20stroke-width%3D%220.5%22%20%2F%3E%0A%3C%2Fsvg%3E%0A%0APlotting%20that%20ratio%20for%20a%20range%20of%20angles%20produces%20an%20undulating%20%5Bsine%5D%7Btrig%7D%20wave%20graph%3A%0A%0A!%5Btrig%20of%20x%5D%7Bline%3DtrigResult%3A%200..2pi%20by%200.025pi%7D%0A%0ABy%20including%20parameters%20around%20the%20%5Bsine%5D%7Btrig%7D%20function%20in%20different%20ways%2C%20we%20can%20manipulate%20the%20resulting%20wave%3A%0A%0A%20%20%20%20const%20trigFunction%20%3D%20sine%20%3F%20Math.sin%20%3A%20Math.cos%3B%0A%20%20%20%20trigResult%20%3D%20function%20(rad)%20%7B%0A%20%20%20%20%20%20return%20amplitude%20*%20trigFunction(frequency%20*%20rad%20%2B%20x_offset)%20%2B%20y_offset%3B%0A%20%20%20%20%7D%0A%0A%7C%20operation%20%7C%20to%20%20%20%20%20%20%20%20%20%20%20%7C%20affects%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%7C%0A%7C-----------%7C--------------%7C---------------------------------------------------%7C%0A%7C%20multiply%20%20%7C%20trig%20result%20%20%7C%20%5Bamplitude%3A%201.00%5D%7Bamplitude%3A%200.1..10%20by%200.1%7D%20%20%20%20%20%20%7C%0A%7C%20multiply%20%20%7C%20the%20angle%20%20%20%20%7C%20%5Bfrequency%3A%201.00%5D%7Bfrequency%3A%200..10%20by%200.25%7D%20%20%20%20%20%20%20%7C%0A%7C%20add%20%20%20%20%20%20%20%7C%20the%20angle%20%20%20%20%7C%20%5Bx%20offset%3A%200.00%5D%7Bx_offset%3A%20-4pi..4pi%20by%200.0625pi%7D%20%7C%0A%7C%20add%20%20%20%20%20%20%20%7C%20trig%20result%20%20%7C%20%5By%20offset%3A%200.00%5D%7By_offset%3A%20-10..10%20by%201%7D%20%20%20%20%20%20%20%20%20%20%7C%0A%0A%0AThe%20%5Bsine%5D%7Btrig%7D%20function%E2%80%99s%20companion%20is%20the%20%5Bcosine%5D%7Bother%7D%20function.%0A%0A%20%20%20%20const%20opposite_el%20%3D%20document.getElementById('opposite')%3B%0A%20%20%20%20const%20adjacent_el%20%3D%20document.getElementById('adjacent')%3B%0A%20%20%20%20if%20(sine)%20%7B%0A%20%20%20%20%20%20trig%20%3D%20'sine'%3B%0A%20%20%20%20%20%20side%20%3D%20'opposite'%3B%0A%20%20%20%20%20%20other%20%3D%20'cosine'%3B%0A%20%20%20%20%20%20opposite_el.style.stroke%20%3D%20'green'%3B%0A%20%20%20%20%20%20adjacent_el.style.stroke%20%3D%20'black'%3B%0A%20%20%20%20%7D%20else%20%7B%0A%20%20%20%20%20%20trig%20%3D%20'cosine'%3B%0A%20%20%20%20%20%20side%20%3D%20'adjacent'%3B%0A%20%20%20%20%20%20other%20%3D%20'sine'%3B%0A%20%20%20%20%20%20opposite_el.style.stroke%20%3D%20'black'%3B%0A%20%20%20%20%20%20adjacent_el.style.stroke%20%3D%20'red'%3B%0A%20%20%20%20%7D%0A%0A(This%20example%20shows%3A%20a%20chart%20embed%3B%20a%20table%3B%20how%20string%20elements%20can%20repeat%20the%20same%20variable%3B%20and%20manipulation%20of%20inline%20markup%20from%20a%20code%20block.)%0A%0A%0A-%20-%20-%0A%0A%0A%23%23%20Crop%20yields%0A%0A%0A%3Cselect%20name%3D%22country%22%3E%0A%20%20%20%20%3Coption%20value%3D%22Canada%22%3ECanada%3C%2Foption%3E%0A%20%20%20%20%3Coption%20value%3D%22Mexico%22%20selected%3EMexico%3C%2Foption%3E%0A%20%20%20%20%3Coption%20value%3D%22United%20States%22%3EUnited%20States%3C%2Foption%3E%0A%3C%2Fselect%3E%0A%0A%3Cselect%20name%3D%22crops%22%20multiple%3E%0A%20%20%20%20%3Coption%20value%3D%22apples%22%20selected%3Eapples%3C%2Foption%3E%0A%20%20%20%20%3Coption%20value%3D%22bananas%22%20selected%3Ebananas%3C%2Foption%3E%0A%20%20%20%20%3Coption%20value%3D%22coffee%22%3Ecoffee%3C%2Foption%3E%0A%20%20%20%20%3Coption%20value%3D%22oats%22%3Eoats%3C%2Foption%3E%0A%20%20%20%20%3Coption%20value%3D%22potatoes%22%3Epotatoes%3C%2Foption%3E%0A%20%20%20%20%3Coption%20value%3D%22sugarcane%22%3Esugarcane%3C%2Foption%3E%0A%20%20%20%20%3Coption%20value%3D%22tomatoes%22%3Etomatoes%3C%2Foption%3E%0A%20%20%20%20%3Coption%20value%3D%22wheat%22%3Ewheat%3C%2Foption%3E%0A%3C%2Fselect%3E%0A%0A!%5Bapples%2Cbananas%2Ccoffee%2Coats%2Cpotatoes%2Csugarcane%2Ctomatoes%2Cwheat%20by%20year%5D%7Bbar%3DselectCrop%3A%202000..2022%7D%0A%0A%20%20%20%20const%20country_records_by_year%20%3D%20%7B%7D%0A%20%20%20%20yields.forEach(row%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20if%20(row.country%20%3D%3D%3D%20country)%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20country_records_by_year%5Brow.year%5D%20%3D%20row%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D)%3B%0A%20%20%20%20selectCrop%20%3D%20(year)%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20const%20point%20%3D%20%7B%20year%3A%20year.toString()%20%7D%3B%0A%20%20%20%20%20%20%20%20const%20record%20%3D%20country_records_by_year%5Byear.toString()%5D%3B%0A%20%20%20%20%20%20%20%20crops.forEach(crop%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20point%5Bcrop%5D%20%3D%20record%5Bcrop%5D%3B%0A%20%20%20%20%20%20%20%20%7D)%0A%20%20%20%20%20%20%20%20return%20point%3B%0A%20%20%20%20%7D%0A%0A%0A%60%60%60csv%3Dyields%0Acountry%2Cyear%2Capples%2Cbananas%2Ccoffee%2Coats%2Cpotatoes%2Csugarcane%2Ctomatoes%2Cwheat%0ACanada%2C2000%2C21.8419%2C%2C%2C2.6076999%2C11.6314%2C%2C51.890697%2C2.4445999%0ACanada%2C2001%2C21.6806%2C%2C%2C2.1727%2C10.2703%2C%2C52.6036%2C1.9452%0ACanada%2C2002%2C17.492699%2C%2C%2C2.1109%2C11.165199%2C%2C65.0225%2C1.8324%0ACanada%2C2003%2C19.431%2C%2C%2C2.3867%2C11.8424%2C%2C66.9062%2C2.2565%0ACanada%2C2004%2C19.3487%2C%2C%2C2.809%2C12.363%2C%2C74.688896%2C2.6409%0ACanada%2C2005%2C21.1301%2C%2C%2C2.5822%2C11.5053%2C%2C75.945%2C2.7380998%0ACanada%2C2006%2C20.2796%2C%2C%2C2.5066%2C13.0482%2C%2C73.8611%2C2.6095998%0ACanada%2C2007%2C24.3757%2C%2C%2C2.5897%2C12.649799%2C%2C75.0129%2C2.3316998%0ACanada%2C2008%2C23.97%2C%2C%2C2.9499%2C12.6065%2C%2C75.1541%2C2.8574998%0ACanada%2C2009%2C25.3975%2C%2C%2C2.9696999%2C12.745299%2C%2C76.4611%2C2.7897%0ACanada%2C2010%2C22.8393%2C%2C%2C2.7491%2C39.0809%2C%2C74.3847%2C2.8084998%0ACanada%2C2011%2C25.4084%2C%2C%2C2.9136999%2C36.6462%2C%2C68.0415%2C2.9568%0ACanada%2C2012%2C17.7194%2C%2C%2C2.8161%2C38.6092%2C%2C84.6532%2C2.8743%0ACanada%2C2013%2C26.636799%2C%2C%2C3.4803998%2C41.0606%2C%2C83.2355%2C3.5979998%0ACanada%2C2014%2C25.8183%2C%2C%2C3.1715%2C41.3836%2C%2C66.9768%2C3.0818%0ACanada%2C2015%2C22.1458%2C%2C%2C3.2684%2C42.7087%2C%2C66.698296%2C2.8925%0ACanada%2C2016%2C26.3333%2C%2C%2C3.4947%2C38.7791%2C%2C72.8319%2C3.5805%0ACanada%2C2017%2C25.7547%2C%2C%2C3.5488%2C39.378%2C%2C78.2447%2C3.3815%0ACanada%2C2018%2C25.6022%2C%2C%2C3.4192%2C38.9128%2C%2C80.361595%2C3.2742%0ACanada%2C2019%2C24.9704%2C%2C%2C3.6223998%2C38.775497%2C%2C82.511894%2C3.3834%0ACanada%2C2020%2C25.5739%2C%2C%2C3.4815%2C36.747997%2C%2C82.896194%2C3.5374%0ACanada%2C2021%2C22.6919%2C%2C%2C2.3883998%2C41.3325%2C%2C82.5077%2C2.4375%0ACanada%2C2022%2C24.751%2C%2C%2C3.7278998%2C41.9235%2C%2C85.936295%2C3.4055998%0AMexico%2C2000%2C6.1765%2C25.8968%2C0.4822%2C1.4108%2C23.942%2C71.3267%2C21.403%2C4.9354997%0AMexico%2C2001%2C7.2573%2C28.542398%2C0.40539998%2C1.2791%2C23.7799%2C75.7528%2C22.560099%2C4.7661%0AMexico%2C2002%2C7.8771%2C29.354399%2C0.43199998%2C1.5033%2C23.7558%2C72.1832%2C22.4196%2C5.0999%0AMexico%2C2003%2C9.0746%2C28.256498%2C0.41849998%2C2.0251%2C25.4312%2C73.6874%2C23.8099%2C4.4912%0AMexico%2C2004%2C9.694699%2C29.9889%2C0.41079998%2C1.5374999%2C24.239899%2C74.6455%2C24.3158%2C4.4871%0AMexico%2C2005%2C9.807899%2C29.2316%2C0.38619998%2C1.6610999%2C25.9662%2C77.1081%2C23.5938%2C4.7517%0AMexico%2C2006%2C10.4179%2C29.542799%2C0.3663%2C2.0007%2C24.861%2C74.5303%2C22.9079%2C5.2274%0AMexico%2C2007%2C9.0077%2C25.9685%2C0.3479%2C1.7243999%2C27.0565%2C75.443596%2C26.9893%2C5.0824%0AMexico%2C2008%2C9.2607%2C27.6791%2C0.3396%2C1.4688%2C27.7258%2C73.8902%2C28.300798%2C5.0134%0AMexico%2C2009%2C9.852099%2C29.446798%2C0.3454%2C1.8120999%2C27.7374%2C69.6506%2C27.1617%2C4.9688%0AMexico%2C2010%2C10.125299%2C27.342299%2C0.3308%2C1.6646999%2C27.7578%2C71.627396%2C30.529299%2C5.4185%0AMexico%2C2011%2C11.0921%2C28.790699%2C0.3445%2C0.97919995%2C26.2734%2C69.6744%2C28.5325%2C5.4778%0AMexico%2C2012%2C6.4164%2C30.3491%2C0.354%2C1.7935%2C26.8098%2C69.303%2C35.5254%2C5.6568%0AMexico%2C2013%2C14.503799%2C28.960299%2C0.3308%2C1.8448%2C26.7752%2C78.1579%2C37.6594%2C5.2934%0AMexico%2C2014%2C12.9289%2C28.8331%2C0.30699998%2C1.7687%2C27.3384%2C74.39%2C37.143497%2C5.1935%0AMexico%2C2015%2C13.6124%2C29.168999%2C0.28419998%2C1.7943%2C27.1435%2C73.0233%2C41.116898%2C4.5256%0AMexico%2C2016%2C13.215699%2C30.448399%2C0.235%2C1.8535999%2C27.925999%2C72.27%2C43.3429%2C5.3388%0AMexico%2C2017%2C13.3189%2C28.865599%2C0.2408%2C1.6645%2C28.950499%2C73.7756%2C45.6275%2C5.2967%0AMexico%2C2018%2C12.592299%2C29.980799%2C0.2514%2C1.9897%2C29.892%2C72.326195%2C50.4785%2C5.4372997%0AMexico%2C2019%2C14.3726%2C30.147%2C0.2633%2C2.0719%2C30.5241%2C74.5418%2C48.590298%2C5.5308%0AMexico%2C2020%2C12.5948%2C30.9%2C0.276%2C2.2489%2C31.943499%2C69.4771%2C48.7171%2C5.3212%0AMexico%2C2021%2C11.307%2C30.2006%2C0.2716%2C2.0527%2C31.7781%2C68.2644%2C45.946598%2C5.9944%0AMexico%2C2022%2C14.8803%2C30.6342%2C0.2809%2C2.1376%2C31.2232%2C68.3484%2C46.3956%2C6.0933%0AUnited%20States%2C2000%2C27.348299%2C22.2572%2C1.4353%2C2.3011%2C42.7161%2C86.4468%2C74.9056%2C2.8237998%0AUnited%20States%2C2001%2C25.804499%2C21.063%2C1.4235%2C2.2072%2C40.180298%2C83.1538%2C66.7475%2C2.7017999%0AUnited%20States%2C2002%2C24.1996%2C16.8587%2C1.4225999%2C2.0217%2C40.5669%2C85.8602%2C75.418495%2C2.3567%0AUnited%20States%2C2003%2C25.321499%2C18.7747%2C1.5732%2C2.3327%2C41.0985%2C84.313194%2C68.2474%2C2.9712%0AUnited%20States%2C2004%2C30.5621%2C18.5926%2C1.0821999%2C2.3221%2C43.815197%2C76.4143%2C80.564995%2C2.9025998%0AUnited%20States%2C2005%2C29.3587%2C23.879099%2C1.5063%2C2.2598%2C43.730297%2C71.3137%2C72.5485%2C2.8230999%0AUnited%20States%2C2006%2C30.5857%2C19.036999%2C1.2983999%2C2.1447%2C44.0949%2C81.378494%2C72.182495%2C2.5986%0AUnited%20States%2C2007%2C29.034399%2C22.076%2C1.3126999%2C2.1566%2C44.433598%2C77.9588%2C83.1205%2C2.7045999%0AUnited%20States%2C2008%2C30.9247%2C17.730299%2C1.5489999%2C2.2842%2C44.437298%2C71.286896%2C84.6034%2C3.0175%0AUnited%20States%2C2009%2C31.483%2C18.853899%2C1.5489999%2C2.4369%2C46.4446%2C78.0623%2C87.7269%2C2.9896998%0AUnited%20States%2C2010%2C30.908699%2C18.143799%2C1.5647%2C2.3172%2C44.943798%2C69.895096%2C88.5396%2C3.1167%0AUnited%20States%2C2011%2C31.9842%2C19.4889%2C1.3518%2C2.0547%2C44.6923%2C75.076195%2C92.4535%2C2.9422%0AUnited%20States%2C2012%2C30.9933%2C18.1845%2C1.2859%2C2.1943998%2C45.7762%2C80.056496%2C94.8245%2C3.1153998%0AUnited%20States%2C2013%2C36.2135%2C18.192299%2C0.9569%2C2.2977998%2C46.3577%2C75.7099%2C90.732796%2C3.1673%0AUnited%20States%2C2014%2C41.6171%2C18.7701%2C0.9068%2C2.4338%2C47.1507%2C78.5279%2C97.1661%2C2.9378%0AUnited%20States%2C2015%2C34.7767%2C16.1994%2C0.8566%2C2.5168%2C46.899998%2C81.153496%2C89.461494%2C2.9299%0AUnited%20States%2C2016%2C39.1856%2C11.5204%2C0.6926%2C2.3676999%2C48.6408%2C79.7242%2C91.1398%2C3.5407999%0AUnited%20States%2C2017%2C39.456898%2C7.9473996%2C0.756%2C2.212%2C48.3887%2C82.4123%2C88.647995%2C3.1174998%0AUnited%20States%2C2018%2C39.4965%2C11.732699%2C0.86759996%2C2.3274%2C49.727398%2C86.0642%2C96.8227%2C3.2005%0AUnited%20States%2C2019%2C42.1498%2C10.2477%2C0.83089995%2C2.307%2C50.752197%2C78.397995%2C98.0384%2C3.4745998%0AUnited%20States%2C2020%2C38.971798%2C9.8925%2C0.7122%2C2.3351998%2C51.636497%2C85.4005%2C99.05019%2C3.3416998%0AUnited%20States%2C2021%2C38.5484%2C10.6138%2C0.779%2C2.1980999%2C49.7352%2C78.712%2C95.8863%2C2.9805%0AUnited%20States%2C2022%2C37.9376%2C10.248%2C0.8472%2C2.3235%2C49.0891%2C83.705795%2C95.541794%2C3.1273%0A%60%60%60%0A%0AData%20sampled%20from%20the%20dataset%20by%3A%20Hannah%20Ritchie%2C%20Pablo%20Rosado%20and%20Max%20Roser%20(2022)%20-%20%E2%80%9CCrop%20Yields%E2%80%9D%2C%20https%3A%2F%2Fourworldindata.org%2Fcrop-yields.%0A%0A%0A(This%20example%20shows%20use%20of%20a%20native%20select%20element%2C%20a%20chart%2C%20and%20a%20dataset%2C%20all%20connected%20together%20through%20a%20code%20block.)%0A%0A%0A-%20-%20-%0A%0A%0A%23%23%20Air%20quality%20readings%0A%0AAir%20quality%20is%20a%20big%20concern%20as%20of%20late.%20A%20major%20contribution%20to%20poor%20air%20quality%20is%20particulate%20matter.%20Different%20particle%20sizes%20have%20different%20health%20impacts.%20Sensors%20can%20detect%20particles%20of%20different%20sizes.%0A%0A!%5Bp1_0_um%2Cp2_5_um%2Cp10_0_um%20by%20date%5D%7Bscatter%3Dparticulates%3A%20..%7D%0A%0AThe%20readings%20are%20provided%20in%20particle%20counts%20per%20deciliter%20of%20air%20for%20a%20given%20particle%20size%20category%2C%20measured%20in%20micrometers%2C%20or%20%CE%BCm.%0A%0AThe%202.5%CE%BCm%20reading%20is%20important%20because%20particles%20at%20this%20size%20threshold%20are%20especially%20difficult%20to%20filter%2C%20artificially%20and%20by%20human%20respiratory%20systems.%20These%20particles%20can%20get%20deep%20into%20lungs%20or%20cross%20the%20blood%E2%80%93brain%20barrier%2C%20and%20are%20typically%20the%20most%20harmful.%20Air%20filters%20are%20rated%20by%20how%20well%20they%20filter%20this%20category.%0A%0ANote%20that%20these%20sensors%20are%20measuring%20particles%20at%20a%20given%20size%20_or%20smaller_.%20This%20means%20the%2010%CE%BCm%20reading%20includes%20the%202.5%CE%BCm%20and%201.0%CE%BCm%20counts%20as%20well.%0A%0A%3C!--%20TODO%3A%20Show%20readings%20from%20%3Cinput%20type%3D%22date%22%20name%3D%22startdate%22%3E%20to%20%3Cinput%20type%3D%22date%22%20name%3D%22enddate%22%3E%20--%3E%0A%0A%60%60%60json%3Dparticulates%0A%5B%7B%22date%22%3A%222024-08-01%22%2C%22p1_0_um%22%3A43.8%2C%22p2_5_um%22%3A0.79%2C%22p10_0_um%22%3A0.18%7D%2C%0A%7B%22date%22%3A%222024-08-02%22%2C%22p1_0_um%22%3A128.93%2C%22p2_5_um%22%3A12.07%2C%22p10_0_um%22%3A4.76%7D%2C%0A%7B%22date%22%3A%222024-08-03%22%2C%22p1_0_um%22%3A42.7%2C%22p2_5_um%22%3A13.68%2C%22p10_0_um%22%3A5.47%7D%2C%0A%7B%22date%22%3A%222024-08-04%22%2C%22p1_0_um%22%3A13.9%2C%22p2_5_um%22%3A2.24%2C%22p10_0_um%22%3A0.37%7D%2C%0A%7B%22date%22%3A%222024-08-05%22%2C%22p1_0_um%22%3A17.93%2C%22p2_5_um%22%3A6.18%2C%22p10_0_um%22%3A1.02%7D%2C%0A%7B%22date%22%3A%222024-08-06%22%2C%22p1_0_um%22%3A91.2%2C%22p2_5_um%22%3A14.23%2C%22p10_0_um%22%3A7.3%7D%2C%0A%7B%22date%22%3A%222024-08-07%22%2C%22p1_0_um%22%3A49.05%2C%22p2_5_um%22%3A9.75%2C%22p10_0_um%22%3A1.64%7D%2C%0A%7B%22date%22%3A%222024-08-08%22%2C%22p1_0_um%22%3A19.32%2C%22p2_5_um%22%3A1.63%2C%22p10_0_um%22%3A0.44%7D%2C%0A%7B%22date%22%3A%222024-08-09%22%2C%22p1_0_um%22%3A36.96%2C%22p2_5_um%22%3A2.64%2C%22p10_0_um%22%3A0.89%7D%2C%0A%7B%22date%22%3A%222024-08-10%22%2C%22p1_0_um%22%3A41.49%2C%22p2_5_um%22%3A7.29%2C%22p10_0_um%22%3A1.59%7D%2C%0A%7B%22date%22%3A%222024-08-11%22%2C%22p1_0_um%22%3A47.33%2C%22p2_5_um%22%3A6.95%2C%22p10_0_um%22%3A1.26%7D%2C%0A%7B%22date%22%3A%222024-08-12%22%2C%22p1_0_um%22%3A30.93%2C%22p2_5_um%22%3A1.69%2C%22p10_0_um%22%3A0.76%7D%2C%0A%7B%22date%22%3A%222024-08-13%22%2C%22p1_0_um%22%3A15.86%2C%22p2_5_um%22%3A1.97%2C%22p10_0_um%22%3A0.37%7D%2C%0A%7B%22date%22%3A%222024-08-14%22%2C%22p1_0_um%22%3A32.86%2C%22p2_5_um%22%3A0.21%2C%22p10_0_um%22%3A0%7D%2C%0A%7B%22date%22%3A%222024-08-15%22%2C%22p1_0_um%22%3A143.12%2C%22p2_5_um%22%3A15.02%2C%22p10_0_um%22%3A5.12%7D%2C%0A%7B%22date%22%3A%222024-08-16%22%2C%22p1_0_um%22%3A113.05%2C%22p2_5_um%22%3A10.82%2C%22p10_0_um%22%3A5.18%7D%2C%0A%7B%22date%22%3A%222024-08-17%22%2C%22p1_0_um%22%3A237.41%2C%22p2_5_um%22%3A28.72%2C%22p10_0_um%22%3A13.66%7D%2C%0A%7B%22date%22%3A%222024-08-18%22%2C%22p1_0_um%22%3A171.52%2C%22p2_5_um%22%3A13.25%2C%22p10_0_um%22%3A5.43%7D%2C%0A%7B%22date%22%3A%222024-08-19%22%2C%22p1_0_um%22%3A21.02%2C%22p2_5_um%22%3A4.2%2C%22p10_0_um%22%3A0.98%7D%2C%0A%7B%22date%22%3A%222024-08-20%22%2C%22p1_0_um%22%3A7.83%2C%22p2_5_um%22%3A0.81%2C%22p10_0_um%22%3A0%7D%2C%0A%7B%22date%22%3A%222024-08-21%22%2C%22p1_0_um%22%3A7.04%2C%22p2_5_um%22%3A2.11%2C%22p10_0_um%22%3A0.86%7D%2C%0A%7B%22date%22%3A%222024-08-22%22%2C%22p1_0_um%22%3A19.29%2C%22p2_5_um%22%3A4%2C%22p10_0_um%22%3A0.46%7D%2C%0A%7B%22date%22%3A%222024-08-23%22%2C%22p1_0_um%22%3A47.35%2C%22p2_5_um%22%3A3.87%2C%22p10_0_um%22%3A0.47%7D%2C%0A%7B%22date%22%3A%222024-08-24%22%2C%22p1_0_um%22%3A57.76%2C%22p2_5_um%22%3A10.83%2C%22p10_0_um%22%3A2.34%7D%2C%0A%7B%22date%22%3A%222024-08-25%22%2C%22p1_0_um%22%3A98.42%2C%22p2_5_um%22%3A13.37%2C%22p10_0_um%22%3A8.28%7D%2C%0A%7B%22date%22%3A%222024-08-26%22%2C%22p1_0_um%22%3A99.53%2C%22p2_5_um%22%3A11.52%2C%22p10_0_um%22%3A5.17%7D%2C%0A%7B%22date%22%3A%222024-08-27%22%2C%22p1_0_um%22%3A93.81%2C%22p2_5_um%22%3A9.4%2C%22p10_0_um%22%3A3.12%7D%2C%0A%7B%22date%22%3A%222024-08-28%22%2C%22p1_0_um%22%3A76.58%2C%22p2_5_um%22%3A7.59%2C%22p10_0_um%22%3A1.86%7D%2C%0A%7B%22date%22%3A%222024-08-29%22%2C%22p1_0_um%22%3A53.47%2C%22p2_5_um%22%3A4.41%2C%22p10_0_um%22%3A1.07%7D%2C%0A%7B%22date%22%3A%222024-08-30%22%2C%22p1_0_um%22%3A23.48%2C%22p2_5_um%22%3A3.41%2C%22p10_0_um%22%3A1.28%7D%2C%0A%7B%22date%22%3A%222024-08-31%22%2C%22p1_0_um%22%3A12.4%2C%22p2_5_um%22%3A3.5%2C%22p10_0_um%22%3A0.67%7D%5D%0A%60%60%60%0A%0A(This%20example%20shows%20a%20scatter-type%20chart%20with%20multiple%20series%2C%20being%20driven%20directly%20from%20a%20JSON%20dataset%2C%20using%20the%20text%20content%20of%20the%20chart%20element%20definition%20to%20specify%20the%20axes.%20Note%20the%20x-axis%20labels%20are%20messy.%20The%20ChartEmbed%20currently%20does%20not%20automatically%20adjust%20the%20labeling%20well%2C%20so%20it%E2%80%99s%20best%20to%20stick%20to%20short%20labels.)%0A%0A</textarea>
  <script>
  /*
  Active Markdown is released under the MIT license.

  Copyright 2024 Alec Perkins <mail@alecperkins.me>

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.


  */
    const __amd_meta__ = JSON.parse(decodeURIComponent('%7B%22title%22%3A%22Active%20Markdown%20examples%22%7D'));
    (function () {
  'use strict';

  
      /*
      https://www.npmjs.com/package/prism-code-editor

      MIT License

Copyright (c) 2023 FIameCaster

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

      */
        var plainTextGrammar = {};
  var rest = Symbol();
  var tokenize = Symbol();
  var resolve = (id) => typeof id == "string" ? languages[id] : id;
  var languages = {
    plain: plainTextGrammar,
    plaintext: plainTextGrammar,
    text: plainTextGrammar,
    txt: plainTextGrammar
  };
  var tokenizeText = (text, grammar) => (grammar[tokenize] || withoutTokenizer)(text, grammar);
  var withoutTokenizer = (text, grammar) => {
    var startNode = [text];
    var restGrammar;
    var array = [], i = 0;
    while (restGrammar = resolve(grammar[rest])) {
      delete grammar[rest];
      Object.assign(grammar, restGrammar);
    }
    matchGrammar(text, grammar, startNode, 0);
    while (array[i++] = startNode[0], startNode = startNode[1])
      ;
    return array;
  };
  var closingTag = "</span>";
  var openingTags = "";
  var closingTags = "";
  var highlightTokens = (tokens) => {
    var str = "", l = tokens.length, i = 0;
    while (i < l)
      str += stringify(tokens[i++]);
    return str;
  };
  var stringify = (token) => {
    if (token instanceof Token) {
      var { type, alias, content } = token;
      var prevOpening = openingTags;
      var prevClosing = closingTags;
      var opening = `<span class="token ${type + (alias ? " " + alias : "") + (type == "keyword" && typeof content == "string" ? " keyword-" + content : "")}">`;
      closingTags += closingTag;
      openingTags += opening;
      var contentStr = stringify(content);
      openingTags = prevOpening;
      closingTags = prevClosing;
      return opening + contentStr + closingTag;
    }
    if (typeof token != "string")
      return highlightTokens(token);
    token = token.replace(/&/g, "&amp;").replace(/</g, "&lt;");
    if (closingTags && token.includes("\n")) {
      return token.replace(/\n/g, closingTags + "\n" + openingTags);
    }
    return token;
  };
  var matchGrammar = (text, grammar, startNode, startPos, rematch) => {
    for (var token in grammar) {
      if (grammar[token])
        for (var j = 0, p = grammar[token], patterns = Array.isArray(p) ? p : [p]; j < patterns.length; ++j) {
          if (rematch && rematch[0] == token && rematch[1] == j) {
            return;
          }
          var patternObj = patterns[j];
          var pattern = patternObj.pattern || patternObj;
          var inside = resolve(patternObj.inside);
          var lookbehind = patternObj.lookbehind;
          var greedy = patternObj.greedy && pattern.global;
          var alias = patternObj.alias;
          for (var currentNode = startNode, pos = startPos; currentNode && (!rematch || pos < rematch[2]); pos += currentNode[0].length, currentNode = currentNode[1]) {
            var str = currentNode[0];
            var removeCount = 0;
            var match, lookbehindLength;
            if (str instanceof Token) {
              continue;
            }
            pattern.lastIndex = greedy ? pos : 0;
            match = pattern.exec(greedy ? text : str);
            if (match && lookbehind && match[1]) {
              lookbehindLength = match[1].length;
              match.index += lookbehindLength;
              match[0] = match[0].slice(lookbehindLength);
            }
            if (greedy) {
              if (!match) {
                break;
              }
              if (match[0]) {
                for (var from = match.index, to = from + match[0].length, l; from >= pos + (l = currentNode[0].length); currentNode = currentNode[1], pos += l)
                  ;
                if (currentNode[0] instanceof Token) {
                  continue;
                }
                for (var k = currentNode, p = pos; (p += k[0].length) < to; k = k[1], removeCount++)
                  ;
                str = text.slice(pos, p);
                match.index -= pos;
              }
            }
            if (!(match && match[0])) {
              continue;
            }
            var from = match.index;
            var matchStr = match[0];
            var after = str.slice(from + matchStr.length);
            var reach = pos + str.length;
            var newToken = new Token(token, inside ? tokenizeText(matchStr, inside) : matchStr, matchStr, alias);
            var next = currentNode, i = 0;
            var nestedRematch;
            while (next = next[1], i++ < removeCount)
              ;
            if (after) {
              if (!next || next[0] instanceof Token)
                next = [after, next];
              else
                next[0] = after + next[0];
            }
            pos += from;
            currentNode[0] = from ? str.slice(0, from) : newToken;
            if (from)
              currentNode = currentNode[1] = [newToken, next];
            else
              currentNode[1] = next;
            if (removeCount) {
              matchGrammar(text, grammar, currentNode, pos, nestedRematch = [token, j, reach]);
              reach = nestedRematch[2];
            }
            if (rematch && reach > rematch[2])
              rematch[2] = reach;
          }
        }
    }
  };
  function Token(type, content, matchedStr, alias) {
    this.type = type;
    this.content = content;
    this.alias = alias;
    this.length = matchedStr.length;
  }

  var clikeComment = () => ({
    pattern: /\/\/.*|\/\*[^]*?(?:\*\/|$)/g,
    greedy: true
  });
  var clikeString = () => ({
    pattern: /(["'])(?:\\[^]|(?!\1)[^\\\n])*\1/g,
    greedy: true
  });
  var boolean = /\b(?:false|true)\b/;

  var js = {};
  languages.js = languages.javascript = Object.assign(js, {
    "doc-comment": {
      pattern: /\/\*\*(?!\/)[^]*?(?:\*\/|$)/g,
      greedy: true,
      alias: "comment",
      inside: "jsdoc"
    },
    "comment": clikeComment(),
    "hashbang": {
      pattern: /^#!.*/g,
      greedy: true,
      alias: "comment"
    },
    "template-string": {
      pattern: /`(?:\\[^]|\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})*\}|(?!\$\{)[^\\`])*`/g,
      greedy: true,
      inside: {
        "template-punctuation": {
          pattern: /^`|`$/,
          alias: "string"
        },
        "interpolation": {
          pattern: /((?:^|[^\\])(?:\\\\)*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})*\}/,
          lookbehind: true,
          inside: {
            "interpolation-punctuation": {
              pattern: /^\$\{|\}$/,
              alias: "punctuation"
            },
            [rest]: js
          }
        },
        "string": /[^]+/
      }
    },
    "string-property": {
      pattern: /((?:^|[,{])[ 	]*)(["'])(?:\\[^]|(?!\2)[^\\\n])*\2(?=\s*:)/mg,
      lookbehind: true,
      greedy: true,
      alias: "property"
    },
    "string": clikeString(),
    "regex": {
      pattern: /((?:^|[^$\w\xa0-\uffff"'`.)\]\s]|\b(?:return|yield))\s*)\/(?:(?:\[(?:\\.|[^\\\n\]])*\]|\\.|[^\\\n/[])+\/[dgimyus]{0,7}|(?:\[(?:\\.|[^\\\n[\]]|\[(?:\\.|[^\\\n[\]]|\[(?:\\.|[^\\\n[\]])*\])*\])*\]|\\.|[^\\\n/[])+\/[dgimyus]{0,7}v[dgimyus]{0,7})(?=(?:\s|\/\*(?:[^*]|\*(?!\/))*\*\/)*(?!\/\*|[^()[\]{}.,:;?`\n%&|^!=<>/*+-]))/g,
      lookbehind: true,
      greedy: true,
      inside: {
        "regex-flags": /\w+$/,
        "regex-delimiter": /^\/|\/$/,
        "regex-source": {
          pattern: /.+/,
          alias: "language-regex",
          inside: "regex"
        }
      }
    },
    "class-name": [
      {
        pattern: /(\b(?:class|extends|implements|instanceof|interface|new)\s+)(?!\d)(?:(?!\s)[$\w.\xa0-\uffff])+/,
        lookbehind: true,
        inside: {
          "punctuation": /\./
        }
      },
      {
        pattern: /(^|[^$\w\xa0-\uffff]|\s)(?![a-z\d])(?:(?!\s)[$\w\xa0-\uffff])+(?=\.(?:constructor|prototype)\b)/,
        lookbehind: true
      }
    ],
    // This must be declared before keyword because we use "function" inside the look-forward
    "function-variable": {
      pattern: /#?(?!\d)(?:(?!\s)[$\w\xa0-\uffff])+(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^)]*\))*\)|(?!\d)(?:(?!\s)[$\w\xa0-\uffff])+)\s*=>))/,
      alias: "function",
      inside: {
        "maybe-class-name": /^[A-Z].*/
      }
    },
    "parameter": [
      /(function(?:\s+(?!\d)(?:(?!\s)[$\w\xa0-\uffff])+)?\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\))/,
      /(^|[^$\w\xa0-\uffff]|\s)(?!\d)(?:(?!\s)[$\w\xa0-\uffff])+(?=\s*=>)/,
      /(\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*=>)/,
      /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|continue|default|do|else|finally|for|if|return|switch|throw|try|while|yield|class|const|debugger|delete|enum|extends|function|[gs]et|export|from|import|implements|in|instanceof|interface|let|new|null|of|package|private|protected|public|static|super|this|typeof|undefined|var|void|with)(?![$\w\xa0-\uffff]))(?:(?!\d)(?:(?!\s)[$\w\xa0-\uffff])+\s*)\(\s*|\]\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*\{)/
    ].map((pattern) => ({
      pattern,
      lookbehind: true,
      inside: js
    })),
    "constant": /\b[A-Z](?:[A-Z_]|\dx?)*\b/,
    "keyword": [
      {
        pattern: /(^|[^.]|\.{3}\s*)\b(?:as|assert(?=\s*\{)|export|from(?!\s*[^\s"'])|import)\b/,
        alias: "module",
        lookbehind: true
      },
      {
        pattern: /(^|[^.]|\.{3}\s*)\b(?:await|break|case|catch|continue|default|do|else|finally|for|if|return|switch|throw|try|while|yield)\b/,
        alias: "control-flow",
        lookbehind: true
      },
      {
        pattern: /(^|[^.]|\.{3}\s*)\b(?:async(?!\s*[^\s($\w\xa0-\uffff])|class|const|debugger|delete|enum|extends|function|[gs]et(?!\s*[^\s#[$\w\xa0-\uffff])|implements|in|instanceof|interface|let|new|null|of|package|private|protected|public|static|super|this|typeof|undefined|var|void|with)\b/,
        lookbehind: true
      }
    ],
    "boolean": boolean,
    // Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)
    "function": {
      pattern: /#?(?!\d)(?:(?!\s)[$\w\xa0-\uffff])+(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,
      inside: {
        "maybe-class-name": /^[A-Z].*/
      }
    },
    "number": {
      pattern: /(^|[^$\w])(?:NaN|Infinity|0[bB][01]+(?:_[01]+)*n?|0[oO][0-7]+(?:_[0-7]+)*n?|0[xX][a-fA-F\d]+(?:_[a-fA-F\d]+)*n?|\d+(?:_\d+)*n|(?:\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\.\d+(?:_\d+)*)(?:[Ee][+-]?\d+(?:_\d+)*)?)(?![$\w])/,
      lookbehind: true
    },
    "literal-property": {
      pattern: /([\n,{][ 	]*)(?!\d)(?:(?!\s)[$\w\xa0-\uffff])+(?=\s*:)/,
      lookbehind: true,
      alias: "property"
    },
    "operator": [
      {
        pattern: /=>/,
        alias: "arrow"
      },
      /--|\+\+|(?:\*\*|&&|\|\||[!=]=|>>>?|<<|[%&|^!=<>/*+-]|\?\?)=?|\.{3}|\?(?!\.)|~|:/
    ],
    "property-access": {
      pattern: /(\.\s*)#?(?!\d)(?:(?!\s)[$\w\xa0-\uffff])+/,
      lookbehind: true,
      inside: {
        "maybe-class-name": /^[A-Z].*/
      }
    },
    "maybe-class-name": {
      pattern: /(^|[^$\w\xa0-\uffff])[A-Z][$\w\xa0-\uffff]+/,
      lookbehind: true
    },
    "punctuation": /\?\.|[()[\]{}.,:;]/
  });

  languages.webmanifest = languages.json = {
    "property": {
      pattern: /"(?:\\.|[^\\\n"])*"(?=\s*:)/g,
      greedy: true
    },
    "string": {
      pattern: /"(?:\\.|[^\\\n"])*"/g,
      greedy: true
    },
    "comment": clikeComment(),
    "number": /-?\b\d+(?:\.\d+)?(?:e[+-]?\d+)?\b/i,
    "operator": /:/,
    "punctuation": /[[\]{},]/,
    "boolean": boolean,
    "null": {
      pattern: /\bnull\b/,
      alias: "keyword"
    }
  };

  languages.csv = {
    "value": /[^\n,"]+|"(?:[^"]|"")*"(?!")/,
    "punctuation": /,/
  };

  const createEditor = (container, options, ...extensions) => {
    let language;
    let grammar;
    let prevLines = [];
    let activeLine;
    let value = "";
    let activeLineNumber;
    let removed = false;
    let focused = false;
    let handleSelectionChange = true;
    let tokens = [];
    let readOnly;
    let lineCount = 0;
    const scrollContainer = editorTemplate();
    const wrapper = scrollContainer.firstChild;
    const lines = wrapper.children;
    const overlays = lines[0];
    const textarea = overlays.firstChild;
    const currentOptions = { language: "text", value };
    const currentExtensions = new Set(extensions);
    const listeners = {};
    const setOptions = (options2) => {
      Object.assign(currentOptions, options2);
      value = options2.value ?? value;
      language = currentOptions.language;
      if (!languages[language])
        throw Error(`Language '${language}' has no grammar.`);
      readOnly = !!currentOptions.readOnly;
      scrollContainer.style.tabSize = currentOptions.tabSize || 2;
      textarea.inputMode = readOnly ? "none" : "";
      textarea.setAttribute("aria-readonly", readOnly);
      updateClassName();
      updateExtensions();
      if (grammar != (grammar = languages[language]) || value != textarea.value) {
        focusRelatedTarget();
        textarea.value = value;
        textarea.selectionEnd = 0;
        update();
      }
    };
    const update = () => {
      tokens = tokenizeText(value = textarea.value, grammar);
      dispatchEvent("tokenize", tokens, language, value);
      let newLines = highlightTokens(tokens).split("\n");
      let start = 0;
      let end2 = lineCount;
      let end1 = lineCount = newLines.length;
      while (newLines[start] == prevLines[start] && start < end1)
        ++start;
      while (end1 && newLines[--end1] == prevLines[--end2])
        ;
      if (start == end1 && start == end2)
        lines[start + 1].innerHTML = newLines[start] + "\n";
      else {
        let insertStart = end2 < start ? end2 : start - 1;
        let i = insertStart;
        let newHTML = "";
        while (i < end1)
          newHTML += `<div class=pce-line aria-hidden=true>${newLines[++i]}
</div>`;
        for (i = end1 < start ? end1 : start - 1; i < end2; i++)
          lines[start + 1].remove();
        if (newHTML)
          lines[insertStart + 1].insertAdjacentHTML("afterend", newHTML);
        for (i = insertStart + 1; i < lineCount; )
          lines[++i].setAttribute("data-line", i);
        scrollContainer.style.setProperty(
          "--number-width",
          Math.ceil(Math.log10(lineCount + 1)) + ".001ch"
        );
      }
      dispatchEvent("update", value);
      dispatchSelection(true);
      if (handleSelectionChange)
        setTimeout(setTimeout, 0, () => handleSelectionChange = true);
      prevLines = newLines;
      handleSelectionChange = false;
    };
    const updateExtensions = (newExtensions) => {
      (newExtensions || currentExtensions).forEach((extension) => {
        if (typeof extension == "object") {
          extension.update(self, currentOptions);
          if (newExtensions)
            currentExtensions.add(extension);
        } else {
          extension(self, currentOptions);
          if (!newExtensions)
            currentExtensions.delete(extension);
        }
      });
    };
    const updateClassName = ([start, end] = getInputSelection()) => {
      scrollContainer.className = `prism-code-editor language-${language}${currentOptions.lineNumbers == false ? "" : " show-line-numbers"} pce-${currentOptions.wordWrap ? "" : "no"}wrap${currentOptions.rtl ? " pce-rtl" : ""} pce-${start < end ? "has" : "no"}-selection${focused ? " pce-focus" : ""}${readOnly ? " pce-readonly" : ""}`;
    };
    const getInputSelection = () => [
      textarea.selectionStart,
      textarea.selectionEnd,
      textarea.selectionDirection
    ];
    const keyCommandMap = {
      Escape() {
        textarea.blur();
      }
    };
    const inputCommandMap = {};
    const focusRelatedTarget = () => isWebKit && !focused && addTextareaListener(
      self,
      "focus",
      (e) => {
        let relatedTarget = e.relatedTarget;
        if (relatedTarget)
          relatedTarget.focus();
        else
          textarea.blur();
      },
      { once: true }
    );
    const dispatchEvent = (name, ...args) => {
      listeners[name]?.forEach((handler) => handler.apply(self, args));
      currentOptions["on" + name[0].toUpperCase() + name.slice(1)]?.apply(self, args);
    };
    const dispatchSelection = (force) => {
      if (force || handleSelectionChange) {
        const selection = getInputSelection();
        const newLine = lines[activeLineNumber = numLines(value, 0, selection[selection[2] < "f" ? 0 : 1])];
        if (newLine != activeLine) {
          activeLine?.classList.remove("active-line");
          newLine.classList.add("active-line");
          activeLine = newLine;
        }
        updateClassName(selection);
        dispatchEvent("selectionChange", selection, value);
      }
    };
    const self = {
      scrollContainer,
      wrapper,
      overlays,
      textarea,
      get activeLine() {
        return activeLine;
      },
      get activeLineNumber() {
        return activeLineNumber;
      },
      get value() {
        return value;
      },
      options: currentOptions,
      get focused() {
        return focused;
      },
      get removed() {
        return removed;
      },
      get tokens() {
        return tokens;
      },
      inputCommandMap,
      keyCommandMap,
      extensions: {},
      setOptions,
      update,
      getSelection: getInputSelection,
      setSelection(start, end = start, direction) {
        focusRelatedTarget();
        textarea.setSelectionRange(start, end, direction);
        dispatchSelection(true);
      },
      addExtensions(...extensions2) {
        updateExtensions(extensions2);
      },
      addListener(name, handler) {
        (listeners[name] || (listeners[name] = /* @__PURE__ */ new Set())).add(handler);
      },
      removeListener(name, handler) {
        listeners[name]?.delete(handler);
      },
      remove() {
        scrollContainer.remove();
        removed = true;
      }
    };
    addTextareaListener(self, "keydown", (e) => {
      keyCommandMap[e.key]?.(e, getInputSelection(), value) && preventDefault(e);
    });
    addTextareaListener(self, "beforeinput", (e) => {
      if (readOnly || e.inputType == "insertText" && inputCommandMap[e.data]?.(e, getInputSelection(), value))
        preventDefault(e);
    });
    addTextareaListener(self, "input", update);
    addTextareaListener(self, "blur", () => {
      selectionChange = null;
      focused = false;
      updateClassName();
    });
    addTextareaListener(self, "focus", () => {
      selectionChange = dispatchSelection;
      focused = true;
      updateClassName();
    });
    addTextareaListener(self, "selectionchange", (e) => {
      dispatchSelection();
      preventDefault(e);
    });
    getElement(container)?.append(scrollContainer);
    options && setOptions(options);
    return self;
  };
  const templateEl = /* @__PURE__ */ document.createElement("div");
  const createTemplate = (html) => {
    templateEl.innerHTML = html;
    const node = templateEl.firstChild;
    return () => node.cloneNode(true);
  };
  const addTextareaListener = (editor, type, listener, options) => editor.textarea.addEventListener(type, listener, options);
  const getElement = (el) => typeof el == "string" ? document.querySelector(el) : el;
  const userAgent = navigator.userAgent;
  const isChrome = /Chrome\//.test(userAgent);
  const isWebKit = !isChrome && /AppleWebKit\//.test(userAgent);
  const numLines = (str, start = 0, end = Infinity) => {
    let count = 1;
    for (; (start = str.indexOf("\n", start) + 1) && start <= end; count++)
      ;
    return count;
  };
  const editorTemplate = /* @__PURE__ */ createTemplate(
    "<div><div class=pce-wrapper><div class=pce-overlays><textarea spellcheck=false autocapitalize=off autocomplete=off>"
  );
  const preventDefault = (e) => {
    e.preventDefault();
    e.stopImmediatePropagation();
  };
  let selectionChange;
  document.addEventListener("selectionchange", () => selectionChange?.());

  const matchBrackets = (rainbowBrackets = true, openingBrackets = "([{", closingBrackets = ")]}") => {
    let bracketIndex;
    let sp;
    const stack = [];
    const self = (editor) => {
      editor.extensions.matchBrackets = self;
      editor.addListener("tokenize", matchBrackets2);
      if (rainbowBrackets && editor.tokens[0])
        editor.update();
      else
        matchBrackets2(editor.tokens);
    };
    const brackets = self.brackets = [];
    const pairMap = self.pairs = [];
    const matchBrackets2 = (tokens) => {
      pairMap.length = brackets.length = sp = bracketIndex = 0;
      matchRecursive(tokens, 0);
      if (rainbowBrackets) {
        for (let i = 0, bracket; bracket = brackets[i]; ) {
          let alias = bracket[0].alias;
          bracket[0].alias = (alias ? alias + " " : "") + `bracket-${i++ in pairMap ? "level-" + bracket[2] % 12 : "error"}`;
        }
      }
    };
    const matchRecursive = (tokens, position) => {
      let token;
      let i = 0;
      for (; token = tokens[i++]; ) {
        let length = token.length;
        if (typeof token != "string") {
          let content = token.content;
          if (Array.isArray(content)) {
            matchRecursive(content, position);
          } else if ((token.alias || token.type) == "punctuation") {
            let openingType = testBracket(content, openingBrackets, length - 1);
            let closingType = openingType || testBracket(content, closingBrackets, length - 1);
            if (closingType) {
              brackets[bracketIndex] = [token, position, 0, content, !!openingType, position + length];
              if (openingType)
                stack[sp++] = [bracketIndex, openingType];
              else {
                for (let i2 = sp; i2; ) {
                  let [index, type] = stack[--i2];
                  if (closingType == type) {
                    pairMap[pairMap[bracketIndex] = index] = bracketIndex;
                    brackets[bracketIndex][2] = brackets[index][2] = sp = i2;
                    i2 = 0;
                  }
                }
              }
              bracketIndex++;
            }
          }
        }
        position += length;
      }
    };
    return self;
  };
  const testBracket = (str, brackets, l) => {
    return brackets.indexOf(str[0]) + 1 || l && brackets.indexOf(str[l]) + 1;
  };

  const template = createTemplate(
    "<div class=guide-indents style=left:var(--padding-left);bottom:auto;right:auto> "
  );
  const indentTemplate = createTemplate(
    "<div style=width:1px;position:absolute;background:var(--bg-guide-indent)>"
  );
  const indentGuides = () => {
    let tabSize;
    let prevLength = 0;
    let lineIndentMap;
    let active = -1;
    let currentEditor;
    const lines = [];
    const indents = [];
    const container = template();
    const indentLevels = [];
    const update = (code) => {
      lineIndentMap = [];
      const newIndents = getIndents(code.split("\n"));
      const l = newIndents.length;
      for (let i = 0, prev = [], next = newIndents[0]; next; i++) {
        const style = (lines[i] || (lines[i] = indentTemplate())).style;
        const [top, height, left] = next;
        const old = indents[i];
        next = newIndents[i + 1];
        if (top != old?.[0])
          style.top = top + "00%";
        if (height != old?.[1])
          style.height = height + "00%";
        if (left != old?.[2])
          style.left = left * 100 + "%";
        const isSingleIndent = prev[0] != top && next?.[0] != top, isSingleOutdent = prev[0] + prev[1] != top + height && next?.[0] + next?.[1] != top + height;
        for (let j = -isSingleIndent, l2 = height + isSingleOutdent; j < l2; j++)
          lineIndentMap[j + top] = i;
        prev = indents[i] = newIndents[i];
      }
      for (let i = prevLength; i > l; )
        lines[--i].remove();
      container.append(...lines.slice(prevLength, prevLength = l));
    };
    const updateActive = () => {
      const newActive = lineIndentMap[currentEditor.activeLineNumber - 1] ?? -1;
      if (newActive != active) {
        active > -1 && (lines[active].className = "");
        newActive > -1 && (lines[newActive].className = "active");
      }
      active = newActive;
    };
    const getIndents = (lines2) => {
      const l = lines2.length;
      const stack = [];
      const results = [];
      for (let prevIndent = 0, emptyPos = -1, i = 0, p = 0; ; i++) {
        const last = i == l;
        const indent = last ? 0 : indentLevels[i] = getIndentCount(lines2[i]);
        if (indent < 0) {
          if (emptyPos < 0)
            emptyPos = i;
        } else {
          for (let j = indent; j < prevIndent; j++) {
            stack[j][1] = (emptyPos < 0 || j == indent && !last ? i : emptyPos) - stack[j][0];
          }
          for (let j = prevIndent; j < indent; ) {
            results[p++] = stack[j] = [
              emptyPos < 0 || j > prevIndent ? i : emptyPos,
              0,
              j++ * tabSize
            ];
          }
          emptyPos = -1;
          prevIndent = indent;
        }
        if (last)
          break;
      }
      indentLevels.length = l;
      return results;
    };
    const getIndentCount = (text) => {
      let l = text.search(/\S/);
      let result = 0;
      if (l < 0)
        return l;
      for (let i = 0; i < l; ) {
        result += text[i++] == "	" ? tabSize - result % tabSize : 1;
      }
      return Math.ceil(result / tabSize);
    };
    return {
      lines: container.children,
      indentLevels,
      update(editor, options) {
        if (!currentEditor) {
          currentEditor = editor;
          editor.extensions.indentGuides = this;
          editor.overlays.append(container);
          editor.addListener("update", update);
          editor.addListener("selectionChange", updateActive);
        }
        container.style.display = options.wordWrap ? "none" : "";
        if (tabSize != (tabSize = options.tabSize || 2))
          update(editor.value), updateActive();
      }
    };
  };

  // // index.ts
  // import "prism-code-editor/prism/languages/markup"
  // import "prism-code-editor/prism/languages/css-extras"

  // // Importing styles
  // import "prism-code-editor/layout.css"
  // import "prism-code-editor/scrollbar.css"
  // import "prism-code-editor/themes/github-dark.css"



  // import('./extensions')

  class CodeEditor {
    constructor (el, language="javascript") {
      this.el = el;
      this.el.classList.add('CodeEditor');
      // this.el.setAttribute('contenteditable', true);
      this._callbacks = [];
      const initial_value = this.el.textContent;
      this.el.textContent = '';
      this._editor = createEditor(
        this.el,
        {
          language,
          value: initial_value,
          lineNumbers: false,
          onUpdate: this._triggerChange.bind(this),
        },
        indentGuides(),
        matchBrackets(),
      );
    }
    onChange (callback) {
      this._callbacks.push(callback);
    }

    _triggerChange () {
      this._callbacks.forEach((fn) => {
        fn();
      });
    }

    getValue () {
      return this._editor.value;
    }
  }

  class DragManager {
    constructor () {
      this._window = window;
      this._body_el = document.body;
      this._reset();

      this._boundDrag = this._drag.bind(this);
      this._boundStop = this._stop.bind(this);
    }

    /**
     * Private: reset the drag manager and related document styles (cursor).
      Returns nothing.
     */
    _reset () {
      this.is_dragging = false;
      if (this._direction !== null) {
        this._body_el.dataset[`dragging_${ this._direction }`] = false;
      }
      this._dragging_target = null;
      this._drag_start_x = null;
      this._drag_start_y = null;
      this._direction = null;
    }
    /*
    Private: prepare the mouse position information for the handlers.

    cur_x - the integer current x position of the cursor
    cur_y - the integer current y position of the cursor

    Returns an object with the initial coordinates, and the change in position.
    */
    _assembleUI (cur_x, cur_y) {
      return {
        x_start : this._drag_start_x,
        y_start : this._drag_start_y,
        x_delta : cur_x - this._drag_start_x,
        y_delta : cur_y - this._drag_start_y,
      };
    }


    /*
    Public: initiate a drag operation for a given view.

    e           - the jQuery.Event from the initial mousedown event
    view        - the BaseElementView of the element starting the drag
    direction   - the String direction of the drag: 'x', 'y', or 'both'

    Returns nothing.
    */
    start (e, view, direction) {
      this._is_dragging = true;
      const { pageX, pageY } = e;
      this._direction = direction;
      this._drag_start_x = pageX;
      this._drag_start_y = pageY;
      this._dragging_target = view;
      this._window.addEventListener('mousemove', this._boundDrag);
      this._window.addEventListener('mouseup', this._boundStop);
      this._window.addEventListener('touchmove', this._boundDrag);
      this._window.addEventListener('touchend', this._boundStop);
      this._body_el.dataset[`dragging_${ this._direction }`] = true;
    }

    _drag (e) {
      const { pageX, pageY } = e;
      const ui = this._assembleUI(pageX, pageY);
      this._dragging_target.onDrag?.(ui);
    }

    _stop (e) {
      this._window.removeEventListener('mousemove', this._boundDrag);
      this._window.removeEventListener('mouseup', this._boundStop);
      if (this._dragging_target != null) {
        const { pageX, pageY } = e;
        const ui = this._assembleUI(pageX, pageY);
        this._dragging_target.stopDragging?.(ui);
        this._reset();
      }
    }
  }

  const doc_variables = {};
  const doc_elements = {};
  const doc_embeds = {};

  const drag_manager = new DragManager(document, window);

  let latest_id = 1;
  function generateId () {
    latest_id += 1;
    return latest_id.toString(36);
  }

  function registerElement (element) {
    const id = generateId();
    element.el.dataset.activemd_id = id;
    doc_elements[id] = element;
  }
  function registerEmbed (element) {
    const id = generateId();
    element.el.dataset.activemd_id = id;
    doc_elements[id] = element;
  }


  window.ActiveMarkdown = {
    variables: doc_variables,
    elements: doc_elements,
    embeds: doc_embeds,
  };

  class Executor {

    constructor (amd_meta) {
      this._amd_meta = amd_meta;
      this._code_blocks = [];
      Object.entries(doc_variables).forEach(([name, variable]) => {
        variable.onChange(this.run.bind(this), true);
      });
    }

    addBlock (block) {
      block.el.classList.add('ActiveCodeBlock');
      block.editor = new CodeEditor(block.el);
      block.editor.onChange(this.run.bind(this));
      this._code_blocks.push(block);
    }

    run () {
      this._execute();
    }

    _execute () {
      if (this._code_blocks.length === 0) {
        return;
      }
      const user_source = this._code_blocks.map(b => b.editor.getValue()).join(';\n'); // ; to guard against poorly placed )s
      const input = {};
      Object.entries(doc_variables).forEach(([name, variable]) => {
        input[name] = variable.getValue();
      });
      const var_list = Object.keys(doc_variables);
      const var_name_spread = var_list.length > 0 ? `{${var_list.join(',')}}` : '{__empty_var_list}';
      const full_source = `
let ${ var_name_spread } = __amd_input;
let meta = __amd_meta;
${user_source}
;return ${var_name_spread};
`;
      let output;
      let fn;
      try {
        fn = Function("__amd_input", "__amd_meta", full_source);
      } catch (error) {
        // Compilation errors are fine since they will happen while editing the code.
        console.debug(error);
        output = {...input};
      }

      if (fn) {
        try {
          output = fn.call(null, {...input}, this._amd_meta);
        } catch (error) {
          console.error(error);
          output = {...input};
        }
      }
      Object.keys(input).forEach((name) => {
        if (doc_variables[name]) {
          const value = output[name];
          doc_variables[name].setValue(value, true);
        } else {
          throw new Error(`Attempted assignment to unknown Document variable: ${name}`);
        }
      });
    }

  }

  /**
   * This object contains all namespaces used within Chartist.
   */ const namespaces = {
      svg: "http://www.w3.org/2000/svg",
      xmlns: "http://www.w3.org/2000/xmlns/",
      xhtml: "http://www.w3.org/1999/xhtml",
      xlink: "http://www.w3.org/1999/xlink",
      ct: "http://gionkunz.github.com/chartist-js/ct"
  };
  /**
   * Precision level used internally in Chartist for rounding. If you require more decimal places you can increase this number.
   */ const precision = 8;
  /**
   * A map with characters to escape for strings to be safely used as attribute values.
   */ const escapingMap = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#039;"
  };

  /**
   * Converts a number to a string with a unit. If a string is passed then this will be returned unmodified.
   * @return Returns the passed number value with unit.
   */ function ensureUnit(value, unit) {
      if (typeof value === "number") {
          return value + unit;
      }
      return value;
  }
  /**
   * Converts a number or string to a quantity object.
   * @return Returns an object containing the value as number and the unit as string.
   */ function quantity(input) {
      if (typeof input === "string") {
          const match = /^(\d+)\s*(.*)$/g.exec(input);
          return {
              value: match ? +match[1] : 0,
              unit: (match === null || match === void 0 ? void 0 : match[2]) || undefined
          };
      }
      return {
          value: Number(input)
      };
  }
  /**
   * Generates a-z from a number 0 to 26
   * @param n A number from 0 to 26 that will result in a letter a-z
   * @return A character from a-z based on the input number n
   */ function alphaNumerate(n) {
      // Limit to a-z
      return String.fromCharCode(97 + n % 26);
  }

  const EPSILON = 2.221e-16;
  /**
   * Calculate the order of magnitude for the chart scale
   * @param value The value Range of the chart
   * @return The order of magnitude
   */ function orderOfMagnitude(value) {
      return Math.floor(Math.log(Math.abs(value)) / Math.LN10);
  }
  /**
   * Project a data length into screen coordinates (pixels)
   * @param axisLength The svg element for the chart
   * @param length Single data value from a series array
   * @param bounds All the values to set the bounds of the chart
   * @return The projected data length in pixels
   */ function projectLength(axisLength, length, bounds) {
      return length / bounds.range * axisLength;
  }
  /**
   * This helper function can be used to round values with certain precision level after decimal. This is used to prevent rounding errors near float point precision limit.
   * @param value The value that should be rounded with precision
   * @param [digits] The number of digits after decimal used to do the rounding
   * @returns Rounded value
   */ function roundWithPrecision(value, digits) {
      const precision$1 = Math.pow(10, precision);
      return Math.round(value * precision$1) / precision$1;
  }
  /**
   * Pollard Rho Algorithm to find smallest factor of an integer value. There are more efficient algorithms for factorization, but this one is quite efficient and not so complex.
   * @param num An integer number where the smallest factor should be searched for
   * @returns The smallest integer factor of the parameter num.
   */ function rho(num) {
      if (num === 1) {
          return num;
      }
      function gcd(p, q) {
          if (p % q === 0) {
              return q;
          } else {
              return gcd(q, p % q);
          }
      }
      function f(x) {
          return x * x + 1;
      }
      let x1 = 2;
      let x2 = 2;
      let divisor;
      if (num % 2 === 0) {
          return 2;
      }
      do {
          x1 = f(x1) % num;
          x2 = f(f(x2)) % num;
          divisor = gcd(Math.abs(x1 - x2), num);
      }while (divisor === 1);
      return divisor;
  }

  /**
   * Calculate and retrieve all the bounds for the chart and return them in one array
   * @param axisLength The length of the Axis used for
   * @param highLow An object containing a high and low property indicating the value range of the chart.
   * @param scaleMinSpace The minimum projected length a step should result in
   * @param onlyInteger
   * @return All the values to set the bounds of the chart
   */ function getBounds(axisLength, highLow, scaleMinSpace) {
      let onlyInteger = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
      const bounds = {
          high: highLow.high,
          low: highLow.low,
          valueRange: 0,
          oom: 0,
          step: 0,
          min: 0,
          max: 0,
          range: 0,
          numberOfSteps: 0,
          values: []
      };
      bounds.valueRange = bounds.high - bounds.low;
      bounds.oom = orderOfMagnitude(bounds.valueRange);
      bounds.step = Math.pow(10, bounds.oom);
      bounds.min = Math.floor(bounds.low / bounds.step) * bounds.step;
      bounds.max = Math.ceil(bounds.high / bounds.step) * bounds.step;
      bounds.range = bounds.max - bounds.min;
      bounds.numberOfSteps = Math.round(bounds.range / bounds.step);
      // Optimize scale step by checking if subdivision is possible based on horizontalGridMinSpace
      // If we are already below the scaleMinSpace value we will scale up
      const length = projectLength(axisLength, bounds.step, bounds);
      const scaleUp = length < scaleMinSpace;
      const smallestFactor = onlyInteger ? rho(bounds.range) : 0;
      // First check if we should only use integer steps and if step 1 is still larger than scaleMinSpace so we can use 1
      if (onlyInteger && projectLength(axisLength, 1, bounds) >= scaleMinSpace) {
          bounds.step = 1;
      } else if (onlyInteger && smallestFactor < bounds.step && projectLength(axisLength, smallestFactor, bounds) >= scaleMinSpace) {
          // If step 1 was too small, we can try the smallest factor of range
          // If the smallest factor is smaller than the current bounds.step and the projected length of smallest factor
          // is larger than the scaleMinSpace we should go for it.
          bounds.step = smallestFactor;
      } else {
          // Trying to divide or multiply by 2 and find the best step value
          let optimizationCounter = 0;
          for(;;){
              if (scaleUp && projectLength(axisLength, bounds.step, bounds) <= scaleMinSpace) {
                  bounds.step *= 2;
              } else if (!scaleUp && projectLength(axisLength, bounds.step / 2, bounds) >= scaleMinSpace) {
                  bounds.step /= 2;
                  if (onlyInteger && bounds.step % 1 !== 0) {
                      bounds.step *= 2;
                      break;
                  }
              } else {
                  break;
              }
              if (optimizationCounter++ > 1000) {
                  throw new Error("Exceeded maximum number of iterations while optimizing scale step!");
              }
          }
      }
      bounds.step = Math.max(bounds.step, EPSILON);
      function safeIncrement(value, increment) {
          // If increment is too small use *= (1+EPSILON) as a simple nextafter
          if (value === (value += increment)) {
              value *= 1 + (increment > 0 ? EPSILON : -EPSILON);
          }
          return value;
      }
      // Narrow min and max based on new step
      let newMin = bounds.min;
      let newMax = bounds.max;
      while(newMin + bounds.step <= bounds.low){
          newMin = safeIncrement(newMin, bounds.step);
      }
      while(newMax - bounds.step >= bounds.high){
          newMax = safeIncrement(newMax, -bounds.step);
      }
      bounds.min = newMin;
      bounds.max = newMax;
      bounds.range = bounds.max - bounds.min;
      const values = [];
      for(let i = bounds.min; i <= bounds.max; i = safeIncrement(i, bounds.step)){
          const value = roundWithPrecision(i);
          if (value !== values[values.length - 1]) {
              values.push(value);
          }
      }
      bounds.values = values;
      return bounds;
  }

  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  function extend() {
      let target = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      for(var _len = arguments.length, sources = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
          sources[_key - 1] = arguments[_key];
      }
      for(let i = 0; i < sources.length; i++){
          const source = sources[i];
          for(const prop in source){
              const sourceProp = source[prop];
              if (typeof sourceProp === "object" && sourceProp !== null && !(sourceProp instanceof Array)) {
                  target[prop] = extend(target[prop], sourceProp);
              } else {
                  target[prop] = sourceProp;
              }
          }
      }
      return target;
  }

  /**
   * Helps to simplify functional style code
   * @param n This exact value will be returned by the noop function
   * @return The same value that was provided to the n parameter
   */ const noop = (n)=>n
  ;
  function times(length, filler) {
      return Array.from({
          length
      }, filler ? (_, i)=>filler(i)
       : ()=>void 0
      );
  }
  /**
   * Map for multi dimensional arrays where their nested arrays will be mapped in serial. The output array will have the length of the largest nested array. The callback function is called with variable arguments where each argument is the nested array value (or undefined if there are no more values).
   *
   * For example:
   * @example
   * ```ts
   * const data = [[1, 2], [3], []];
   * serialMap(data, cb);
   *
   * // where cb will be called 2 times
   * // 1. call arguments: (1, 3, undefined)
   * // 2. call arguments: (2, undefined, undefined)
   * ```
   */ const serialMap = (array, callback)=>times(Math.max(...array.map((element)=>element.length
      )), (index)=>callback(...array.map((element)=>element[index]
          ))
      )
  ;

  function safeHasProperty(target, property) {
      return target !== null && typeof target === "object" && Reflect.has(target, property);
  }
  function isNumeric(value) {
      return value !== null && isFinite(value);
  }
  /**
   * Returns true on all falsey values except the numeric value 0.
   */ function isFalseyButZero(value) {
      return !value && value !== 0;
  }
  function getNumberOrUndefined(value) {
      return isNumeric(value) ? Number(value) : undefined;
  }
  /**
   * Checks if value is array of arrays or not.
   */ function isArrayOfArrays(data) {
      if (!Array.isArray(data)) {
          return false;
      }
      return data.every(Array.isArray);
  }
  /**
   * Loop over array.
   */ function each(list, callback) {
      let reverse = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
      let index = 0;
      list[reverse ? "reduceRight" : "reduce"]((_, item, itemIndex)=>callback(item, index++, itemIndex)
      , void 0);
  }

  /**
   * Get meta data of a specific value in a series.
   */ function getMetaData(seriesData, index) {
      const value = Array.isArray(seriesData) ? seriesData[index] : safeHasProperty(seriesData, "data") ? seriesData.data[index] : null;
      return safeHasProperty(value, "meta") ? value.meta : undefined;
  }
  function isDataHoleValue(value) {
      return value === null || value === undefined || typeof value === "number" && isNaN(value);
  }
  /**
   * Checks if value is array of series objects.
   */ function isArrayOfSeries(value) {
      return Array.isArray(value) && value.every((_)=>Array.isArray(_) || safeHasProperty(_, "data")
      );
  }
  /**
   * Checks if provided value object is multi value (contains x or y properties)
   */ function isMultiValue(value) {
      return typeof value === "object" && value !== null && (Reflect.has(value, "x") || Reflect.has(value, "y"));
  }
  /**
   * Gets a value from a dimension `value.x` or `value.y` while returning value directly if it's a valid numeric value. If the value is not numeric and it's falsey this function will return `defaultValue`.
   */ function getMultiValue(value) {
      let dimension = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "y";
      if (isMultiValue(value) && safeHasProperty(value, dimension)) {
          return getNumberOrUndefined(value[dimension]);
      } else {
          return getNumberOrUndefined(value);
      }
  }

  /**
   * Get highest and lowest value of data array. This Array contains the data that will be visualized in the chart.
   * @param data The array that contains the data to be visualized in the chart
   * @param options The Object that contains the chart options
   * @param dimension Axis dimension 'x' or 'y' used to access the correct value and high / low configuration
   * @return An object that contains the highest and lowest value that will be visualized on the chart.
   */ function getHighLow(data, options, dimension) {
      // TODO: Remove workaround for deprecated global high / low config. Axis high / low configuration is preferred
      options = {
          ...options,
          ...dimension ? dimension === "x" ? options.axisX : options.axisY : {}
      };
      const highLow = {
          high: options.high === undefined ? -Number.MAX_VALUE : +options.high,
          low: options.low === undefined ? Number.MAX_VALUE : +options.low
      };
      const findHigh = options.high === undefined;
      const findLow = options.low === undefined;
      // Function to recursively walk through arrays and find highest and lowest number
      function recursiveHighLow(sourceData) {
          if (isDataHoleValue(sourceData)) {
              return;
          } else if (Array.isArray(sourceData)) {
              for(let i = 0; i < sourceData.length; i++){
                  recursiveHighLow(sourceData[i]);
              }
          } else {
              const value = Number(dimension && safeHasProperty(sourceData, dimension) ? sourceData[dimension] : sourceData);
              if (findHigh && value > highLow.high) {
                  highLow.high = value;
              }
              if (findLow && value < highLow.low) {
                  highLow.low = value;
              }
          }
      }
      // Start to find highest and lowest number recursively
      if (findHigh || findLow) {
          recursiveHighLow(data);
      }
      // Overrides of high / low based on reference value, it will make sure that the invisible reference value is
      // used to generate the chart. This is useful when the chart always needs to contain the position of the
      // invisible reference value in the view i.e. for bipolar scales.
      if (options.referenceValue || options.referenceValue === 0) {
          highLow.high = Math.max(options.referenceValue, highLow.high);
          highLow.low = Math.min(options.referenceValue, highLow.low);
      }
      // If high and low are the same because of misconfiguration or flat data (only the same value) we need
      // to set the high or low to 0 depending on the polarity
      if (highLow.high <= highLow.low) {
          // If both values are 0 we set high to 1
          if (highLow.low === 0) {
              highLow.high = 1;
          } else if (highLow.low < 0) {
              // If we have the same negative value for the bounds we set bounds.high to 0
              highLow.high = 0;
          } else if (highLow.high > 0) {
              // If we have the same positive value for the bounds we set bounds.low to 0
              highLow.low = 0;
          } else {
              // If data array was empty, values are Number.MAX_VALUE and -Number.MAX_VALUE. Set bounds to prevent errors
              highLow.high = 1;
              highLow.low = 0;
          }
      }
      return highLow;
  }

  function normalizeData(data) {
      let reverse = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false, multi = arguments.length > 2 ? arguments[2] : void 0, distributed = arguments.length > 3 ? arguments[3] : void 0;
      let labelCount;
      const normalized = {
          labels: (data.labels || []).slice(),
          series: normalizeSeries(data.series, multi, distributed)
      };
      const inputLabelCount = normalized.labels.length;
      // If all elements of the normalized data array are arrays we're dealing with
      // multi series data and we need to find the largest series if they are un-even
      if (isArrayOfArrays(normalized.series)) {
          // Getting the series with the the most elements
          labelCount = Math.max(inputLabelCount, ...normalized.series.map((series)=>series.length
          ));
          normalized.series.forEach((series)=>{
              series.push(...times(Math.max(0, labelCount - series.length)));
          });
      } else {
          // We're dealing with Pie data so we just take the normalized array length
          labelCount = normalized.series.length;
      }
      // Padding the labels to labelCount with empty strings
      normalized.labels.push(...times(Math.max(0, labelCount - inputLabelCount), ()=>""
      ));
      if (reverse) {
          reverseData(normalized);
      }
      return normalized;
  }
  /**
   * Reverses the series, labels and series data arrays.
   */ function reverseData(data) {
      var ref;
      (ref = data.labels) === null || ref === void 0 ? void 0 : ref.reverse();
      data.series.reverse();
      for (const series of data.series){
          if (safeHasProperty(series, "data")) {
              series.data.reverse();
          } else if (Array.isArray(series)) {
              series.reverse();
          }
      }
  }
  function normalizeMulti(value, multi) {
      // We need to prepare multi value output (x and y data)
      let x;
      let y;
      // Single series value arrays are assumed to specify the Y-Axis value
      // For example: [1, 2] => [{x: undefined, y: 1}, {x: undefined, y: 2}]
      // If multi is a string then it's assumed that it specified which dimension should be filled as default
      if (typeof value !== "object") {
          const num = getNumberOrUndefined(value);
          if (multi === "x") {
              x = num;
          } else {
              y = num;
          }
      } else {
          if (safeHasProperty(value, "x")) {
              x = getNumberOrUndefined(value.x);
          }
          if (safeHasProperty(value, "y")) {
              y = getNumberOrUndefined(value.y);
          }
      }
      if (x === undefined && y === undefined) {
          return undefined;
      }
      return {
          x,
          y
      };
  }
  function normalizePrimitive(value, multi) {
      if (isDataHoleValue(value)) {
          // We're dealing with a hole in the data and therefore need to return undefined
          // We're also returning undefined for multi value output
          return undefined;
      }
      if (multi) {
          return normalizeMulti(value, multi);
      }
      return getNumberOrUndefined(value);
  }
  function normalizeSingleSeries(series, multi) {
      if (!Array.isArray(series)) {
          // We are dealing with series object notation so we need to recurse on data property
          return normalizeSingleSeries(series.data, multi);
      }
      return series.map((value)=>{
          if (safeHasProperty(value, "value")) {
              // We are dealing with value object notation so we need to recurse on value property
              return normalizePrimitive(value.value, multi);
          }
          return normalizePrimitive(value, multi);
      });
  }
  function normalizeSeries(series, multi, distributed) {
      if (isArrayOfSeries(series)) {
          return series.map((_)=>normalizeSingleSeries(_, multi)
          );
      }
      const normalizedSeries = normalizeSingleSeries(series, multi);
      if (distributed) {
          return normalizedSeries.map((value)=>[
                  value
              ]
          );
      }
      return normalizedSeries;
  }

  /**
   * Splits a list of coordinates and associated values into segments. Each returned segment contains a pathCoordinates
   * valueData property describing the segment.
   *
   * With the default options, segments consist of contiguous sets of points that do not have an undefined value. Any
   * points with undefined values are discarded.
   *
   * **Options**
   * The following options are used to determine how segments are formed
   * ```javascript
   * var options = {
   *   // If fillHoles is true, undefined values are simply discarded without creating a new segment. Assuming other options are default, this returns single segment.
   *   fillHoles: false,
   *   // If increasingX is true, the coordinates in all segments have strictly increasing x-values.
   *   increasingX: false
   * };
   * ```
   *
   * @param pathCoordinates List of point coordinates to be split in the form [x1, y1, x2, y2 ... xn, yn]
   * @param valueData List of associated point values in the form [v1, v2 .. vn]
   * @param options Options set by user
   * @return List of segments, each containing a pathCoordinates and valueData property.
   */ function splitIntoSegments(pathCoordinates, valueData, options) {
      const finalOptions = {
          increasingX: false,
          fillHoles: false,
          ...options
      };
      const segments = [];
      let hole = true;
      for(let i = 0; i < pathCoordinates.length; i += 2){
          // If this value is a "hole" we set the hole flag
          if (getMultiValue(valueData[i / 2].value) === undefined) {
              // if(valueData[i / 2].value === undefined) {
              if (!finalOptions.fillHoles) {
                  hole = true;
              }
          } else {
              if (finalOptions.increasingX && i >= 2 && pathCoordinates[i] <= pathCoordinates[i - 2]) {
                  // X is not increasing, so we need to make sure we start a new segment
                  hole = true;
              }
              // If it's a valid value we need to check if we're coming out of a hole and create a new empty segment
              if (hole) {
                  segments.push({
                      pathCoordinates: [],
                      valueData: []
                  });
                  // As we have a valid value now, we are not in a "hole" anymore
                  hole = false;
              }
              // Add to the segment pathCoordinates and valueData
              segments[segments.length - 1].pathCoordinates.push(pathCoordinates[i], pathCoordinates[i + 1]);
              segments[segments.length - 1].valueData.push(valueData[i / 2]);
          }
      }
      return segments;
  }

  function serialize(data) {
      let serialized = "";
      if (data === null || data === undefined) {
          return data;
      } else if (typeof data === "number") {
          serialized = "" + data;
      } else if (typeof data === "object") {
          serialized = JSON.stringify({
              data: data
          });
      } else {
          serialized = String(data);
      }
      return Object.keys(escapingMap).reduce((result, key)=>result.replaceAll(key, escapingMap[key])
      , serialized);
  }

  /**
   * This helper class is to wrap multiple `Svg` elements into a list where you can call the `Svg` functions on all elements in the list with one call. This is helpful when you'd like to perform calls with `Svg` on multiple elements.
   * An instance of this class is also returned by `Svg.querySelectorAll`.
   */ class SvgList {
      call(method, args) {
          this.svgElements.forEach((element)=>Reflect.apply(element[method], element, args)
          );
          return this;
      }
      attr() {
          for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
              args[_key] = arguments[_key];
          }
          return this.call("attr", args);
      }
      elem() {
          for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
              args[_key] = arguments[_key];
          }
          return this.call("elem", args);
      }
      root() {
          for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
              args[_key] = arguments[_key];
          }
          return this.call("root", args);
      }
      getNode() {
          for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
              args[_key] = arguments[_key];
          }
          return this.call("getNode", args);
      }
      foreignObject() {
          for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
              args[_key] = arguments[_key];
          }
          return this.call("foreignObject", args);
      }
      text() {
          for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
              args[_key] = arguments[_key];
          }
          return this.call("text", args);
      }
      empty() {
          for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
              args[_key] = arguments[_key];
          }
          return this.call("empty", args);
      }
      remove() {
          for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
              args[_key] = arguments[_key];
          }
          return this.call("remove", args);
      }
      addClass() {
          for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
              args[_key] = arguments[_key];
          }
          return this.call("addClass", args);
      }
      removeClass() {
          for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
              args[_key] = arguments[_key];
          }
          return this.call("removeClass", args);
      }
      removeAllClasses() {
          for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
              args[_key] = arguments[_key];
          }
          return this.call("removeAllClasses", args);
      }
      animate() {
          for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
              args[_key] = arguments[_key];
          }
          return this.call("animate", args);
      }
      /**
     * @param nodeList An Array of SVG DOM nodes or a SVG DOM NodeList (as returned by document.querySelectorAll)
     */ constructor(nodeList){
          this.svgElements = [];
          for(let i = 0; i < nodeList.length; i++){
              this.svgElements.push(new Svg(nodeList[i]));
          }
      }
  }

  /**
   * This Object contains some standard easing cubic bezier curves.
   * Then can be used with their name in the `Svg.animate`.
   * You can also extend the list and use your own name in the `animate` function.
   * Click the show code button to see the available bezier functions.
   */ const easings = {
      easeInSine: [
          0.47,
          0,
          0.745,
          0.715
      ],
      easeOutSine: [
          0.39,
          0.575,
          0.565,
          1
      ],
      easeInOutSine: [
          0.445,
          0.05,
          0.55,
          0.95
      ],
      easeInQuad: [
          0.55,
          0.085,
          0.68,
          0.53
      ],
      easeOutQuad: [
          0.25,
          0.46,
          0.45,
          0.94
      ],
      easeInOutQuad: [
          0.455,
          0.03,
          0.515,
          0.955
      ],
      easeInCubic: [
          0.55,
          0.055,
          0.675,
          0.19
      ],
      easeOutCubic: [
          0.215,
          0.61,
          0.355,
          1
      ],
      easeInOutCubic: [
          0.645,
          0.045,
          0.355,
          1
      ],
      easeInQuart: [
          0.895,
          0.03,
          0.685,
          0.22
      ],
      easeOutQuart: [
          0.165,
          0.84,
          0.44,
          1
      ],
      easeInOutQuart: [
          0.77,
          0,
          0.175,
          1
      ],
      easeInQuint: [
          0.755,
          0.05,
          0.855,
          0.06
      ],
      easeOutQuint: [
          0.23,
          1,
          0.32,
          1
      ],
      easeInOutQuint: [
          0.86,
          0,
          0.07,
          1
      ],
      easeInExpo: [
          0.95,
          0.05,
          0.795,
          0.035
      ],
      easeOutExpo: [
          0.19,
          1,
          0.22,
          1
      ],
      easeInOutExpo: [
          1,
          0,
          0,
          1
      ],
      easeInCirc: [
          0.6,
          0.04,
          0.98,
          0.335
      ],
      easeOutCirc: [
          0.075,
          0.82,
          0.165,
          1
      ],
      easeInOutCirc: [
          0.785,
          0.135,
          0.15,
          0.86
      ],
      easeInBack: [
          0.6,
          -0.28,
          0.735,
          0.045
      ],
      easeOutBack: [
          0.175,
          0.885,
          0.32,
          1.275
      ],
      easeInOutBack: [
          0.68,
          -0.55,
          0.265,
          1.55
      ]
  };
  function createAnimation(element, attribute, animationDefinition) {
      let createGuided = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false, eventEmitter = arguments.length > 4 ? arguments[4] : void 0;
      const { easing , ...def } = animationDefinition;
      const attributeProperties = {};
      let animationEasing;
      let timeout;
      // Check if an easing is specified in the definition object and delete it from the object as it will not
      // be part of the animate element attributes.
      if (easing) {
          // If already an easing Bézier curve array we take it or we lookup a easing array in the Easing object
          animationEasing = Array.isArray(easing) ? easing : easings[easing];
      }
      // If numeric dur or begin was provided we assume milli seconds
      def.begin = ensureUnit(def.begin, "ms");
      def.dur = ensureUnit(def.dur, "ms");
      if (animationEasing) {
          def.calcMode = "spline";
          def.keySplines = animationEasing.join(" ");
          def.keyTimes = "0;1";
      }
      // Adding "fill: freeze" if we are in guided mode and set initial attribute values
      if (createGuided) {
          def.fill = "freeze";
          // Animated property on our element should already be set to the animation from value in guided mode
          attributeProperties[attribute] = def.from;
          element.attr(attributeProperties);
          // In guided mode we also set begin to indefinite so we can trigger the start manually and put the begin
          // which needs to be in ms aside
          timeout = quantity(def.begin || 0).value;
          def.begin = "indefinite";
      }
      const animate = element.elem("animate", {
          attributeName: attribute,
          ...def
      });
      if (createGuided) {
          // If guided we take the value that was put aside in timeout and trigger the animation manually with a timeout
          setTimeout(()=>{
              // If beginElement fails we set the animated attribute to the end position and remove the animate element
              // This happens if the SMIL ElementTimeControl interface is not supported or any other problems occurred in
              // the browser. (Currently FF 34 does not support animate elements in foreignObjects)
              try {
                  // @ts-expect-error Try legacy API.
                  animate._node.beginElement();
              } catch (err) {
                  // Set animated attribute to current animated value
                  attributeProperties[attribute] = def.to;
                  element.attr(attributeProperties);
                  // Remove the animate element as it's no longer required
                  animate.remove();
              }
          }, timeout);
      }
      const animateNode = animate.getNode();
      if (eventEmitter) {
          animateNode.addEventListener("beginEvent", ()=>eventEmitter.emit("animationBegin", {
                  element: element,
                  animate: animateNode,
                  params: animationDefinition
              })
          );
      }
      animateNode.addEventListener("endEvent", ()=>{
          if (eventEmitter) {
              eventEmitter.emit("animationEnd", {
                  element: element,
                  animate: animateNode,
                  params: animationDefinition
              });
          }
          if (createGuided) {
              // Set animated attribute to current animated value
              attributeProperties[attribute] = def.to;
              element.attr(attributeProperties);
              // Remove the animate element as it's no longer required
              animate.remove();
          }
      });
  }

  /**
   * Svg creates a new SVG object wrapper with a starting element. You can use the wrapper to fluently create sub-elements and modify them.
   */ class Svg {
      attr(attributes, ns) {
          if (typeof attributes === "string") {
              if (ns) {
                  return this._node.getAttributeNS(ns, attributes);
              } else {
                  return this._node.getAttribute(attributes);
              }
          }
          Object.keys(attributes).forEach((key)=>{
              // If the attribute value is undefined we can skip this one
              if (attributes[key] === undefined) {
                  return;
              }
              if (key.indexOf(":") !== -1) {
                  const namespacedAttribute = key.split(":");
                  this._node.setAttributeNS(namespaces[namespacedAttribute[0]], key, String(attributes[key]));
              } else {
                  this._node.setAttribute(key, String(attributes[key]));
              }
          });
          return this;
      }
      /**
     * Create a new SVG element whose wrapper object will be selected for further operations. This way you can also create nested groups easily.
     * @param name The name of the SVG element that should be created as child element of the currently selected element wrapper
     * @param attributes An object with properties that will be added as attributes to the SVG element that is created. Attributes with undefined values will not be added.
     * @param className This class or class list will be added to the SVG element
     * @param insertFirst If this param is set to true in conjunction with a parent element the newly created element will be added as first child element in the parent element
     * @return Returns a Svg wrapper object that can be used to modify the containing SVG data
     */ elem(name, attributes, className) {
          let insertFirst = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
          return new Svg(name, attributes, className, this, insertFirst);
      }
      /**
     * Returns the parent Chartist.SVG wrapper object
     * @return Returns a Svg wrapper around the parent node of the current node. If the parent node is not existing or it's not an SVG node then this function will return null.
     */ parent() {
          return this._node.parentNode instanceof SVGElement ? new Svg(this._node.parentNode) : null;
      }
      /**
     * This method returns a Svg wrapper around the root SVG element of the current tree.
     * @return The root SVG element wrapped in a Svg element
     */ root() {
          let node = this._node;
          while(node.nodeName !== "svg"){
              if (node.parentElement) {
                  node = node.parentElement;
              } else {
                  break;
              }
          }
          return new Svg(node);
      }
      /**
     * Find the first child SVG element of the current element that matches a CSS selector. The returned object is a Svg wrapper.
     * @param selector A CSS selector that is used to query for child SVG elements
     * @return The SVG wrapper for the element found or null if no element was found
     */ querySelector(selector) {
          const foundNode = this._node.querySelector(selector);
          return foundNode ? new Svg(foundNode) : null;
      }
      /**
     * Find the all child SVG elements of the current element that match a CSS selector. The returned object is a Svg.List wrapper.
     * @param selector A CSS selector that is used to query for child SVG elements
     * @return The SVG wrapper list for the element found or null if no element was found
     */ querySelectorAll(selector) {
          const foundNodes = this._node.querySelectorAll(selector);
          return new SvgList(foundNodes);
      }
      /**
     * Returns the underlying SVG node for the current element.
     */ getNode() {
          return this._node;
      }
      /**
     * This method creates a foreignObject (see https://developer.mozilla.org/en-US/docs/Web/SVG/Element/foreignObject) that allows to embed HTML content into a SVG graphic. With the help of foreignObjects you can enable the usage of regular HTML elements inside of SVG where they are subject for SVG positioning and transformation but the Browser will use the HTML rendering capabilities for the containing DOM.
     * @param content The DOM Node, or HTML string that will be converted to a DOM Node, that is then placed into and wrapped by the foreignObject
     * @param attributes An object with properties that will be added as attributes to the foreignObject element that is created. Attributes with undefined values will not be added.
     * @param className This class or class list will be added to the SVG element
     * @param insertFirst Specifies if the foreignObject should be inserted as first child
     * @return New wrapper object that wraps the foreignObject element
     */ foreignObject(content, attributes, className) {
          let insertFirst = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
          let contentNode;
          // If content is string then we convert it to DOM
          // TODO: Handle case where content is not a string nor a DOM Node
          if (typeof content === "string") {
              const container = document.createElement("div");
              container.innerHTML = content;
              contentNode = container.firstChild;
          } else {
              contentNode = content;
          }
          if (contentNode instanceof Element) {
              // Adding namespace to content element
              contentNode.setAttribute("xmlns", namespaces.xmlns);
          }
          // Creating the foreignObject without required extension attribute (as described here
          // http://www.w3.org/TR/SVG/extend.html#ForeignObjectElement)
          const fnObj = this.elem("foreignObject", attributes, className, insertFirst);
          // Add content to foreignObjectElement
          fnObj._node.appendChild(contentNode);
          return fnObj;
      }
      /**
     * This method adds a new text element to the current Svg wrapper.
     * @param t The text that should be added to the text element that is created
     * @return The same wrapper object that was used to add the newly created element
     */ text(t) {
          this._node.appendChild(document.createTextNode(t));
          return this;
      }
      /**
     * This method will clear all child nodes of the current wrapper object.
     * @return The same wrapper object that got emptied
     */ empty() {
          while(this._node.firstChild){
              this._node.removeChild(this._node.firstChild);
          }
          return this;
      }
      /**
     * This method will cause the current wrapper to remove itself from its parent wrapper. Use this method if you'd like to get rid of an element in a given DOM structure.
     * @return The parent wrapper object of the element that got removed
     */ remove() {
          var ref;
          (ref = this._node.parentNode) === null || ref === void 0 ? void 0 : ref.removeChild(this._node);
          return this.parent();
      }
      /**
     * This method will replace the element with a new element that can be created outside of the current DOM.
     * @param newElement The new Svg object that will be used to replace the current wrapper object
     * @return The wrapper of the new element
     */ replace(newElement) {
          var ref;
          (ref = this._node.parentNode) === null || ref === void 0 ? void 0 : ref.replaceChild(newElement._node, this._node);
          return newElement;
      }
      /**
     * This method will append an element to the current element as a child.
     * @param element The Svg element that should be added as a child
     * @param insertFirst Specifies if the element should be inserted as first child
     * @return The wrapper of the appended object
     */ append(element) {
          let insertFirst = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
          if (insertFirst && this._node.firstChild) {
              this._node.insertBefore(element._node, this._node.firstChild);
          } else {
              this._node.appendChild(element._node);
          }
          return this;
      }
      /**
     * Returns an array of class names that are attached to the current wrapper element. This method can not be chained further.
     * @return A list of classes or an empty array if there are no classes on the current element
     */ classes() {
          const classNames = this._node.getAttribute("class");
          return classNames ? classNames.trim().split(/\s+/) : [];
      }
      /**
     * Adds one or a space separated list of classes to the current element and ensures the classes are only existing once.
     * @param names A white space separated list of class names
     * @return The wrapper of the current element
     */ addClass(names) {
          this._node.setAttribute("class", this.classes().concat(names.trim().split(/\s+/)).filter(function(elem, pos, self) {
              return self.indexOf(elem) === pos;
          }).join(" "));
          return this;
      }
      /**
     * Removes one or a space separated list of classes from the current element.
     * @param names A white space separated list of class names
     * @return The wrapper of the current element
     */ removeClass(names) {
          const removedClasses = names.trim().split(/\s+/);
          this._node.setAttribute("class", this.classes().filter((name)=>removedClasses.indexOf(name) === -1
          ).join(" "));
          return this;
      }
      /**
     * Removes all classes from the current element.
     * @return The wrapper of the current element
     */ removeAllClasses() {
          this._node.setAttribute("class", "");
          return this;
      }
      /**
     * Get element height using `getBoundingClientRect`
     * @return The elements height in pixels
     */ height() {
          return this._node.getBoundingClientRect().height;
      }
      /**
     * Get element width using `getBoundingClientRect`
     * @return The elements width in pixels
     */ width() {
          return this._node.getBoundingClientRect().width;
      }
      /**
     * The animate function lets you animate the current element with SMIL animations. You can add animations for multiple attributes at the same time by using an animation definition object. This object should contain SMIL animation attributes. Please refer to http://www.w3.org/TR/SVG/animate.html for a detailed specification about the available animation attributes. Additionally an easing property can be passed in the animation definition object. This can be a string with a name of an easing function in `Svg.Easing` or an array with four numbers specifying a cubic Bézier curve.
     * **An animations object could look like this:**
     * ```javascript
     * element.animate({
     *   opacity: {
     *     dur: 1000,
     *     from: 0,
     *     to: 1
     *   },
     *   x1: {
     *     dur: '1000ms',
     *     from: 100,
     *     to: 200,
     *     easing: 'easeOutQuart'
     *   },
     *   y1: {
     *     dur: '2s',
     *     from: 0,
     *     to: 100
     *   }
     * });
     * ```
     * **Automatic unit conversion**
     * For the `dur` and the `begin` animate attribute you can also omit a unit by passing a number. The number will automatically be converted to milli seconds.
     * **Guided mode**
     * The default behavior of SMIL animations with offset using the `begin` attribute is that the attribute will keep it's original value until the animation starts. Mostly this behavior is not desired as you'd like to have your element attributes already initialized with the animation `from` value even before the animation starts. Also if you don't specify `fill="freeze"` on an animate element or if you delete the animation after it's done (which is done in guided mode) the attribute will switch back to the initial value. This behavior is also not desired when performing simple one-time animations. For one-time animations you'd want to trigger animations immediately instead of relative to the document begin time. That's why in guided mode Svg will also use the `begin` property to schedule a timeout and manually start the animation after the timeout. If you're using multiple SMIL definition objects for an attribute (in an array), guided mode will be disabled for this attribute, even if you explicitly enabled it.
     * If guided mode is enabled the following behavior is added:
     * - Before the animation starts (even when delayed with `begin`) the animated attribute will be set already to the `from` value of the animation
     * - `begin` is explicitly set to `indefinite` so it can be started manually without relying on document begin time (creation)
     * - The animate element will be forced to use `fill="freeze"`
     * - The animation will be triggered with `beginElement()` in a timeout where `begin` of the definition object is interpreted in milli seconds. If no `begin` was specified the timeout is triggered immediately.
     * - After the animation the element attribute value will be set to the `to` value of the animation
     * - The animate element is deleted from the DOM
     * @param animations An animations object where the property keys are the attributes you'd like to animate. The properties should be objects again that contain the SMIL animation attributes (usually begin, dur, from, and to). The property begin and dur is auto converted (see Automatic unit conversion). You can also schedule multiple animations for the same attribute by passing an Array of SMIL definition objects. Attributes that contain an array of SMIL definition objects will not be executed in guided mode.
     * @param guided Specify if guided mode should be activated for this animation (see Guided mode). If not otherwise specified, guided mode will be activated.
     * @param eventEmitter If specified, this event emitter will be notified when an animation starts or ends.
     * @return The current element where the animation was added
     */ animate(animations) {
          let guided = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true, eventEmitter = arguments.length > 2 ? arguments[2] : void 0;
          Object.keys(animations).forEach((attribute)=>{
              const attributeAnimation = animations[attribute];
              // If current attribute is an array of definition objects we create an animate for each and disable guided mode
              if (Array.isArray(attributeAnimation)) {
                  attributeAnimation.forEach((animationDefinition)=>createAnimation(this, attribute, animationDefinition, false, eventEmitter)
                  );
              } else {
                  createAnimation(this, attribute, attributeAnimation, guided, eventEmitter);
              }
          });
          return this;
      }
      /**
     * @param name The name of the SVG element to create or an SVG dom element which should be wrapped into Svg
     * @param attributes An object with properties that will be added as attributes to the SVG element that is created. Attributes with undefined values will not be added.
     * @param className This class or class list will be added to the SVG element
     * @param parent The parent SVG wrapper object where this newly created wrapper and it's element will be attached to as child
     * @param insertFirst If this param is set to true in conjunction with a parent element the newly created element will be added as first child element in the parent element
     */ constructor(name, attributes, className, parent, insertFirst = false){
          // If Svg is getting called with an SVG element we just return the wrapper
          if (name instanceof Element) {
              this._node = name;
          } else {
              this._node = document.createElementNS(namespaces.svg, name);
              // If this is an SVG element created then custom namespace
              if (name === "svg") {
                  this.attr({
                      "xmlns:ct": namespaces.ct
                  });
              }
          }
          if (attributes) {
              this.attr(attributes);
          }
          if (className) {
              this.addClass(className);
          }
          if (parent) {
              if (insertFirst && parent._node.firstChild) {
                  parent._node.insertBefore(this._node, parent._node.firstChild);
              } else {
                  parent._node.appendChild(this._node);
              }
          }
      }
  }
  /**
     * @todo Only there for chartist <1 compatibility. Remove after deprecation warining.
     * @deprecated Use the animation module export `easings` directly.
     */ Svg.Easing = easings;

  /**
   * Create or reinitialize the SVG element for the chart
   * @param container The containing DOM Node object that will be used to plant the SVG element
   * @param width Set the width of the SVG element. Default is 100%
   * @param height Set the height of the SVG element. Default is 100%
   * @param className Specify a class to be added to the SVG element
   * @return The created/reinitialized SVG element
   */ function createSvg(container) {
      let width = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "100%", height = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "100%", className = arguments.length > 3 ? arguments[3] : void 0;
      // Check if there is a previous SVG element in the container that contains the Chartist XML namespace and remove it
      // Since the DOM API does not support namespaces we need to manually search the returned list http://www.w3.org/TR/selectors-api/
      Array.from(container.querySelectorAll("svg")).filter((svg)=>svg.getAttributeNS(namespaces.xmlns, "ct")
      ).forEach((svg)=>container.removeChild(svg)
      );
      // Create svg object with width and height or use 100% as default
      const svg1 = new Svg("svg").attr({
          width,
          height
      }).attr({
          // TODO: Check better solution (browser support) and remove inline styles due to CSP
          style: "width: ".concat(width, "; height: ").concat(height, ";")
      });
      if (className) {
          svg1.addClass(className);
      }
      // Add the DOM node to our container
      container.appendChild(svg1.getNode());
      return svg1;
  }
  /**
   * Converts a number into a padding object.
   * @param padding
   * @param fallback This value is used to fill missing values if a incomplete padding object was passed
   * @returns Returns a padding object containing top, right, bottom, left properties filled with the padding number passed in as argument. If the argument is something else than a number (presumably already a correct padding object) then this argument is directly returned.
   */ function normalizePadding(padding) {
      return typeof padding === "number" ? {
          top: padding,
          right: padding,
          bottom: padding,
          left: padding
      } : padding === undefined ? {
          top: 0,
          right: 0,
          bottom: 0,
          left: 0
      } : {
          top: typeof padding.top === "number" ? padding.top : 0,
          right: typeof padding.right === "number" ? padding.right : 0,
          bottom: typeof padding.bottom === "number" ? padding.bottom : 0,
          left: typeof padding.left === "number" ? padding.left : 0
      };
  }
  /**
   * Initialize chart drawing rectangle (area where chart is drawn) x1,y1 = bottom left / x2,y2 = top right
   * @param svg The svg element for the chart
   * @param options The Object that contains all the optional values for the chart
   * @return The chart rectangles coordinates inside the svg element plus the rectangles measurements
   */ function createChartRect(svg, options) {
      var ref, ref1, ref2, ref3;
      const hasAxis = Boolean(options.axisX || options.axisY);
      const yAxisOffset = ((ref = options.axisY) === null || ref === void 0 ? void 0 : ref.offset) || 0;
      const xAxisOffset = ((ref1 = options.axisX) === null || ref1 === void 0 ? void 0 : ref1.offset) || 0;
      const yAxisPosition = (ref2 = options.axisY) === null || ref2 === void 0 ? void 0 : ref2.position;
      const xAxisPosition = (ref3 = options.axisX) === null || ref3 === void 0 ? void 0 : ref3.position;
      // If width or height results in invalid value (including 0) we fallback to the unitless settings or even 0
      let width = svg.width() || quantity(options.width).value || 0;
      let height = svg.height() || quantity(options.height).value || 0;
      const normalizedPadding = normalizePadding(options.chartPadding);
      // If settings were to small to cope with offset (legacy) and padding, we'll adjust
      width = Math.max(width, yAxisOffset + normalizedPadding.left + normalizedPadding.right);
      height = Math.max(height, xAxisOffset + normalizedPadding.top + normalizedPadding.bottom);
      const chartRect = {
          x1: 0,
          x2: 0,
          y1: 0,
          y2: 0,
          padding: normalizedPadding,
          width () {
              return this.x2 - this.x1;
          },
          height () {
              return this.y1 - this.y2;
          }
      };
      if (hasAxis) {
          if (xAxisPosition === "start") {
              chartRect.y2 = normalizedPadding.top + xAxisOffset;
              chartRect.y1 = Math.max(height - normalizedPadding.bottom, chartRect.y2 + 1);
          } else {
              chartRect.y2 = normalizedPadding.top;
              chartRect.y1 = Math.max(height - normalizedPadding.bottom - xAxisOffset, chartRect.y2 + 1);
          }
          if (yAxisPosition === "start") {
              chartRect.x1 = normalizedPadding.left + yAxisOffset;
              chartRect.x2 = Math.max(width - normalizedPadding.right, chartRect.x1 + 1);
          } else {
              chartRect.x1 = normalizedPadding.left;
              chartRect.x2 = Math.max(width - normalizedPadding.right - yAxisOffset, chartRect.x1 + 1);
          }
      } else {
          chartRect.x1 = normalizedPadding.left;
          chartRect.x2 = Math.max(width - normalizedPadding.right, chartRect.x1 + 1);
          chartRect.y2 = normalizedPadding.top;
          chartRect.y1 = Math.max(height - normalizedPadding.bottom, chartRect.y2 + 1);
      }
      return chartRect;
  }
  /**
   * Creates a grid line based on a projected value.
   */ function createGrid(position, index, axis, offset, length, group, classes, eventEmitter) {
      const positionalData = {
          ["".concat(axis.units.pos, "1")]: position,
          ["".concat(axis.units.pos, "2")]: position,
          ["".concat(axis.counterUnits.pos, "1")]: offset,
          ["".concat(axis.counterUnits.pos, "2")]: offset + length
      };
      const gridElement = group.elem("line", positionalData, classes.join(" "));
      // Event for grid draw
      eventEmitter.emit("draw", {
          type: "grid",
          axis,
          index,
          group,
          element: gridElement,
          ...positionalData
      });
  }
  /**
   * Creates a grid background rect and emits the draw event.
   */ function createGridBackground(gridGroup, chartRect, className, eventEmitter) {
      const gridBackground = gridGroup.elem("rect", {
          x: chartRect.x1,
          y: chartRect.y2,
          width: chartRect.width(),
          height: chartRect.height()
      }, className, true);
      // Event for grid background draw
      eventEmitter.emit("draw", {
          type: "gridBackground",
          group: gridGroup,
          element: gridBackground
      });
  }
  /**
   * Creates a label based on a projected value and an axis.
   */ function createLabel(position, length, index, label, axis, axisOffset, labelOffset, group, classes, eventEmitter) {
      const positionalData = {
          [axis.units.pos]: position + labelOffset[axis.units.pos],
          [axis.counterUnits.pos]: labelOffset[axis.counterUnits.pos],
          [axis.units.len]: length,
          [axis.counterUnits.len]: Math.max(0, axisOffset - 10)
      };
      // We need to set width and height explicitly to px as span will not expand with width and height being
      // 100% in all browsers
      const stepLength = Math.round(positionalData[axis.units.len]);
      const stepCounterLength = Math.round(positionalData[axis.counterUnits.len]);
      const content = document.createElement("span");
      content.className = classes.join(" ");
      content.style[axis.units.len] = stepLength + "px";
      content.style[axis.counterUnits.len] = stepCounterLength + "px";
      content.textContent = String(label);
      const labelElement = group.foreignObject(content, {
          style: "overflow: visible;",
          ...positionalData
      });
      eventEmitter.emit("draw", {
          type: "label",
          axis,
          index,
          group,
          element: labelElement,
          text: label,
          ...positionalData
      });
  }

  /**
   * Provides options handling functionality with callback for options changes triggered by responsive options and media query matches
   * @param options Options set by user
   * @param responsiveOptions Optional functions to add responsive behavior to chart
   * @param eventEmitter The event emitter that will be used to emit the options changed events
   * @return The consolidated options object from the defaults, base and matching responsive options
   */ function optionsProvider(options, responsiveOptions, eventEmitter) {
      let currentOptions;
      const mediaQueryListeners = [];
      function updateCurrentOptions(mediaEvent) {
          const previousOptions = currentOptions;
          currentOptions = extend({}, options);
          if (responsiveOptions) {
              responsiveOptions.forEach((responsiveOption)=>{
                  const mql = window.matchMedia(responsiveOption[0]);
                  if (mql.matches) {
                      currentOptions = extend(currentOptions, responsiveOption[1]);
                  }
              });
          }
          if (eventEmitter && mediaEvent) {
              eventEmitter.emit("optionsChanged", {
                  previousOptions,
                  currentOptions
              });
          }
      }
      function removeMediaQueryListeners() {
          mediaQueryListeners.forEach((mql)=>mql.removeEventListener("change", updateCurrentOptions)
          );
      }
      if (!window.matchMedia) {
          throw new Error("window.matchMedia not found! Make sure you're using a polyfill.");
      } else if (responsiveOptions) {
          responsiveOptions.forEach((responsiveOption)=>{
              const mql = window.matchMedia(responsiveOption[0]);
              mql.addEventListener("change", updateCurrentOptions);
              mediaQueryListeners.push(mql);
          });
      }
      // Execute initially without an event argument so we get the correct options
      updateCurrentOptions();
      return {
          removeMediaQueryListeners,
          getCurrentOptions () {
              return currentOptions;
          }
      };
  }

  /**
   * Contains the descriptors of supported element types in a SVG path. Currently only move, line and curve are supported.
   */ const elementDescriptions = {
      m: [
          "x",
          "y"
      ],
      l: [
          "x",
          "y"
      ],
      c: [
          "x1",
          "y1",
          "x2",
          "y2",
          "x",
          "y"
      ],
      a: [
          "rx",
          "ry",
          "xAr",
          "lAf",
          "sf",
          "x",
          "y"
      ]
  };
  /**
   * Default options for newly created SVG path objects.
   */ const defaultOptions$3 = {
      // The accuracy in digit count after the decimal point. This will be used to round numbers in the SVG path. If this option is set to false then no rounding will be performed.
      accuracy: 3
  };
  function element(command, params, pathElements, pos, relative, data) {
      const pathElement = {
          command: relative ? command.toLowerCase() : command.toUpperCase(),
          ...params,
          ...data ? {
              data
          } : {}
      };
      pathElements.splice(pos, 0, pathElement);
  }
  function forEachParam(pathElements, cb) {
      pathElements.forEach((pathElement, pathElementIndex)=>{
          elementDescriptions[pathElement.command.toLowerCase()].forEach((paramName, paramIndex)=>{
              cb(pathElement, paramName, pathElementIndex, paramIndex, pathElements);
          });
      });
  }
  class SvgPath {
      /**
     * This static function on `SvgPath` is joining multiple paths together into one paths.
     * @param paths A list of paths to be joined together. The order is important.
     * @param close If the newly created path should be a closed path
     * @param options Path options for the newly created path.
     */ static join(paths) {
          let close = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false, options = arguments.length > 2 ? arguments[2] : void 0;
          const joinedPath = new SvgPath(close, options);
          for(let i = 0; i < paths.length; i++){
              const path = paths[i];
              for(let j = 0; j < path.pathElements.length; j++){
                  joinedPath.pathElements.push(path.pathElements[j]);
              }
          }
          return joinedPath;
      }
      position(pos) {
          if (pos !== undefined) {
              this.pos = Math.max(0, Math.min(this.pathElements.length, pos));
              return this;
          } else {
              return this.pos;
          }
      }
      /**
     * Removes elements from the path starting at the current position.
     * @param count Number of path elements that should be removed from the current position.
     * @return The current path object for easy call chaining.
     */ remove(count) {
          this.pathElements.splice(this.pos, count);
          return this;
      }
      /**
     * Use this function to add a new move SVG path element.
     * @param x The x coordinate for the move element.
     * @param y The y coordinate for the move element.
     * @param relative If set to true the move element will be created with relative coordinates (lowercase letter)
     * @param data Any data that should be stored with the element object that will be accessible in pathElement
     * @return The current path object for easy call chaining.
     */ move(x, y) {
          let relative = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false, data = arguments.length > 3 ? arguments[3] : void 0;
          element("M", {
              x: +x,
              y: +y
          }, this.pathElements, this.pos++, relative, data);
          return this;
      }
      /**
     * Use this function to add a new line SVG path element.
     * @param x The x coordinate for the line element.
     * @param y The y coordinate for the line element.
     * @param relative If set to true the line element will be created with relative coordinates (lowercase letter)
     * @param data Any data that should be stored with the element object that will be accessible in pathElement
     * @return The current path object for easy call chaining.
     */ line(x, y) {
          let relative = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false, data = arguments.length > 3 ? arguments[3] : void 0;
          element("L", {
              x: +x,
              y: +y
          }, this.pathElements, this.pos++, relative, data);
          return this;
      }
      /**
     * Use this function to add a new curve SVG path element.
     * @param x1 The x coordinate for the first control point of the bezier curve.
     * @param y1 The y coordinate for the first control point of the bezier curve.
     * @param x2 The x coordinate for the second control point of the bezier curve.
     * @param y2 The y coordinate for the second control point of the bezier curve.
     * @param x The x coordinate for the target point of the curve element.
     * @param y The y coordinate for the target point of the curve element.
     * @param relative If set to true the curve element will be created with relative coordinates (lowercase letter)
     * @param data Any data that should be stored with the element object that will be accessible in pathElement
     * @return The current path object for easy call chaining.
     */ curve(x1, y1, x2, y2, x, y) {
          let relative = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : false, data = arguments.length > 7 ? arguments[7] : void 0;
          element("C", {
              x1: +x1,
              y1: +y1,
              x2: +x2,
              y2: +y2,
              x: +x,
              y: +y
          }, this.pathElements, this.pos++, relative, data);
          return this;
      }
      /**
     * Use this function to add a new non-bezier curve SVG path element.
     * @param rx The radius to be used for the x-axis of the arc.
     * @param ry The radius to be used for the y-axis of the arc.
     * @param xAr Defines the orientation of the arc
     * @param lAf Large arc flag
     * @param sf Sweep flag
     * @param x The x coordinate for the target point of the curve element.
     * @param y The y coordinate for the target point of the curve element.
     * @param relative If set to true the curve element will be created with relative coordinates (lowercase letter)
     * @param data Any data that should be stored with the element object that will be accessible in pathElement
     * @return The current path object for easy call chaining.
     */ arc(rx, ry, xAr, lAf, sf, x, y) {
          let relative = arguments.length > 7 && arguments[7] !== void 0 ? arguments[7] : false, data = arguments.length > 8 ? arguments[8] : void 0;
          element("A", {
              rx,
              ry,
              xAr,
              lAf,
              sf,
              x,
              y
          }, this.pathElements, this.pos++, relative, data);
          return this;
      }
      /**
     * Parses an SVG path seen in the d attribute of path elements, and inserts the parsed elements into the existing path object at the current cursor position. Any closing path indicators (Z at the end of the path) will be ignored by the parser as this is provided by the close option in the options of the path object.
     * @param path Any SVG path that contains move (m), line (l) or curve (c) components.
     * @return The current path object for easy call chaining.
     */ parse(path) {
          // Parsing the SVG path string into an array of arrays [['M', '10', '10'], ['L', '100', '100']]
          const chunks = path.replace(/([A-Za-z])(-?[0-9])/g, "$1 $2").replace(/([0-9])([A-Za-z])/g, "$1 $2").split(/[\s,]+/).reduce((result, pathElement)=>{
              if (pathElement.match(/[A-Za-z]/)) {
                  result.push([]);
              }
              result[result.length - 1].push(pathElement);
              return result;
          }, []);
          // If this is a closed path we remove the Z at the end because this is determined by the close option
          if (chunks[chunks.length - 1][0].toUpperCase() === "Z") {
              chunks.pop();
          }
          // Using svgPathElementDescriptions to map raw path arrays into objects that contain the command and the parameters
          // For example {command: 'M', x: '10', y: '10'}
          const elements = chunks.map((chunk)=>{
              const command = chunk.shift();
              const description = elementDescriptions[command.toLowerCase()];
              return {
                  command,
                  ...description.reduce((result, paramName, index)=>{
                      result[paramName] = +chunk[index];
                      return result;
                  }, {})
              };
          });
          // Preparing a splice call with the elements array as var arg params and insert the parsed elements at the current position
          this.pathElements.splice(this.pos, 0, ...elements);
          // Increase the internal position by the element count
          this.pos += elements.length;
          return this;
      }
      /**
     * This function renders to current SVG path object into a final SVG string that can be used in the d attribute of SVG path elements. It uses the accuracy option to round big decimals. If the close parameter was set in the constructor of this path object then a path closing Z will be appended to the output string.
     */ stringify() {
          const accuracyMultiplier = Math.pow(10, this.options.accuracy);
          return this.pathElements.reduce((path, pathElement)=>{
              const params = elementDescriptions[pathElement.command.toLowerCase()].map((paramName)=>{
                  const value = pathElement[paramName];
                  return this.options.accuracy ? Math.round(value * accuracyMultiplier) / accuracyMultiplier : value;
              });
              return path + pathElement.command + params.join(",");
          }, "") + (this.close ? "Z" : "");
      }
      /**
     * Scales all elements in the current SVG path object. There is an individual parameter for each coordinate. Scaling will also be done for control points of curves, affecting the given coordinate.
     * @param x The number which will be used to scale the x, x1 and x2 of all path elements.
     * @param y The number which will be used to scale the y, y1 and y2 of all path elements.
     * @return The current path object for easy call chaining.
     */ scale(x, y) {
          forEachParam(this.pathElements, (pathElement, paramName)=>{
              pathElement[paramName] *= paramName[0] === "x" ? x : y;
          });
          return this;
      }
      /**
     * Translates all elements in the current SVG path object. The translation is relative and there is an individual parameter for each coordinate. Translation will also be done for control points of curves, affecting the given coordinate.
     * @param x The number which will be used to translate the x, x1 and x2 of all path elements.
     * @param y The number which will be used to translate the y, y1 and y2 of all path elements.
     * @return The current path object for easy call chaining.
     */ translate(x, y) {
          forEachParam(this.pathElements, (pathElement, paramName)=>{
              pathElement[paramName] += paramName[0] === "x" ? x : y;
          });
          return this;
      }
      /**
     * This function will run over all existing path elements and then loop over their attributes. The callback function will be called for every path element attribute that exists in the current path.
     * The method signature of the callback function looks like this:
     * ```javascript
     * function(pathElement, paramName, pathElementIndex, paramIndex, pathElements)
     * ```
     * If something else than undefined is returned by the callback function, this value will be used to replace the old value. This allows you to build custom transformations of path objects that can't be achieved using the basic transformation functions scale and translate.
     * @param transformFnc The callback function for the transformation. Check the signature in the function description.
     * @return The current path object for easy call chaining.
     */ transform(transformFnc) {
          forEachParam(this.pathElements, (pathElement, paramName, pathElementIndex, paramIndex, pathElements)=>{
              const transformed = transformFnc(pathElement, paramName, pathElementIndex, paramIndex, pathElements);
              if (transformed || transformed === 0) {
                  pathElement[paramName] = transformed;
              }
          });
          return this;
      }
      /**
     * This function clones a whole path object with all its properties. This is a deep clone and path element objects will also be cloned.
     * @param close Optional option to set the new cloned path to closed. If not specified or false, the original path close option will be used.
     */ clone() {
          let close = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
          const clone = new SvgPath(close || this.close);
          clone.pos = this.pos;
          clone.pathElements = this.pathElements.slice().map((pathElement)=>({
                  ...pathElement
              })
          );
          clone.options = {
              ...this.options
          };
          return clone;
      }
      /**
     * Split a Svg.Path object by a specific command in the path chain. The path chain will be split and an array of newly created paths objects will be returned. This is useful if you'd like to split an SVG path by it's move commands, for example, in order to isolate chunks of drawings.
     * @param command The command you'd like to use to split the path
     */ splitByCommand(command) {
          const split = [
              new SvgPath()
          ];
          this.pathElements.forEach((pathElement)=>{
              if (pathElement.command === command.toUpperCase() && split[split.length - 1].pathElements.length !== 0) {
                  split.push(new SvgPath());
              }
              split[split.length - 1].pathElements.push(pathElement);
          });
          return split;
      }
      /**
     * Used to construct a new path object.
     * @param close If set to true then this path will be closed when stringified (with a Z at the end)
     * @param options Options object that overrides the default objects. See default options for more details.
     */ constructor(close = false, options){
          this.close = close;
          this.pathElements = [];
          this.pos = 0;
          this.options = {
              ...defaultOptions$3,
              ...options
          };
      }
  }

  /**
   * This interpolation function does not smooth the path and the result is only containing lines and no curves.
   *
   * @example
   * ```ts
   * const chart = new LineChart('.ct-chart', {
   *   labels: [1, 2, 3, 4, 5],
   *   series: [[1, 2, 8, 1, 7]]
   * }, {
   *   lineSmooth: Interpolation.none({
   *     fillHoles: false
   *   })
   * });
   * ```
   */ function none(options) {
      const finalOptions = {
          fillHoles: false,
          ...options
      };
      return function noneInterpolation(pathCoordinates, valueData) {
          const path = new SvgPath();
          let hole = true;
          for(let i = 0; i < pathCoordinates.length; i += 2){
              const currX = pathCoordinates[i];
              const currY = pathCoordinates[i + 1];
              const currData = valueData[i / 2];
              if (getMultiValue(currData.value) !== undefined) {
                  if (hole) {
                      path.move(currX, currY, false, currData);
                  } else {
                      path.line(currX, currY, false, currData);
                  }
                  hole = false;
              } else if (!finalOptions.fillHoles) {
                  hole = true;
              }
          }
          return path;
      };
  }

  /**
   * Monotone Cubic spline interpolation produces a smooth curve which preserves monotonicity. Unlike cardinal splines, the curve will not extend beyond the range of y-values of the original data points.
   *
   * Monotone Cubic splines can only be created if there are more than two data points. If this is not the case this smoothing will fallback to `Chartist.Smoothing.none`.
   *
   * The x-values of subsequent points must be increasing to fit a Monotone Cubic spline. If this condition is not met for a pair of adjacent points, then there will be a break in the curve between those data points.
   *
   * All smoothing functions within Chartist are factory functions that accept an options parameter.
   *
   * @example
   * ```ts
   * const chart = new LineChart('.ct-chart', {
   *   labels: [1, 2, 3, 4, 5],
   *   series: [[1, 2, 8, 1, 7]]
   * }, {
   *   lineSmooth: Interpolation.monotoneCubic({
   *     fillHoles: false
   *   })
   * });
   * ```
   *
   * @param options The options of the monotoneCubic factory function.
   */ function monotoneCubic(options) {
      const finalOptions = {
          fillHoles: false,
          ...options
      };
      return function monotoneCubicInterpolation(pathCoordinates, valueData) {
          // First we try to split the coordinates into segments
          // This is necessary to treat "holes" in line charts
          const segments = splitIntoSegments(pathCoordinates, valueData, {
              fillHoles: finalOptions.fillHoles,
              increasingX: true
          });
          if (!segments.length) {
              // If there were no segments return 'Chartist.Interpolation.none'
              return none()([], []);
          } else if (segments.length > 1) {
              // If the split resulted in more that one segment we need to interpolate each segment individually and join them
              // afterwards together into a single path.
              // For each segment we will recurse the monotoneCubic fn function
              // Join the segment path data into a single path and return
              return SvgPath.join(segments.map((segment)=>monotoneCubicInterpolation(segment.pathCoordinates, segment.valueData)
              ));
          } else {
              // If there was only one segment we can proceed regularly by using pathCoordinates and valueData from the first
              // segment
              pathCoordinates = segments[0].pathCoordinates;
              valueData = segments[0].valueData;
              // If less than three points we need to fallback to no smoothing
              if (pathCoordinates.length <= 4) {
                  return none()(pathCoordinates, valueData);
              }
              const xs = [];
              const ys = [];
              const n = pathCoordinates.length / 2;
              const ms = [];
              const ds = [];
              const dys = [];
              const dxs = [];
              // Populate x and y coordinates into separate arrays, for readability
              for(let i = 0; i < n; i++){
                  xs[i] = pathCoordinates[i * 2];
                  ys[i] = pathCoordinates[i * 2 + 1];
              }
              // Calculate deltas and derivative
              for(let i1 = 0; i1 < n - 1; i1++){
                  dys[i1] = ys[i1 + 1] - ys[i1];
                  dxs[i1] = xs[i1 + 1] - xs[i1];
                  ds[i1] = dys[i1] / dxs[i1];
              }
              // Determine desired slope (m) at each point using Fritsch-Carlson method
              // See: http://math.stackexchange.com/questions/45218/implementation-of-monotone-cubic-interpolation
              ms[0] = ds[0];
              ms[n - 1] = ds[n - 2];
              for(let i2 = 1; i2 < n - 1; i2++){
                  if (ds[i2] === 0 || ds[i2 - 1] === 0 || ds[i2 - 1] > 0 !== ds[i2] > 0) {
                      ms[i2] = 0;
                  } else {
                      ms[i2] = 3 * (dxs[i2 - 1] + dxs[i2]) / ((2 * dxs[i2] + dxs[i2 - 1]) / ds[i2 - 1] + (dxs[i2] + 2 * dxs[i2 - 1]) / ds[i2]);
                      if (!isFinite(ms[i2])) {
                          ms[i2] = 0;
                      }
                  }
              }
              // Now build a path from the slopes
              const path = new SvgPath().move(xs[0], ys[0], false, valueData[0]);
              for(let i3 = 0; i3 < n - 1; i3++){
                  path.curve(// First control point
                  xs[i3] + dxs[i3] / 3, ys[i3] + ms[i3] * dxs[i3] / 3, // Second control point
                  xs[i3 + 1] - dxs[i3] / 3, ys[i3 + 1] - ms[i3 + 1] * dxs[i3] / 3, // End point
                  xs[i3 + 1], ys[i3 + 1], false, valueData[i3 + 1]);
              }
              return path;
          }
      };
  }

  class EventEmitter {
      on(event, listener) {
          const { allListeners , listeners  } = this;
          if (event === "*") {
              allListeners.add(listener);
          } else {
              if (!listeners.has(event)) {
                  listeners.set(event, new Set());
              }
              listeners.get(event).add(listener);
          }
      }
      off(event, listener) {
          const { allListeners , listeners  } = this;
          if (event === "*") {
              if (listener) {
                  allListeners.delete(listener);
              } else {
                  allListeners.clear();
              }
          } else if (listeners.has(event)) {
              const eventListeners = listeners.get(event);
              if (listener) {
                  eventListeners.delete(listener);
              } else {
                  eventListeners.clear();
              }
              if (!eventListeners.size) {
                  listeners.delete(event);
              }
          }
      }
      /**
     * Use this function to emit an event. All handlers that are listening for this event will be triggered with the data parameter.
     * @param event The event name that should be triggered
     * @param data Arbitrary data that will be passed to the event handler callback functions
     */ emit(event, data) {
          const { allListeners , listeners  } = this;
          // Only do something if there are event handlers with this name existing
          if (listeners.has(event)) {
              listeners.get(event).forEach((listener)=>listener(data)
              );
          }
          // Emit event to star event handlers
          allListeners.forEach((listener)=>listener(event, data)
          );
      }
      constructor(){
          this.listeners = new Map();
          this.allListeners = new Set();
      }
  }

  const instances = new WeakMap();
  class BaseChart {
      // TODO: Currently we need to re-draw the chart on window resize. This is usually very bad and will affect performance.
      // This is done because we can't work with relative coordinates when drawing the chart because SVG Path does not
      // work with relative positions yet. We need to check if we can do a viewBox hack to switch to percentage.
      // See http://mozilla.6506.n7.nabble.com/Specyfing-paths-with-percentages-unit-td247474.html
      // Update: can be done using the above method tested here: http://codepen.io/gionkunz/pen/KDvLj
      // The problem is with the label offsets that can't be converted into percentage and affecting the chart container
      /**
     * Updates the chart which currently does a full reconstruction of the SVG DOM
     * @param data Optional data you'd like to set for the chart before it will update. If not specified the update method will use the data that is already configured with the chart.
     * @param options Optional options you'd like to add to the previous options for the chart before it will update. If not specified the update method will use the options that have been already configured with the chart.
     * @param override If set to true, the passed options will be used to extend the options that have been configured already. Otherwise the chart default options will be used as the base
     */ update(data, options) {
          let override = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
          if (data) {
              this.data = data || {};
              this.data.labels = this.data.labels || [];
              this.data.series = this.data.series || [];
              // Event for data transformation that allows to manipulate the data before it gets rendered in the charts
              this.eventEmitter.emit("data", {
                  type: "update",
                  data: this.data
              });
          }
          if (options) {
              this.options = extend({}, override ? this.options : this.defaultOptions, options);
              // If chartist was not initialized yet, we just set the options and leave the rest to the initialization
              // Otherwise we re-create the optionsProvider at this point
              if (!this.initializeTimeoutId) {
                  var ref;
                  (ref = this.optionsProvider) === null || ref === void 0 ? void 0 : ref.removeMediaQueryListeners();
                  this.optionsProvider = optionsProvider(this.options, this.responsiveOptions, this.eventEmitter);
              }
          }
          // Only re-created the chart if it has been initialized yet
          if (!this.initializeTimeoutId && this.optionsProvider) {
              this.createChart(this.optionsProvider.getCurrentOptions());
          }
          // Return a reference to the chart object to chain up calls
          return this;
      }
      /**
     * This method can be called on the API object of each chart and will un-register all event listeners that were added to other components. This currently includes a window.resize listener as well as media query listeners if any responsive options have been provided. Use this function if you need to destroy and recreate Chartist charts dynamically.
     */ detach() {
          // Only detach if initialization already occurred on this chart. If this chart still hasn't initialized (therefore
          // the initializationTimeoutId is still a valid timeout reference, we will clear the timeout
          if (!this.initializeTimeoutId) {
              var ref;
              window.removeEventListener("resize", this.resizeListener);
              (ref = this.optionsProvider) === null || ref === void 0 ? void 0 : ref.removeMediaQueryListeners();
          } else {
              window.clearTimeout(this.initializeTimeoutId);
          }
          instances.delete(this.container);
          return this;
      }
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      on(event, listener) {
          this.eventEmitter.on(event, listener);
          return this;
      }
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      off(event, listener) {
          this.eventEmitter.off(event, listener);
          return this;
      }
      initialize() {
          // Add window resize listener that re-creates the chart
          window.addEventListener("resize", this.resizeListener);
          // Obtain current options based on matching media queries (if responsive options are given)
          // This will also register a listener that is re-creating the chart based on media changes
          this.optionsProvider = optionsProvider(this.options, this.responsiveOptions, this.eventEmitter);
          // Register options change listener that will trigger a chart update
          this.eventEmitter.on("optionsChanged", ()=>this.update()
          );
          // Before the first chart creation we need to register us with all plugins that are configured
          // Initialize all relevant plugins with our chart object and the plugin options specified in the config
          if (this.options.plugins) {
              this.options.plugins.forEach((plugin)=>{
                  if (Array.isArray(plugin)) {
                      plugin[0](this, plugin[1]);
                  } else {
                      plugin(this);
                  }
              });
          }
          // Event for data transformation that allows to manipulate the data before it gets rendered in the charts
          this.eventEmitter.emit("data", {
              type: "initial",
              data: this.data
          });
          // Create the first chart
          this.createChart(this.optionsProvider.getCurrentOptions());
          // As chart is initialized from the event loop now we can reset our timeout reference
          // This is important if the chart gets initialized on the same element twice
          this.initializeTimeoutId = null;
      }
      constructor(query, data, defaultOptions, options, responsiveOptions){
          this.data = data;
          this.defaultOptions = defaultOptions;
          this.options = options;
          this.responsiveOptions = responsiveOptions;
          this.eventEmitter = new EventEmitter();
          this.resizeListener = ()=>this.update()
          ;
          this.initializeTimeoutId = setTimeout(()=>this.initialize()
          , 0);
          const container = typeof query === "string" ? document.querySelector(query) : query;
          if (!container) {
              throw new Error("Target element is not found");
          }
          this.container = container;
          const prevInstance = instances.get(container);
          // If chartist was already initialized in this container we are detaching all event listeners first
          if (prevInstance) {
              prevInstance.detach();
          }
          instances.set(container, this);
      }
  }

  const axisUnits = {
      x: {
          pos: "x",
          len: "width",
          dir: "horizontal",
          rectStart: "x1",
          rectEnd: "x2",
          rectOffset: "y2"
      },
      y: {
          pos: "y",
          len: "height",
          dir: "vertical",
          rectStart: "y2",
          rectEnd: "y1",
          rectOffset: "x1"
      }
  };
  class Axis {
      createGridAndLabels(gridGroup, labelGroup, chartOptions, eventEmitter) {
          const axisOptions = this.units.pos === "x" ? chartOptions.axisX : chartOptions.axisY;
          const projectedValues = this.ticks.map((tick, i)=>this.projectValue(tick, i)
          );
          const labelValues = this.ticks.map(axisOptions.labelInterpolationFnc);
          projectedValues.forEach((projectedValue, index)=>{
              const labelValue = labelValues[index];
              const labelOffset = {
                  x: 0,
                  y: 0
              };
              // TODO: Find better solution for solving this problem
              // Calculate how much space we have available for the label
              let labelLength;
              if (projectedValues[index + 1]) {
                  // If we still have one label ahead, we can calculate the distance to the next tick / label
                  labelLength = projectedValues[index + 1] - projectedValue;
              } else {
                  // If we don't have a label ahead and we have only two labels in total, we just take the remaining distance to
                  // on the whole axis length. We limit that to a minimum of 30 pixel, so that labels close to the border will
                  // still be visible inside of the chart padding.
                  labelLength = Math.max(this.axisLength - projectedValue, this.axisLength / this.ticks.length);
              }
              // Skip grid lines and labels where interpolated label values are falsey (except for 0)
              if (labelValue !== "" && isFalseyButZero(labelValue)) {
                  return;
              }
              // Transform to global coordinates using the chartRect
              // We also need to set the label offset for the createLabel function
              if (this.units.pos === "x") {
                  projectedValue = this.chartRect.x1 + projectedValue;
                  labelOffset.x = chartOptions.axisX.labelOffset.x;
                  // If the labels should be positioned in start position (top side for vertical axis) we need to set a
                  // different offset as for positioned with end (bottom)
                  if (chartOptions.axisX.position === "start") {
                      labelOffset.y = this.chartRect.padding.top + chartOptions.axisX.labelOffset.y + 5;
                  } else {
                      labelOffset.y = this.chartRect.y1 + chartOptions.axisX.labelOffset.y + 5;
                  }
              } else {
                  projectedValue = this.chartRect.y1 - projectedValue;
                  labelOffset.y = chartOptions.axisY.labelOffset.y - labelLength;
                  // If the labels should be positioned in start position (left side for horizontal axis) we need to set a
                  // different offset as for positioned with end (right side)
                  if (chartOptions.axisY.position === "start") {
                      labelOffset.x = this.chartRect.padding.left + chartOptions.axisY.labelOffset.x;
                  } else {
                      labelOffset.x = this.chartRect.x2 + chartOptions.axisY.labelOffset.x + 10;
                  }
              }
              if (axisOptions.showGrid) {
                  createGrid(projectedValue, index, this, this.gridOffset, this.chartRect[this.counterUnits.len](), gridGroup, [
                      chartOptions.classNames.grid,
                      chartOptions.classNames[this.units.dir]
                  ], eventEmitter);
              }
              if (axisOptions.showLabel) {
                  createLabel(projectedValue, labelLength, index, labelValue, this, axisOptions.offset, labelOffset, labelGroup, [
                      chartOptions.classNames.label,
                      chartOptions.classNames[this.units.dir],
                      axisOptions.position === "start" ? chartOptions.classNames[axisOptions.position] : chartOptions.classNames.end
                  ], eventEmitter);
              }
          });
      }
      constructor(units, chartRect, ticks){
          this.units = units;
          this.chartRect = chartRect;
          this.ticks = ticks;
          this.counterUnits = units === axisUnits.x ? axisUnits.y : axisUnits.x;
          this.axisLength = chartRect[this.units.rectEnd] - chartRect[this.units.rectStart];
          this.gridOffset = chartRect[this.units.rectOffset];
      }
  }

  class AutoScaleAxis extends Axis {
      projectValue(value) {
          const finalValue = Number(getMultiValue(value, this.units.pos));
          return this.axisLength * (finalValue - this.bounds.min) / this.bounds.range;
      }
      constructor(axisUnit, data, chartRect, options){
          // Usually we calculate highLow based on the data but this can be overriden by a highLow object in the options
          const highLow = options.highLow || getHighLow(data, options, axisUnit.pos);
          const bounds = getBounds(chartRect[axisUnit.rectEnd] - chartRect[axisUnit.rectStart], highLow, options.scaleMinSpace || 20, options.onlyInteger);
          const range = {
              min: bounds.min,
              max: bounds.max
          };
          super(axisUnit, chartRect, bounds.values);
          this.bounds = bounds;
          this.range = range;
      }
  }

  class StepAxis extends Axis {
      projectValue(_value, index) {
          return this.stepLength * index;
      }
      constructor(axisUnit, _data, chartRect, options){
          const ticks = options.ticks || [];
          super(axisUnit, chartRect, ticks);
          const calc = Math.max(1, ticks.length - (options.stretch ? 1 : 0));
          this.stepLength = this.axisLength / calc;
          this.stretch = Boolean(options.stretch);
      }
  }

  function getSeriesOption(series, options, key) {
      var ref;
      if (safeHasProperty(series, "name") && series.name && ((ref = options.series) === null || ref === void 0 ? void 0 : ref[series.name])) {
          const seriesOptions = options === null || options === void 0 ? void 0 : options.series[series.name];
          const value = seriesOptions[key];
          const result = value === undefined ? options[key] : value;
          return result;
      } else {
          return options[key];
      }
  }
  /**
   * Default options in line charts. Expand the code view to see a detailed list of options with comments.
   */ const defaultOptions$2 = {
      // Options for X-Axis
      axisX: {
          // The offset of the labels to the chart area
          offset: 30,
          // Position where labels are placed. Can be set to `start` or `end` where `start` is equivalent to left or top on vertical axis and `end` is equivalent to right or bottom on horizontal axis.
          position: "end",
          // Allows you to correct label positioning on this axis by positive or negative x and y offset.
          labelOffset: {
              x: 0,
              y: 0
          },
          // If labels should be shown or not
          showLabel: true,
          // If the axis grid should be drawn or not
          showGrid: true,
          // Interpolation function that allows you to intercept the value from the axis label
          labelInterpolationFnc: noop,
          // Set the axis type to be used to project values on this axis. If not defined, Chartist.StepAxis will be used for the X-Axis, where the ticks option will be set to the labels in the data and the stretch option will be set to the global fullWidth option. This type can be changed to any axis constructor available (e.g. Chartist.FixedScaleAxis), where all axis options should be present here.
          type: undefined
      },
      // Options for Y-Axis
      axisY: {
          // The offset of the labels to the chart area
          offset: 40,
          // Position where labels are placed. Can be set to `start` or `end` where `start` is equivalent to left or top on vertical axis and `end` is equivalent to right or bottom on horizontal axis.
          position: "start",
          // Allows you to correct label positioning on this axis by positive or negative x and y offset.
          labelOffset: {
              x: 0,
              y: 0
          },
          // If labels should be shown or not
          showLabel: true,
          // If the axis grid should be drawn or not
          showGrid: true,
          // Interpolation function that allows you to intercept the value from the axis label
          labelInterpolationFnc: noop,
          // Set the axis type to be used to project values on this axis. If not defined, Chartist.AutoScaleAxis will be used for the Y-Axis, where the high and low options will be set to the global high and low options. This type can be changed to any axis constructor available (e.g. Chartist.FixedScaleAxis), where all axis options should be present here.
          type: undefined,
          // This value specifies the minimum height in pixel of the scale steps
          scaleMinSpace: 20,
          // Use only integer values (whole numbers) for the scale steps
          onlyInteger: false
      },
      // Specify a fixed width for the chart as a string (i.e. '100px' or '50%')
      width: undefined,
      // Specify a fixed height for the chart as a string (i.e. '100px' or '50%')
      height: undefined,
      // If the line should be drawn or not
      showLine: true,
      // If dots should be drawn or not
      showPoint: true,
      // If the line chart should draw an area
      showArea: false,
      // The base for the area chart that will be used to close the area shape (is normally 0)
      areaBase: 0,
      // Specify if the lines should be smoothed. This value can be true or false where true will result in smoothing using the default smoothing interpolation function Chartist.Interpolation.cardinal and false results in Chartist.Interpolation.none. You can also choose other smoothing / interpolation functions available in the Chartist.Interpolation module, or write your own interpolation function. Check the examples for a brief description.
      lineSmooth: true,
      // If the line chart should add a background fill to the .ct-grids group.
      showGridBackground: false,
      // Overriding the natural low of the chart allows you to zoom in or limit the charts lowest displayed value
      low: undefined,
      // Overriding the natural high of the chart allows you to zoom in or limit the charts highest displayed value
      high: undefined,
      // Padding of the chart drawing area to the container element and labels as a number or padding object {top: 5, right: 5, bottom: 5, left: 5}
      chartPadding: {
          top: 15,
          right: 15,
          bottom: 5,
          left: 10
      },
      // When set to true, the last grid line on the x-axis is not drawn and the chart elements will expand to the full available width of the chart. For the last label to be drawn correctly you might need to add chart padding or offset the last label with a draw event handler.
      fullWidth: false,
      // If true the whole data is reversed including labels, the series order as well as the whole series data arrays.
      reverseData: false,
      // Override the class names that get used to generate the SVG structure of the chart
      classNames: {
          chart: "ct-chart-line",
          label: "ct-label",
          labelGroup: "ct-labels",
          series: "ct-series",
          line: "ct-line",
          point: "ct-point",
          area: "ct-area",
          grid: "ct-grid",
          gridGroup: "ct-grids",
          gridBackground: "ct-grid-background",
          vertical: "ct-vertical",
          horizontal: "ct-horizontal",
          start: "ct-start",
          end: "ct-end"
      }
  };
  class LineChart extends BaseChart {
      /**
     * Creates a new chart
     */ createChart(options) {
          const { data  } = this;
          const normalizedData = normalizeData(data, options.reverseData, true);
          // Create new svg object
          const svg = createSvg(this.container, options.width, options.height, options.classNames.chart);
          this.svg = svg;
          // Create groups for labels, grid and series
          const gridGroup = svg.elem("g").addClass(options.classNames.gridGroup);
          const seriesGroup = svg.elem("g");
          const labelGroup = svg.elem("g").addClass(options.classNames.labelGroup);
          const chartRect = createChartRect(svg, options);
          let axisX;
          let axisY;
          if (options.axisX.type === undefined) {
              axisX = new StepAxis(axisUnits.x, normalizedData.series, chartRect, {
                  ...options.axisX,
                  ticks: normalizedData.labels,
                  stretch: options.fullWidth
              });
          } else {
              // eslint-disable-next-line new-cap
              axisX = new options.axisX.type(axisUnits.x, normalizedData.series, chartRect, options.axisX);
          }
          if (options.axisY.type === undefined) {
              axisY = new AutoScaleAxis(axisUnits.y, normalizedData.series, chartRect, {
                  ...options.axisY,
                  high: isNumeric(options.high) ? options.high : options.axisY.high,
                  low: isNumeric(options.low) ? options.low : options.axisY.low
              });
          } else {
              // eslint-disable-next-line new-cap
              axisY = new options.axisY.type(axisUnits.y, normalizedData.series, chartRect, options.axisY);
          }
          axisX.createGridAndLabels(gridGroup, labelGroup, options, this.eventEmitter);
          axisY.createGridAndLabels(gridGroup, labelGroup, options, this.eventEmitter);
          if (options.showGridBackground) {
              createGridBackground(gridGroup, chartRect, options.classNames.gridBackground, this.eventEmitter);
          }
          // Draw the series
          each(data.series, (series, seriesIndex)=>{
              const seriesElement = seriesGroup.elem("g");
              const seriesName = safeHasProperty(series, "name") && series.name;
              const seriesClassName = safeHasProperty(series, "className") && series.className;
              const seriesMeta = safeHasProperty(series, "meta") ? series.meta : undefined;
              // Write attributes to series group element. If series name or meta is undefined the attributes will not be written
              if (seriesName) {
                  seriesElement.attr({
                      "ct:series-name": seriesName
                  });
              }
              if (seriesMeta) {
                  seriesElement.attr({
                      "ct:meta": serialize(seriesMeta)
                  });
              }
              // Use series class from series data or if not set generate one
              seriesElement.addClass([
                  options.classNames.series,
                  seriesClassName || "".concat(options.classNames.series, "-").concat(alphaNumerate(seriesIndex))
              ].join(" "));
              const pathCoordinates = [];
              const pathData = [];
              normalizedData.series[seriesIndex].forEach((value, valueIndex)=>{
                  const p = {
                      x: chartRect.x1 + axisX.projectValue(value, valueIndex, normalizedData.series[seriesIndex]),
                      y: chartRect.y1 - axisY.projectValue(value, valueIndex, normalizedData.series[seriesIndex])
                  };
                  pathCoordinates.push(p.x, p.y);
                  pathData.push({
                      value,
                      valueIndex,
                      meta: getMetaData(series, valueIndex)
                  });
              });
              const seriesOptions = {
                  lineSmooth: getSeriesOption(series, options, "lineSmooth"),
                  showPoint: getSeriesOption(series, options, "showPoint"),
                  showLine: getSeriesOption(series, options, "showLine"),
                  showArea: getSeriesOption(series, options, "showArea"),
                  areaBase: getSeriesOption(series, options, "areaBase")
              };
              let smoothing;
              if (typeof seriesOptions.lineSmooth === "function") {
                  smoothing = seriesOptions.lineSmooth;
              } else {
                  smoothing = seriesOptions.lineSmooth ? monotoneCubic() : none();
              }
              // Interpolating path where pathData will be used to annotate each path element so we can trace back the original
              // index, value and meta data
              const path = smoothing(pathCoordinates, pathData);
              // If we should show points we need to create them now to avoid secondary loop
              // Points are drawn from the pathElements returned by the interpolation function
              // Small offset for Firefox to render squares correctly
              if (seriesOptions.showPoint) {
                  path.pathElements.forEach((pathElement)=>{
                      const { data: pathElementData  } = pathElement;
                      const point = seriesElement.elem("line", {
                          x1: pathElement.x,
                          y1: pathElement.y,
                          x2: pathElement.x + 0.01,
                          y2: pathElement.y
                      }, options.classNames.point);
                      if (pathElementData) {
                          let x;
                          let y;
                          if (safeHasProperty(pathElementData.value, "x")) {
                              x = pathElementData.value.x;
                          }
                          if (safeHasProperty(pathElementData.value, "y")) {
                              y = pathElementData.value.y;
                          }
                          point.attr({
                              "ct:value": [
                                  x,
                                  y
                              ].filter(isNumeric).join(","),
                              "ct:meta": serialize(pathElementData.meta)
                          });
                      }
                      this.eventEmitter.emit("draw", {
                          type: "point",
                          value: pathElementData === null || pathElementData === void 0 ? void 0 : pathElementData.value,
                          index: (pathElementData === null || pathElementData === void 0 ? void 0 : pathElementData.valueIndex) || 0,
                          meta: pathElementData === null || pathElementData === void 0 ? void 0 : pathElementData.meta,
                          series,
                          seriesIndex,
                          axisX,
                          axisY,
                          group: seriesElement,
                          element: point,
                          x: pathElement.x,
                          y: pathElement.y,
                          chartRect
                      });
                  });
              }
              if (seriesOptions.showLine) {
                  const line = seriesElement.elem("path", {
                      d: path.stringify()
                  }, options.classNames.line, true);
                  this.eventEmitter.emit("draw", {
                      type: "line",
                      values: normalizedData.series[seriesIndex],
                      path: path.clone(),
                      chartRect,
                      // TODO: Remove redundant
                      index: seriesIndex,
                      series,
                      seriesIndex,
                      meta: seriesMeta,
                      axisX,
                      axisY,
                      group: seriesElement,
                      element: line
                  });
              }
              // Area currently only works with axes that support a range!
              if (seriesOptions.showArea && axisY.range) {
                  // If areaBase is outside the chart area (< min or > max) we need to set it respectively so that
                  // the area is not drawn outside the chart area.
                  const areaBase = Math.max(Math.min(seriesOptions.areaBase, axisY.range.max), axisY.range.min);
                  // We project the areaBase value into screen coordinates
                  const areaBaseProjected = chartRect.y1 - axisY.projectValue(areaBase);
                  // In order to form the area we'll first split the path by move commands so we can chunk it up into segments
                  path.splitByCommand("M")// We filter only "solid" segments that contain more than one point. Otherwise there's no need for an area
                  .filter((pathSegment)=>pathSegment.pathElements.length > 1
                  ).map((solidPathSegments)=>{
                      // Receiving the filtered solid path segments we can now convert those segments into fill areas
                      const firstElement = solidPathSegments.pathElements[0];
                      const lastElement = solidPathSegments.pathElements[solidPathSegments.pathElements.length - 1];
                      // Cloning the solid path segment with closing option and removing the first move command from the clone
                      // We then insert a new move that should start at the area base and draw a straight line up or down
                      // at the end of the path we add an additional straight line to the projected area base value
                      // As the closing option is set our path will be automatically closed
                      return solidPathSegments.clone(true).position(0).remove(1).move(firstElement.x, areaBaseProjected).line(firstElement.x, firstElement.y).position(solidPathSegments.pathElements.length + 1).line(lastElement.x, areaBaseProjected);
                  }).forEach((areaPath)=>{
                      // For each of our newly created area paths, we'll now create path elements by stringifying our path objects
                      // and adding the created DOM elements to the correct series group
                      const area = seriesElement.elem("path", {
                          d: areaPath.stringify()
                      }, options.classNames.area, true);
                      // Emit an event for each area that was drawn
                      this.eventEmitter.emit("draw", {
                          type: "area",
                          values: normalizedData.series[seriesIndex],
                          path: areaPath.clone(),
                          series,
                          seriesIndex,
                          axisX,
                          axisY,
                          chartRect,
                          // TODO: Remove redundant
                          index: seriesIndex,
                          group: seriesElement,
                          element: area,
                          meta: seriesMeta
                      });
                  });
              }
          }, options.reverseData);
          this.eventEmitter.emit("created", {
              chartRect,
              axisX,
              axisY,
              svg,
              options
          });
      }
      /**
     * This method creates a new line chart.
     * @param query A selector query string or directly a DOM element
     * @param data The data object that needs to consist of a labels and a series array
     * @param options The options object with options that override the default options. Check the examples for a detailed list.
     * @param responsiveOptions Specify an array of responsive option arrays which are a media query and options object pair => [[mediaQueryString, optionsObject],[more...]]
     * @return An object which exposes the API for the created chart
     *
     * @example
     * ```ts
     * // Create a simple line chart
     * const data = {
     *   // A labels array that can contain any sort of values
     *   labels: ['Mon', 'Tue', 'Wed', 'Thu', 'Fri'],
     *   // Our series array that contains series objects or in this case series data arrays
     *   series: [
     *     [5, 2, 4, 2, 0]
     *   ]
     * };
     *
     * // As options we currently only set a static size of 300x200 px
     * const options = {
     *   width: '300px',
     *   height: '200px'
     * };
     *
     * // In the global name space Chartist we call the Line function to initialize a line chart. As a first parameter we pass in a selector where we would like to get our chart created. Second parameter is the actual data object and as a third parameter we pass in our options
     * new LineChart('.ct-chart', data, options);
     * ```
     *
     * @example
     * ```ts
     * // Use specific interpolation function with configuration from the Chartist.Interpolation module
     *
     * const chart = new LineChart('.ct-chart', {
     *   labels: [1, 2, 3, 4, 5],
     *   series: [
     *     [1, 1, 8, 1, 7]
     *   ]
     * }, {
     *   lineSmooth: Chartist.Interpolation.cardinal({
     *     tension: 0.2
     *   })
     * });
     * ```
     *
     * @example
     * ```ts
     * // Create a line chart with responsive options
     *
     * const data = {
     *   // A labels array that can contain any sort of values
     *   labels: ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday'],
     *   // Our series array that contains series objects or in this case series data arrays
     *   series: [
     *     [5, 2, 4, 2, 0]
     *   ]
     * };
     *
     * // In addition to the regular options we specify responsive option overrides that will override the default configutation based on the matching media queries.
     * const responsiveOptions = [
     *   ['screen and (min-width: 641px) and (max-width: 1024px)', {
     *     showPoint: false,
     *     axisX: {
     *       labelInterpolationFnc: function(value) {
     *         // Will return Mon, Tue, Wed etc. on medium screens
     *         return value.slice(0, 3);
     *       }
     *     }
     *   }],
     *   ['screen and (max-width: 640px)', {
     *     showLine: false,
     *     axisX: {
     *       labelInterpolationFnc: function(value) {
     *         // Will return M, T, W etc. on small screens
     *         return value[0];
     *       }
     *     }
     *   }]
     * ];
     *
     * new LineChart('.ct-chart', data, null, responsiveOptions);
     * ```
     */ constructor(query, data, options, responsiveOptions){
          super(query, data, defaultOptions$2, extend({}, defaultOptions$2, options), responsiveOptions);
          this.data = data;
      }
  }

  function getSerialSums(series) {
      return serialMap(series, function() {
          for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
              args[_key] = arguments[_key];
          }
          return Array.from(args).reduce((prev, curr)=>{
              return {
                  x: prev.x + (safeHasProperty(curr, "x") ? curr.x : 0),
                  y: prev.y + (safeHasProperty(curr, "y") ? curr.y : 0)
              };
          }, {
              x: 0,
              y: 0
          });
      });
  }
  /**
   * Default options in bar charts. Expand the code view to see a detailed list of options with comments.
   */ const defaultOptions$1 = {
      // Options for X-Axis
      axisX: {
          // The offset of the chart drawing area to the border of the container
          offset: 30,
          // Position where labels are placed. Can be set to `start` or `end` where `start` is equivalent to left or top on vertical axis and `end` is equivalent to right or bottom on horizontal axis.
          position: "end",
          // Allows you to correct label positioning on this axis by positive or negative x and y offset.
          labelOffset: {
              x: 0,
              y: 0
          },
          // If labels should be shown or not
          showLabel: true,
          // If the axis grid should be drawn or not
          showGrid: true,
          // Interpolation function that allows you to intercept the value from the axis label
          labelInterpolationFnc: noop,
          // This value specifies the minimum width in pixel of the scale steps
          scaleMinSpace: 30,
          // Use only integer values (whole numbers) for the scale steps
          onlyInteger: false
      },
      // Options for Y-Axis
      axisY: {
          // The offset of the chart drawing area to the border of the container
          offset: 40,
          // Position where labels are placed. Can be set to `start` or `end` where `start` is equivalent to left or top on vertical axis and `end` is equivalent to right or bottom on horizontal axis.
          position: "start",
          // Allows you to correct label positioning on this axis by positive or negative x and y offset.
          labelOffset: {
              x: 0,
              y: 0
          },
          // If labels should be shown or not
          showLabel: true,
          // If the axis grid should be drawn or not
          showGrid: true,
          // Interpolation function that allows you to intercept the value from the axis label
          labelInterpolationFnc: noop,
          // This value specifies the minimum height in pixel of the scale steps
          scaleMinSpace: 20,
          // Use only integer values (whole numbers) for the scale steps
          onlyInteger: false
      },
      // Specify a fixed width for the chart as a string (i.e. '100px' or '50%')
      width: undefined,
      // Specify a fixed height for the chart as a string (i.e. '100px' or '50%')
      height: undefined,
      // Overriding the natural high of the chart allows you to zoom in or limit the charts highest displayed value
      high: undefined,
      // Overriding the natural low of the chart allows you to zoom in or limit the charts lowest displayed value
      low: undefined,
      // Unless low/high are explicitly set, bar chart will be centered at zero by default. Set referenceValue to null to auto scale.
      referenceValue: 0,
      // Padding of the chart drawing area to the container element and labels as a number or padding object {top: 5, right: 5, bottom: 5, left: 5}
      chartPadding: {
          top: 15,
          right: 15,
          bottom: 5,
          left: 10
      },
      // Specify the distance in pixel of bars in a group
      seriesBarDistance: 15,
      // If set to true this property will cause the series bars to be stacked. Check the `stackMode` option for further stacking options.
      stackBars: false,
      // If set to true this property will force the stacked bars to draw from the zero line.
      // If set to 'accumulate' this property will form a total for each series point. This will also influence the y-axis and the overall bounds of the chart. In stacked mode the seriesBarDistance property will have no effect.
      // If set to 'accumulate-relative' positive and negative values will be handled separately.
      stackMode: "accumulate",
      // Inverts the axes of the bar chart in order to draw a horizontal bar chart. Be aware that you also need to invert your axis settings as the Y Axis will now display the labels and the X Axis the values.
      horizontalBars: false,
      // If set to true then each bar will represent a series and the data array is expected to be a one dimensional array of data values rather than a series array of series. This is useful if the bar chart should represent a profile rather than some data over time.
      distributeSeries: false,
      // If true the whole data is reversed including labels, the series order as well as the whole series data arrays.
      reverseData: false,
      // If the bar chart should add a background fill to the .ct-grids group.
      showGridBackground: false,
      // Override the class names that get used to generate the SVG structure of the chart
      classNames: {
          chart: "ct-chart-bar",
          horizontalBars: "ct-horizontal-bars",
          label: "ct-label",
          labelGroup: "ct-labels",
          series: "ct-series",
          bar: "ct-bar",
          grid: "ct-grid",
          gridGroup: "ct-grids",
          gridBackground: "ct-grid-background",
          vertical: "ct-vertical",
          horizontal: "ct-horizontal",
          start: "ct-start",
          end: "ct-end"
      }
  };
  class BarChart extends BaseChart {
      /**
     * Creates a new chart
     */ createChart(options) {
          const { data  } = this;
          const normalizedData = normalizeData(data, options.reverseData, options.horizontalBars ? "x" : "y", true);
          // Create new svg element
          const svg = createSvg(this.container, options.width, options.height, options.classNames.chart + (options.horizontalBars ? " " + options.classNames.horizontalBars : ""));
          const highLow = options.stackBars && options.stackMode !== true && normalizedData.series.length ? getHighLow([
              getSerialSums(normalizedData.series)
          ], options, options.horizontalBars ? "x" : "y") : getHighLow(normalizedData.series, options, options.horizontalBars ? "x" : "y");
          this.svg = svg;
          // Drawing groups in correct order
          const gridGroup = svg.elem("g").addClass(options.classNames.gridGroup);
          const seriesGroup = svg.elem("g");
          const labelGroup = svg.elem("g").addClass(options.classNames.labelGroup);
          // Overrides of high / low from settings
          if (typeof options.high === "number") {
              highLow.high = options.high;
          }
          if (typeof options.low === "number") {
              highLow.low = options.low;
          }
          const chartRect = createChartRect(svg, options);
          let valueAxis;
          const labelAxisTicks = options.distributeSeries && options.stackBars ? // use only the first label for the step axis
          normalizedData.labels.slice(0, 1) : // If we are drawing a regular bar chart with two dimensional series data, we just use the labels array
          // as the bars are normalized
          normalizedData.labels;
          let labelAxis;
          let axisX;
          let axisY;
          // Set labelAxis and valueAxis based on the horizontalBars setting. This setting will flip the axes if necessary.
          if (options.horizontalBars) {
              if (options.axisX.type === undefined) {
                  valueAxis = axisX = new AutoScaleAxis(axisUnits.x, normalizedData.series, chartRect, {
                      ...options.axisX,
                      highLow: highLow,
                      referenceValue: 0
                  });
              } else {
                  // eslint-disable-next-line new-cap
                  valueAxis = axisX = new options.axisX.type(axisUnits.x, normalizedData.series, chartRect, {
                      ...options.axisX,
                      highLow: highLow,
                      referenceValue: 0
                  });
              }
              if (options.axisY.type === undefined) {
                  labelAxis = axisY = new StepAxis(axisUnits.y, normalizedData.series, chartRect, {
                      ticks: labelAxisTicks
                  });
              } else {
                  // eslint-disable-next-line new-cap
                  labelAxis = axisY = new options.axisY.type(axisUnits.y, normalizedData.series, chartRect, options.axisY);
              }
          } else {
              if (options.axisX.type === undefined) {
                  labelAxis = axisX = new StepAxis(axisUnits.x, normalizedData.series, chartRect, {
                      ticks: labelAxisTicks
                  });
              } else {
                  // eslint-disable-next-line new-cap
                  labelAxis = axisX = new options.axisX.type(axisUnits.x, normalizedData.series, chartRect, options.axisX);
              }
              if (options.axisY.type === undefined) {
                  valueAxis = axisY = new AutoScaleAxis(axisUnits.y, normalizedData.series, chartRect, {
                      ...options.axisY,
                      highLow: highLow,
                      referenceValue: 0
                  });
              } else {
                  // eslint-disable-next-line new-cap
                  valueAxis = axisY = new options.axisY.type(axisUnits.y, normalizedData.series, chartRect, {
                      ...options.axisY,
                      highLow: highLow,
                      referenceValue: 0
                  });
              }
          }
          // Projected 0 point
          const zeroPoint = options.horizontalBars ? chartRect.x1 + valueAxis.projectValue(0) : chartRect.y1 - valueAxis.projectValue(0);
          const isAccumulateStackMode = options.stackMode === "accumulate";
          const isAccumulateRelativeStackMode = options.stackMode === "accumulate-relative";
          // Used to track the screen coordinates of stacked bars
          const posStackedBarValues = [];
          const negStackedBarValues = [];
          let stackedBarValues = posStackedBarValues;
          labelAxis.createGridAndLabels(gridGroup, labelGroup, options, this.eventEmitter);
          valueAxis.createGridAndLabels(gridGroup, labelGroup, options, this.eventEmitter);
          if (options.showGridBackground) {
              createGridBackground(gridGroup, chartRect, options.classNames.gridBackground, this.eventEmitter);
          }
          // Draw the series
          each(data.series, (series, seriesIndex)=>{
              // Calculating bi-polar value of index for seriesOffset. For i = 0..4 biPol will be -1.5, -0.5, 0.5, 1.5 etc.
              const biPol = seriesIndex - (data.series.length - 1) / 2;
              // Half of the period width between vertical grid lines used to position bars
              let periodHalfLength;
              // We need to set periodHalfLength based on some options combinations
              if (options.distributeSeries && !options.stackBars) {
                  // If distributed series are enabled but stacked bars aren't, we need to use the length of the normaizedData array
                  // which is the series count and divide by 2
                  periodHalfLength = labelAxis.axisLength / normalizedData.series.length / 2;
              } else if (options.distributeSeries && options.stackBars) {
                  // If distributed series and stacked bars are enabled we'll only get one bar so we should just divide the axis
                  // length by 2
                  periodHalfLength = labelAxis.axisLength / 2;
              } else {
                  // On regular bar charts we should just use the series length
                  periodHalfLength = labelAxis.axisLength / normalizedData.series[seriesIndex].length / 2;
              }
              // Adding the series group to the series element
              const seriesElement = seriesGroup.elem("g");
              const seriesName = safeHasProperty(series, "name") && series.name;
              const seriesClassName = safeHasProperty(series, "className") && series.className;
              const seriesMeta = safeHasProperty(series, "meta") ? series.meta : undefined;
              // Write attributes to series group element. If series name or meta is undefined the attributes will not be written
              if (seriesName) {
                  seriesElement.attr({
                      "ct:series-name": seriesName
                  });
              }
              if (seriesMeta) {
                  seriesElement.attr({
                      "ct:meta": serialize(seriesMeta)
                  });
              }
              // Use series class from series data or if not set generate one
              seriesElement.addClass([
                  options.classNames.series,
                  seriesClassName || "".concat(options.classNames.series, "-").concat(alphaNumerate(seriesIndex))
              ].join(" "));
              normalizedData.series[seriesIndex].forEach((value, valueIndex)=>{
                  const valueX = safeHasProperty(value, "x") && value.x;
                  const valueY = safeHasProperty(value, "y") && value.y;
                  let labelAxisValueIndex;
                  // We need to set labelAxisValueIndex based on some options combinations
                  if (options.distributeSeries && !options.stackBars) {
                      // If distributed series are enabled but stacked bars aren't, we can use the seriesIndex for later projection
                      // on the step axis for label positioning
                      labelAxisValueIndex = seriesIndex;
                  } else if (options.distributeSeries && options.stackBars) {
                      // If distributed series and stacked bars are enabled, we will only get one bar and therefore always use
                      // 0 for projection on the label step axis
                      labelAxisValueIndex = 0;
                  } else {
                      // On regular bar charts we just use the value index to project on the label step axis
                      labelAxisValueIndex = valueIndex;
                  }
                  let projected;
                  // We need to transform coordinates differently based on the chart layout
                  if (options.horizontalBars) {
                      projected = {
                          x: chartRect.x1 + valueAxis.projectValue(valueX || 0, valueIndex, normalizedData.series[seriesIndex]),
                          y: chartRect.y1 - labelAxis.projectValue(valueY || 0, labelAxisValueIndex, normalizedData.series[seriesIndex])
                      };
                  } else {
                      projected = {
                          x: chartRect.x1 + labelAxis.projectValue(valueX || 0, labelAxisValueIndex, normalizedData.series[seriesIndex]),
                          y: chartRect.y1 - valueAxis.projectValue(valueY || 0, valueIndex, normalizedData.series[seriesIndex])
                      };
                  }
                  // If the label axis is a step based axis we will offset the bar into the middle of between two steps using
                  // the periodHalfLength value. Also we do arrange the different series so that they align up to each other using
                  // the seriesBarDistance. If we don't have a step axis, the bar positions can be chosen freely so we should not
                  // add any automated positioning.
                  if (labelAxis instanceof StepAxis) {
                      // Offset to center bar between grid lines, but only if the step axis is not stretched
                      if (!labelAxis.stretch) {
                          projected[labelAxis.units.pos] += periodHalfLength * (options.horizontalBars ? -1 : 1);
                      }
                      // Using bi-polar offset for multiple series if no stacked bars or series distribution is used
                      projected[labelAxis.units.pos] += options.stackBars || options.distributeSeries ? 0 : biPol * options.seriesBarDistance * (options.horizontalBars ? -1 : 1);
                  }
                  // distinguish between positive and negative values in relative stack mode
                  if (isAccumulateRelativeStackMode) {
                      stackedBarValues = valueY >= 0 || valueX >= 0 ? posStackedBarValues : negStackedBarValues;
                  }
                  // Enter value in stacked bar values used to remember previous screen value for stacking up bars
                  const previousStack = stackedBarValues[valueIndex] || zeroPoint;
                  stackedBarValues[valueIndex] = previousStack - (zeroPoint - projected[labelAxis.counterUnits.pos]);
                  // Skip if value is undefined
                  if (value === undefined) {
                      return;
                  }
                  const positions = {
                      ["".concat(labelAxis.units.pos, "1")]: projected[labelAxis.units.pos],
                      ["".concat(labelAxis.units.pos, "2")]: projected[labelAxis.units.pos]
                  };
                  if (options.stackBars && (isAccumulateStackMode || isAccumulateRelativeStackMode || !options.stackMode)) {
                      // Stack mode: accumulate (default)
                      // If bars are stacked we use the stackedBarValues reference and otherwise base all bars off the zero line
                      // We want backwards compatibility, so the expected fallback without the 'stackMode' option
                      // to be the original behaviour (accumulate)
                      positions["".concat(labelAxis.counterUnits.pos, "1")] = previousStack;
                      positions["".concat(labelAxis.counterUnits.pos, "2")] = stackedBarValues[valueIndex];
                  } else {
                      // Draw from the zero line normally
                      // This is also the same code for Stack mode: overlap
                      positions["".concat(labelAxis.counterUnits.pos, "1")] = zeroPoint;
                      positions["".concat(labelAxis.counterUnits.pos, "2")] = projected[labelAxis.counterUnits.pos];
                  }
                  // Limit x and y so that they are within the chart rect
                  positions.x1 = Math.min(Math.max(positions.x1, chartRect.x1), chartRect.x2);
                  positions.x2 = Math.min(Math.max(positions.x2, chartRect.x1), chartRect.x2);
                  positions.y1 = Math.min(Math.max(positions.y1, chartRect.y2), chartRect.y1);
                  positions.y2 = Math.min(Math.max(positions.y2, chartRect.y2), chartRect.y1);
                  const metaData = getMetaData(series, valueIndex);
                  // Create bar element
                  const bar = seriesElement.elem("line", positions, options.classNames.bar).attr({
                      "ct:value": [
                          valueX,
                          valueY
                      ].filter(isNumeric).join(","),
                      "ct:meta": serialize(metaData)
                  });
                  this.eventEmitter.emit("draw", {
                      type: "bar",
                      value,
                      index: valueIndex,
                      meta: metaData,
                      series,
                      seriesIndex,
                      axisX,
                      axisY,
                      chartRect,
                      group: seriesElement,
                      element: bar,
                      ...positions
                  });
              });
          }, options.reverseData);
          this.eventEmitter.emit("created", {
              chartRect,
              axisX,
              axisY,
              svg,
              options
          });
      }
      /**
     * This method creates a new bar chart and returns API object that you can use for later changes.
     * @param query A selector query string or directly a DOM element
     * @param data The data object that needs to consist of a labels and a series array
     * @param options The options object with options that override the default options. Check the examples for a detailed list.
     * @param responsiveOptions Specify an array of responsive option arrays which are a media query and options object pair => [[mediaQueryString, optionsObject],[more...]]
     * @return An object which exposes the API for the created chart
     *
     * @example
     * ```ts
     * // Create a simple bar chart
     * const data = {
     *   labels: ['Mon', 'Tue', 'Wed', 'Thu', 'Fri'],
     *   series: [
     *     [5, 2, 4, 2, 0]
     *   ]
     * };
     *
     * // In the global name space Chartist we call the Bar function to initialize a bar chart. As a first parameter we pass in a selector where we would like to get our chart created and as a second parameter we pass our data object.
     * new BarChart('.ct-chart', data);
     * ```
     *
     * @example
     * ```ts
     * // This example creates a bipolar grouped bar chart where the boundaries are limitted to -10 and 10
     * new BarChart('.ct-chart', {
     *   labels: [1, 2, 3, 4, 5, 6, 7],
     *   series: [
     *     [1, 3, 2, -5, -3, 1, -6],
     *     [-5, -2, -4, -1, 2, -3, 1]
     *   ]
     * }, {
     *   seriesBarDistance: 12,
     *   low: -10,
     *   high: 10
     * });
     * ```
     */ constructor(query, data, options, responsiveOptions){
          super(query, data, defaultOptions$1, extend({}, defaultOptions$1, options), responsiveOptions);
          this.data = data;
      }
  }

  function debounce (fn, delay) {
    let timeout;
    return function (...args) {
      clearTimeout(timeout);
      setTimeout(() => fn(...args), delay);
    }
  }

  /*

  Numbers in Active Markdown are ordinary `Number` values for the most part, but also MAY include various constants from `Math` as a multiplier. For example, `2pi` is equivalent to `2 * Math.PI`, while `0.5e` is equivalent to `0.5 * Math.E`. The constants may be specified without a digit, eg `pi` or `ln2`. Also, they may be specified in lowercase or uppercase, or some combination of the two, if you're into that.
  */
  function parseNumber (val) {
    const constants = ['E', 'PI', 'LN2', 'LN10', 'LOG2E', 'LOG10E', 'SQRT1_2', 'SQRT2'];
    let parsed_val = null;

    // Check the value for each constant, allowing for just a constant
    // with no coefficient.
    for (const c of constants) {
      const r = RegExp(`([+-]?)([\\d\\.]*)${ c }`);
      const group = val.toUpperCase().match(r);

      // If the number matches a constant, generate the equivalent
      // expression and calculate the actual value of the number.
      if (group) {
        const sign = group[1] === '-' ? -1 : 1;
        const mult = group[2] ? (new Number(group[2])) : 1;
        parsed_val = sign * mult * Math[c];
        break
      }

    }

    // If the value is still null, the number didn't have any constants, so
    // just parse it as a regular Number.
    if (parsed_val == null) {
      parsed_val = parseFloat(val);
    }

    return parsed_val
  }

  // The step of a range defaults to 1, but can be specified using the `by` keyword after the min/max. The step is an Active Markdown Number, and can include the constants described above.
  //
  // A range described with `0..10` will have a step of `1`, while `0..10 by 0.1` will have a step of `0.1`, and `0..10 by pi` will have a step of `Math.PI`.
  function parseStep (val) {
    if (val) {
      const as_str = val.replace(' by ','');
      const as_number = parseNumber(as_str);
      // if (Number.isNaN(as_number)) {
      //   return as_str;
      // }
      return as_number;
    }
    return 1;
  }

  // Ranges in Active Markdown work the same as in CoffeeScript; two dots describes an inclusive range, while three dots excludes the tail. (The check here is only if there are two dots or not since the element configuration parsing regex limits the match to `'..'` or `'...'`.)
  function parseInclusivity (dots) {
    return dots.length === 2;
  }

  class Variable {

    static getOrCreate (name, initial_value) {
      if (doc_variables[name]) {
        return doc_variables[name];
      }
      return new Variable(name, initial_value);
    }

    constructor (name, initial_value=undefined, options={}) {
      this.is_dataset = options.is_dataset || false;
      this._element_callbacks = [];
      this._code_block_callbacks = [];
      this._name = name;
      this._value = initial_value;

      if (doc_variables[name]) {
        throw new Error(`Variable name repeated: ${ name }`);
      }

      doc_variables[name] = this;
    }
    onChange (callback, is_code_block=false) {
      if (is_code_block) {
        this._code_block_callbacks.push(callback);
      } else {
        this._element_callbacks.push(callback);
      }
    }
    getName () {
      return this._name;
    }
    getValue () {
      return this._value;
    }
    setValue (value, trigger_elements_only=false) {
      this._value = value;
      this._triggerOnChange(trigger_elements_only);
    }

    _triggerOnChange (trigger_elements_only=false) {
      this._element_callbacks.forEach((callback) => {
        callback(this._value, this._name);
      });
      if (!trigger_elements_only) {
        this._code_block_callbacks.forEach((callback) => {
          callback(this._value, this._name);
        });
      }
    }
  }

  class ChartEmbed {
    static config_pattern = new RegExp(`
    ^
      (                      # Chart
        [line|scatter|bar]+   # - type
      )

        =

      (                      # Variable
        [\\w\\d]+               # - name
      )

        :\\s                   # Delimiter

      (                       # Range min, if any:
        (?:
        [+|-]?                        # - sign, if any
        (?:[\\d]*[\\.]?[\\d]+)?          # - coefficient, if any
        [102EGILONQPSRT_egilonqpsrt]* # - constant, if any
        ) # TODO: | (?:[a-z0-9_]+)? # Variable-driven
      )

      (                       # Inclusivity
        [\\.]{2,3}             # - dots
      )

      (                       # Range max, if any:
        (?:
        [+|-]?                        # - sign, if any
        (?:[\\d]*[\\.]?[\\d]+)?          # - coefficient, if any
        [102EGILONQPSRT_egilonqpsrt]* # - constant, if any
        ) # TODO: | (?:[a-z0-9_]+)? # Variable-driven
      )

      (                       # Step, if any:
        \\sby\\s                # - by keyword

          (?:(?:                 # - step value
            [+|-]?                        # - sign, if any
            (?:[\\d]*[\\.]?[\\d]+)?          # - coefficient, if any
            [102EGILONQPSRT_egilonqpsrt]* # - constant, if any
          ) # TODO: | (?:[a-z0-9_]+)? # Variable-driven
          )

      )*$
  `.replace(/#.*\n/g,'').replace(/\s+/g,''));

    static _parseConfig (config_text) {
      const config_match = config_text.match(this.config_pattern);
      if (!config_match) { return null; }
      /*
      [
          "calories: 10..100 by 10",
          "calories",
          "10",
          "..",
          "100",
          " by 10",
          index: 0,
          input: "calories: 10..100 by 10"
      ]
      */

      const [_text, type, var_name, min_str, dots, max_str, step_str] = config_match;

      let min;
      if (min_str) {
        min = parseNumber(min_str);
        // if (Number.isNaN(min)) {
        //   min = min_str;
        // }
      } else {
        min = null;
      }

      let max;
      if (max_str) {
        max = parseNumber(max_str);
        // if (Number.isNaN(max)) {
        //   max = max_str;
        // }
      } else {
        max = null;
      }

      let val;
      if (min && max) {
        // TODO: align this to the step
        val = (max - min) / 2;
      } else {
        val = 0;
      }

      const step = parseStep(step_str);

      return {
        name        : var_name,
        min         : min,
        max         : max,
        inclusive   : parseInclusivity(dots),
        step        : step,
        value       : val,
        type        : type,
      }
    }

    /*
    # TODO: This could be cleaned up across elements, particularly so it's
    # more testable.
    ###
    Private: parse the text content of the element for axes labels.

    text_content - the String text version of the element

    Returns an Object with the x and y labels.
    */
    static _parseTextContent (parsed_config, text_content) {
      const label_config = {
        y_label: null,
        x_label: null,
      };
      const pattern = /([ \-_\w\d,]+\s)(vs|over|per|by)(\s[ \-_\w\d]+)/;
      const matched = text_content.match(pattern)?.slice(1,4);
      label_config.y_label = matched?.[0].trim().split(',') || null;
      label_config.x_label = matched?.[2].trim() || null;
      return label_config;
    }


    constructor (el) {
      this.el = el;
      const parsed_config = ChartEmbed._parseConfig(el.dataset.config);
      const parsed_text = ChartEmbed._parseTextContent(parsed_config, el.textContent);
      this._x_label = parsed_text.x_label || '';
      this._y_label = parsed_text.y_label;
      this._config = parsed_config;

      const boundRender = () => window.requestAnimationFrame(this._renderUpdate.bind(this));

      window.addEventListener('resize', debounce(boundRender, 250));
      window.requestAnimationFrame(this._renderInitial.bind(this));

      this.variable = Variable.getOrCreate(parsed_config.name);
      this.variable.onChange(boundRender);

      // TODO: support variable driven ranges
      // this._min_var = null;
      // if (typeof this._config.min === "string") {
      //   this._min_var = Variable.getOrCreate(this._config.min);
      //   this._min_var.onChange(boundRender);
      // }
      // this._max_var = null;
      // if (typeof this._config.max === "string") {
      //   this._max_var = Variable.getOrCreate(this._config.max);
      //   this._max_var.onChange(boundRender);
      // }
      // this._step_var = null;
      // if (typeof this._config.step === "string") {
      //   this._step_var = Variable.getOrCreate(this._config.step);
      //   this._step_var.onChange(boundRender);
      // }
      registerEmbed(this);
    }

    _renderInitial () {
      this.el.classList.add('ChartEmbed');
      this.el.innerHTML = '';
      this.els = {};
      this.els.canvas = document.createElement('div');
      this.els.canvas.classList.add('_Canvas');
      this.el.appendChild(this.els.canvas);
      this.els.config = document.createElement('div');
      this.els.config.classList.add('_Config');
      this.el.appendChild(this.els.config);
      this.els.config.textContent = this.el.dataset.config;
      switch (this._config.type) {
        case "line":
        case "scatter": {
          this._chart = new LineChart(this.els.canvas);
          break;
        }
        case "bar": {
          this._chart = new BarChart(this.els.canvas);
          break;
        }
      }
      this._renderUpdate();
    }

    _renderUpdate () {
      if (!this._chart) { return; }
      const value = this.variable.getValue();
      if (!value) { return; }

      const points = [];
      const x_name = this._x_label || 'x';
      const y_names = this._y_label || ['y'];

      if (typeof value === "function") {
        let step = 1;
        if (this._step_var) {
          step = this._step_var.getValue();
        } else if (this._config.step != null) {
          step = this._config.step;
        }

        let min_x = 0;
        if (this._min_var) {
          min_x = this._min_var.getValue();
        } else if (this._config.min != null) {
          min_x = this._config.min;
        }

        let max_x = 100;
        if (this._max_var) {
          max_x = this._max_var.getValue();
        } else if (this._config.max != null) {
          max_x = this._config.max;
        }
        if (!this._config.inclusive) {
          max_x -= step;
        }

        for (let _x = min_x; _x <= max_x; _x += step) {
          const result = value(_x);
          if (result == null) { continue; }
          if (typeof result === "object") {
            points.push(result);
          } else {
            points.push({ [x_name]: _x, [y_names[0]]: result });
          }
        }
      } else if (this.variable.is_dataset) {
        points.push(...value.filter(point => {
          let min;
          const _min = this._min_var ? this._min_var.getValue() : this._config.min;
          if (_min != null) {
            min = _min;
          }
          let max;
          const _max = this._max_var ? this._max_var.getValue() : this._config.max;
          if (_max != null) {
            max = _max;
            if (this._config.inclusive) {
              max += this._config.step;
            }
          }
          if (min == null && max == null) {
            return true;
          }
          return (
            (point[x_name] >= min)
            && (point[x_name] < max)
            // TODO filter y by @ rules
          );
        }));
      }
      let data = {};
      const options = {};
      const labels = [];
      const series_by_name = {};
      const seen_labels = new Set();
      points.forEach(point => {
        if (!seen_labels.has(point[x_name])) {
          labels.push(point[x_name]);
          seen_labels.add(point[x_name]);
        }
        y_names.forEach(y_name => {
          if (point[y_name] != null) { // Allow functions to omit certain attributes
            series_by_name[y_name] ??= [];
            series_by_name[y_name].push(point[y_name]);
          }
        });
      });

      if (this._config !== "bar") {
        if (typeof labels[0] === "string") ; else {
          options.axisX = {
            type: AutoScaleAxis,
            onlyInteger: this._config.max && (this._config.max % 1 === 0),
          };
        }
        // TODO: use the @ 2..3 by 3 config to set this
        // axisY: {
        //   type: Chartist.FixedScaleAxis,
        //   ticks: [0, 50, 75, 87.5, 100],
        //   low: 0
        // },
        const series = Object.values(series_by_name);
        if (series.length === 1 && typeof labels[0] === "number") {
          data = {
            labels,
            series: [series[0].map((y,i) => ({ x: labels[i], y }))],
          };
        } else {
          data = {
            labels,
            series,
          };
        }
        options.showPoint = this._config.type === "scatter";
        options.showLine = this._config.type === "line";
      } else {
        data = {
          labels,
          series: Object.values(series_by_name),
        };
      }

      this._chart.update(data, options);
    }

  }

  class BaseElement {
    constructor (el) {
      this.el = el;
      this.el.classList.add("BaseElement");
      this.el.setAttribute("tabindex", 0);
      this._active_ping_timeout = null;
      registerElement(this);
    }
    _pingChanged () {
      clearTimeout(this._active_ping_timeout);
      this.el.dataset.is_active = true;
      this._active_ping_timeout = setTimeout(() => {
        this.el.dataset.is_active = false;
      }, 2000);
    }
  }

  class RangeElement extends BaseElement {
    static config_pattern = new RegExp(`
    ^(                      # Variable
      [\\w\\d]+               # - name
    )

      :\\s                   # Delimiter

    (                       # Range min, if any:
      [+|-]?                        # - sign, if any
      (?:[\\d]*[\\.]?[\\d]+)?          # - coefficient, if any
      [102EGILONQPSRT_egilonqpsrt]* # - constant, if any
    )

    (                       # Inclusivity
      [\\.]{2,3}             # - dots
    )

    (                       # Range max, if any:
      [+|-]?                        # - sign, if any
      (?:[\\d]*[\\.]?[\\d]+)?          # - coefficient, if any
      [102EGILONQPSRT_egilonqpsrt]* # - constant, if any
    )

    (                       # Step, if any:
      \\sby\\s                # - by keyword

        (?:                 # - step value
          [+|-]?                        # - sign, if any
          (?:[\\d]*[\\.]?[\\d]+)?          # - coefficient, if any
          [102EGILONQPSRT_egilonqpsrt]* # - constant, if any
        )

    )*$
  `.replace(/#.*\n/g,'').replace(/\s+/g,'')
    );

    /*
    [
        "calories: 10..100 by 10",
        "calories",
        "10",
        "..",
        "100",
        " by 10",
        index: 0,
        input: "calories: 10..100 by 10"
    ]
    */
    static _parseConfig (config_text) {
      const config_match = config_text.match(this.config_pattern);
      if (!config_match) { return null; }

      const [text, var_name, min_str, dots, max_str, step_str] = config_match;
      let min;
      let max;
      let initial_value;

      if (min_str) {
        min = parseNumber(min_str);
      } else {
      min = null;
      }

      if (max_str) {
        max = parseNumber(max_str);
      } else {
        max = null;
      }

      if (min && max) {
        initial_value = (max - min) / 2;
      } else {
        initial_value = 0;
      }

      const config = {
        name        : var_name,
        min         : min,
        max         : max,
        inclusive   : parseInclusivity(dots),
        step        : parseStep(step_str),
        value       : initial_value,
      };
      return config;
    }

    /*
      Private: parse the text content of the element for default value, display
               precision, and additional text.

      text_content - the String text version of the element

      Return the default value for the variable.
    */
    static _parseTextContent (parsed_config, text_content) {
      let default_value     = parsed_config.value;
      let before_text       = '';
      let after_text        = '';
      let display_precision = null;

      /*
          [
            '$200.0 per day',
            '$',
            '200',
            '.',
            '0',
            ' per day',
            index: 0,
            input: '$200.0 per day'
          ]
      */
      const pattern = /([a-zA-Z=:$ ]*)([\-\d]+)(\.?)(\d*)([a-zA-Z=: ]*)/;
      const match_group = text_content.match(pattern);
      if (match_group) {
        const [
          _text,
          before_text_str,
          value_str,
          point_str,
          decimal_str,
          after_text_str,
        ] = match_group;
        before_text = before_text_str;
        after_text = after_text_str;
        default_value = parseFloat([value_str, point_str, decimal_str].join(''));
        if (point_str) {
          display_precision = decimal_str.length;
        }
      }
      return {
        default_value,
        before_text,
        after_text,
        display_precision,
      };
    }

    constructor (el) {
      super(el);
      this.els = {};
      const parsed_config = RangeElement._parseConfig(el.dataset.config);
      const parsed_text = RangeElement._parseTextContent(parsed_config, el.textContent);
      this._before_text = parsed_text.before_text;
      this._after_text = parsed_text.after_text;
      this._display_precision = parsed_text.display_precision;
      this._text_content = el.textContent;
      this.variable = new Variable(parsed_config.name, parsed_text.default_value);
      this.variable.onChange(() => this._renderUpdate());
      this._initial_value = parsed_text.default_value;
      this._config = parsed_config;
      this._renderInitial();
      this._last_click = 0;
      this._drag_manager = drag_manager;
    }

    _renderInitial () {
      this.el.innerHTML = `<ruby><span class="_Value"></span><rp>(</rp><rt class="_Name"></rt><rp>)</rp></ruby><span class="_Indicator" aria-role="hidden"></span>`;
      this.el.classList.add('RangeElement');
      this.el.setAttribute('aria-role', "slider");
      this.el.setAttribute('aria-valuemin', this._config.min);
      this.el.setAttribute('aria-valuemax', this._config.max);
      this.els.value = this.el.querySelector('._Value');
      this.els.name = this.el.querySelector('._Name');
      this.els.name.textContent = this.variable.getName();
      this.els.indicator = this.el.querySelector('._Indicator');
      this._renderUpdate();
      this._bindEvents();
    }

    _bindEvents () {
      this.el.addEventListener('mousedown', this._startDragging.bind(this));
      this.el.addEventListener('touchstart', this._startDragging.bind(this));
      this.el.addEventListener('click', this._reset.bind(this));
      this.el.addEventListener('keydown', this._handleKeydown.bind(this));
    }

    _handleKeydown (e) {
      if (
        e.which === 37 // Left Arrow
        || e.which === 40 // Down Arrow
      ) {
        e.preventDefault();
        this._decrement(e.shiftKey ? this._config.step * 10 : this._config.step);
      } else if (
        e.which === 39 // Right Arrow
        || e.which === 38 // Up Arrow
      ) {
        e.preventDefault();
        this._increment(e.shiftKey ? this._config.step * 10 : this._config.step);
      } else if (
        e.which === 13 // Enter
      ) {
        e.preventDefault();
        this._reset();
      }
    }

    _increment (magnitude) {
      if (!magnitude) {
        magnitude = this._config.step;
      }
      const current_value = this.variable.getValue();
      let new_value = current_value + magnitude;
      if (this._config.max != null) {
        if (this._config.inclusive) {
          if (new_value > this._config.max) {
            new_value = this._config.max;
          }
        } else {
          if (new_value > this._config.max - this._config.step) {
            new_value = this._config.max - this._config.step;
          }
        }
      }
      this.variable.setValue(new_value);
    }

    _decrement (magnitude) {
      if (!magnitude) {
        magnitude = this._config.step;
      }
      const current_value = this.variable.getValue();
      let new_value = current_value - magnitude;
      if (this._config.min != null) {
        if (new_value < this._config.min) {
          new_value = this._config.min;
        }
      }
      this.variable.setValue(new_value);
    }

    _startDragging (e) {
      e.preventDefault();
      this._drag_start_value = this.variable.getValue();
      this._drag_manager.start(e, this, 'x');
      this.el.dataset.is_active = true;
    }

    onDrag ({ x_start, y_start, x_delta, y_delta }) {
      const max = this._config.max;
      const min = this._config.min;
      const step = this._config.step;
      let px_per_step;
      if (max != null && min != null) {
        px_per_step = Math.min((window.innerWidth / (max - min / step)), 25); // Keep the step size close to a comfortable touch target
      } else {
        px_per_step = 25;
      }
      const value_delta = Math.floor(x_delta / px_per_step) * step;
      let new_val = this._drag_start_value + value_delta;

      if (max != null) {
        const inclusive = this._config.inclusive;
        if (
          (inclusive && new_val > max)
          || (!inclusive && new_val >= max)
        ) {
          new_val = max;
          if (!inclusive) {
            new_val -= this._config.step;
          }
        }
      }
      if (min != null && new_val < min) {
        new_val = min;
      }
      if (this.variable.getValue() !== new_val) {
        this.variable.setValue(new_val);
      }
    }

    stopDragging (ui) {
      this.el.dataset.is_active = false;
      this._drag_start_value = null;
    }

    _reset () {
      const now = Date.now();
      if (now - this._last_click < 500) {
        this.variable.setValue(this._initial_value);
      }
      this._last_click = now;
    }

    _renderUpdate () {
      const value = this.variable.getValue();

      if (value === undefined) {
        this.el.setAttribute('aria-valuetext', this._text_content);
        this.els.value.textContent = this._text_content;
        return;
      }

      let display_val;
      if (this._display_precision != null) {
        display_val = value.toFixed(this._display_precision);
      } else {
        display_val = value;
      }
      display_val = `${this._before_text || ''}${ display_val }${ this._after_text || '' }`;
      this.el.setAttribute('aria-valuetext', display_val);
      this.el.setAttribute('aria-valuenow', value);
      this.els.value.textContent = display_val;
      if (this._config.max != null && this._config.min != null) {
        const max = this._config.inclusive ? this._config.max : this._config.max - this._config.step;
        const min = this._config.min;
        const progress = (value - min) / (max - min);
        this.els.indicator.style.width = `${ progress * 100 }%`;
      }
    }

  }

  class StringElement extends BaseElement {
    readonly = true;
    static config_pattern = /(^[\w\d]+$)/;

    static _parseConfig (config_text) {
      const config_match = config_text.match(this.config_pattern);
      if (!config_match) { return null; }
      return {
        name: config_match[1],
      };
    }

    static _parseTextContent (parsed_config, text_content) {
      let default_value     = parsed_config.value;
      let before_text       = '';
      let after_text        = '';
      let display_precision = null;

      /*
          [
            '$200.0 per day',
            '$',
            '200',
            '.',
            '0',
            ' per day',
            index: 0,
            input: '$200.0 per day'
          ]
      */
      const pattern = /([a-zA-Z=:$ ]*)([\-\d]+)(\.?)(\d*)([%a-zA-Z=: ]*)/;
      const match_group = text_content.match(pattern);
      if (match_group) {
        const [
          _text,
          before_text_str,
          value_str,
          point_str,
          decimal_str,
          after_text_str,
        ] = match_group;
        before_text = before_text_str;
        after_text = after_text_str;
        default_value = parseFloat([value_str, point_str, decimal_str].join(''));
        if (point_str) {
          display_precision = decimal_str.length;
        }
      }
      return {
        default_value,
        before_text,
        after_text,
        display_precision,
      };
    }

    constructor (el) {
      super(el);
      this.els = {};
      const parsed_config = StringElement._parseConfig(el.dataset.config);
      const parsed_text = StringElement._parseTextContent(parsed_config, el.textContent);
      this._before_text = parsed_text.before_text;
      this._after_text = parsed_text.after_text;
      this._display_precision = parsed_text.display_precision;
      this._text_content = el.textContent;
      this.variable = Variable.getOrCreate(parsed_config.name);
      this.variable.onChange(() => this._renderUpdate());
      this._renderInitial();
    }

    _renderInitial () {
      this.el.innerHTML = `<ruby><span class="_Value"></span><rp>(</rp><rt class="_Name"></rt><rp>)</rp></ruby>`;
      this.el.classList.add('StringElement');
      this.els.value = this.el.querySelector('._Value');
      this.els.name = this.el.querySelector('._Name');
      this.els.name.textContent = this.variable.getName();
      this._renderUpdate();
    }

    _renderUpdate () {
      let value = this.variable.getValue();
      let display_value;
      if (value === undefined) {
        display_value = this._text_content;
      } else {
        // Automatically format percents
        if (typeof value === "number") {
          if (this._after_text === "%") {
            value = value * 100;
          }
          if (this._display_precision !== null) {
            display_value = value.toFixed(this._display_precision);
          } else {
            const fmt = new Intl.NumberFormat({
              // minimumFractionDigits: this._display_precision || undefined,
              // maximumFractionDigits: this._display_precision || undefined,
            });
            display_value = fmt.format(value);
          }
        } else if (Array.isArray(value)) {
          if (value.length > 0) {
            display_value = value.join(", ");
          } else {
            display_value = this._text_content;
          }
        } else {
          display_value = value.toString();
        }
      }
      display_value = `${ this._before_text || '' }${ display_value }${ this._after_text || '' }`;
      if (this.els.value.textContent !== display_value) {
        this.els.value.textContent = display_value;
        this._pingChanged();
      }
    }
  }

  class SwitchElement extends BaseElement {
    static config_pattern = new RegExp(`
    ^(                      # Variable
      [\\w\\d]+               # - name
    )

    :\\s                   # Delimiter

    (                       # true_label
        [\\w]+
    )

    \\sor\\s                  # or keyword

    (                       # false_label
        [\\w]+
    )$
  `.replace(/#.*\n/g,'').replace(/\s+/g,''));

    static _parseConfig (config_text) {
      const config_match = config_text.match(this.config_pattern);
      if (!config_match) { return null; }
      /*
          [
              "some_flag: on or off",
              "some_flag",
              "on",
              "off",
              index: 0,
              input: "some_flag: on or off"
          ]
      */

      const [
        _text,
        name,
        true_label,
        false_label,
      ] = config_match;

      return {
        name,
        true_label,
        false_label,
      };
    }

    static _parseTextContent (parsed_config, text_content) {
      const { true_label, false_label } = parsed_config;

      function matchLabel (label) {
        const pattern = RegExp(`(.*)${ label }(.*)`);
        const group = text_content.match(pattern);
        return group;
      }

      let default_value = undefined;
      let before_text = '';
      let after_text = '';

      const true_group = matchLabel(true_label);
      if (true_group) {
        default_value = true;
        before_text = true_group[1];
        after_text = true_group[2];
      } else {
        const false_group = matchLabel(false_label);
        if (false_group) {
          default_value = false;
          before_text = false_group[1];
          after_text = false_group[2];
        }
      }
      return {
        default_value,
        before_text,
        after_text,
      };
    }

    constructor (el) {
      super(el);
      this.els = {};
      const parsed_config = SwitchElement._parseConfig(el.dataset.config);
      const parsed_text = SwitchElement._parseTextContent(parsed_config, el.textContent);
      this._true_label = parsed_config.true_label;
      this._false_label = parsed_config.false_label;
      this._before_text = parsed_text.before_text;
      this._after_text = parsed_text.after_text;
      this._text_content = el.textContent;
      this._name = parsed_config.name;
      this.variable = new Variable(parsed_config.name, parsed_text.default_value);
      this.variable.onChange(() => this._renderUpdate());
      this._renderInitial();
    }

    _renderInitial () {
      this.el.innerHTML = `<span class="_Indicator" aria-hidden="true">•</span><ruby><span class="_Value"></span><rp>(</rp><rt class="_Name"></rt><rp>)</rp></ruby>`;
      this.el.classList.add('SwitchElement');
      this.el.setAttribute('aria-role', "button");
      this.els.value = this.el.querySelector("._Value");
      this.els.name = this.el.querySelector("._Name");
      this.els.indicator = this.el.querySelector("._Indicator");
      this.els.name.textContent = this._name;
      this._renderUpdate();
      this._bindEvents();
    }

    _renderUpdate () {
      const value = this.variable.getValue();
      let display_val;
      if (value === true) {
        display_val = this._true_label;
        this.el.setAttribute('aria-pressed', true);
      } else if (value === false) {
        display_val = this._false_label;
        this.el.setAttribute('aria-pressed', false);
      } else {
        display_val = this._text_content;
        this.el.setAttribute('aria-pressed', 'mixed');
      }
      display_val = `${this._before_text || ''}${ display_val }${ this._after_text || '' }`;
      this.els.value.textContent = display_val;
    }

    _bindEvents () {
      this.el.addEventListener('click', this._toggleValue.bind(this));
      this.el.addEventListener('keydown', this._handleKeydown.bind(this));
    }

    _handleKeydown (e) {
      if (
        e.which === 32 // Space
        || e.which === 13 // Enter
      ) {
        e.preventDefault();
        this._toggleValue();
      }
    }

    _toggleValue (e) {
      const current = this.variable.getValue();
      if (current === true) {
        this.variable.setValue(false);
      } else {
        this.variable.setValue(true);
      }
    }
  }

  class FormElement extends BaseElement {
    constructor (el) {
      super(el);
      this.el.classList.add('FormElement');
      const name = this.el.getAttribute('name');
      this._variable = new Variable(name);
      this.el.addEventListener('change', this._triggerUpdate.bind(this));
      this._triggerUpdate({ target: this.el }); // Get the initial value from the markup
    }

    _triggerUpdate (e) {
      if (this.el.options && this.el.multiple) {
        const value = [];
        for (const option of this.el.options) {
          if (option.selected) {
            value.push(option.value);
          }
        }
        this._variable.setValue(value);
      } else {
        this._variable.setValue(e.target.value);
      }

    }
  }

  var global$1 = (typeof global !== "undefined" ? global :
              typeof self !== "undefined" ? self :
              typeof window !== "undefined" ? window : {});

  var lookup = [];
  var revLookup = [];
  var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
  var inited = false;
  function init () {
    inited = true;
    var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
    for (var i = 0, len = code.length; i < len; ++i) {
      lookup[i] = code[i];
      revLookup[code.charCodeAt(i)] = i;
    }

    revLookup['-'.charCodeAt(0)] = 62;
    revLookup['_'.charCodeAt(0)] = 63;
  }

  function toByteArray (b64) {
    if (!inited) {
      init();
    }
    var i, j, l, tmp, placeHolders, arr;
    var len = b64.length;

    if (len % 4 > 0) {
      throw new Error('Invalid string. Length must be a multiple of 4')
    }

    // the number of equal signs (place holders)
    // if there are two placeholders, than the two characters before it
    // represent one byte
    // if there is only one, then the three characters before it represent 2 bytes
    // this is just a cheap hack to not do indexOf twice
    placeHolders = b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0;

    // base64 is 4/3 + up to two characters of the original data
    arr = new Arr(len * 3 / 4 - placeHolders);

    // if there are placeholders, only get up to the last complete 4 chars
    l = placeHolders > 0 ? len - 4 : len;

    var L = 0;

    for (i = 0, j = 0; i < l; i += 4, j += 3) {
      tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)];
      arr[L++] = (tmp >> 16) & 0xFF;
      arr[L++] = (tmp >> 8) & 0xFF;
      arr[L++] = tmp & 0xFF;
    }

    if (placeHolders === 2) {
      tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4);
      arr[L++] = tmp & 0xFF;
    } else if (placeHolders === 1) {
      tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2);
      arr[L++] = (tmp >> 8) & 0xFF;
      arr[L++] = tmp & 0xFF;
    }

    return arr
  }

  function tripletToBase64 (num) {
    return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
  }

  function encodeChunk (uint8, start, end) {
    var tmp;
    var output = [];
    for (var i = start; i < end; i += 3) {
      tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);
      output.push(tripletToBase64(tmp));
    }
    return output.join('')
  }

  function fromByteArray (uint8) {
    if (!inited) {
      init();
    }
    var tmp;
    var len = uint8.length;
    var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes
    var output = '';
    var parts = [];
    var maxChunkLength = 16383; // must be multiple of 3

    // go through the array every three bytes, we'll deal with trailing stuff later
    for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
      parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)));
    }

    // pad the end with zeros, but make sure to not forget the extra bytes
    if (extraBytes === 1) {
      tmp = uint8[len - 1];
      output += lookup[tmp >> 2];
      output += lookup[(tmp << 4) & 0x3F];
      output += '==';
    } else if (extraBytes === 2) {
      tmp = (uint8[len - 2] << 8) + (uint8[len - 1]);
      output += lookup[tmp >> 10];
      output += lookup[(tmp >> 4) & 0x3F];
      output += lookup[(tmp << 2) & 0x3F];
      output += '=';
    }

    parts.push(output);

    return parts.join('')
  }

  function read (buffer, offset, isLE, mLen, nBytes) {
    var e, m;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i = isLE ? (nBytes - 1) : 0;
    var d = isLE ? -1 : 1;
    var s = buffer[offset + i];

    i += d;

    e = s & ((1 << (-nBits)) - 1);
    s >>= (-nBits);
    nBits += eLen;
    for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

    m = e & ((1 << (-nBits)) - 1);
    e >>= (-nBits);
    nBits += mLen;
    for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

    if (e === 0) {
      e = 1 - eBias;
    } else if (e === eMax) {
      return m ? NaN : ((s ? -1 : 1) * Infinity)
    } else {
      m = m + Math.pow(2, mLen);
      e = e - eBias;
    }
    return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
  }

  function write (buffer, value, offset, isLE, mLen, nBytes) {
    var e, m, c;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0);
    var i = isLE ? 0 : (nBytes - 1);
    var d = isLE ? 1 : -1;
    var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

    value = Math.abs(value);

    if (isNaN(value) || value === Infinity) {
      m = isNaN(value) ? 1 : 0;
      e = eMax;
    } else {
      e = Math.floor(Math.log(value) / Math.LN2);
      if (value * (c = Math.pow(2, -e)) < 1) {
        e--;
        c *= 2;
      }
      if (e + eBias >= 1) {
        value += rt / c;
      } else {
        value += rt * Math.pow(2, 1 - eBias);
      }
      if (value * c >= 2) {
        e++;
        c /= 2;
      }

      if (e + eBias >= eMax) {
        m = 0;
        e = eMax;
      } else if (e + eBias >= 1) {
        m = (value * c - 1) * Math.pow(2, mLen);
        e = e + eBias;
      } else {
        m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
        e = 0;
      }
    }

    for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

    e = (e << mLen) | m;
    eLen += mLen;
    for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

    buffer[offset + i - d] |= s * 128;
  }

  var toString = {}.toString;

  var isArray = Array.isArray || function (arr) {
    return toString.call(arr) == '[object Array]';
  };

  var INSPECT_MAX_BYTES = 50;

  /**
   * If `Buffer.TYPED_ARRAY_SUPPORT`:
   *   === true    Use Uint8Array implementation (fastest)
   *   === false   Use Object implementation (most compatible, even IE6)
   *
   * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
   * Opera 11.6+, iOS 4.2+.
   *
   * Due to various browser bugs, sometimes the Object implementation will be used even
   * when the browser supports typed arrays.
   *
   * Note:
   *
   *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
   *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
   *
   *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
   *
   *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
   *     incorrect length in some situations.

   * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
   * get the Object implementation, which is slower but behaves correctly.
   */
  Buffer.TYPED_ARRAY_SUPPORT = global$1.TYPED_ARRAY_SUPPORT !== undefined
    ? global$1.TYPED_ARRAY_SUPPORT
    : true;

  function kMaxLength () {
    return Buffer.TYPED_ARRAY_SUPPORT
      ? 0x7fffffff
      : 0x3fffffff
  }

  function createBuffer (that, length) {
    if (kMaxLength() < length) {
      throw new RangeError('Invalid typed array length')
    }
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      // Return an augmented `Uint8Array` instance, for best performance
      that = new Uint8Array(length);
      that.__proto__ = Buffer.prototype;
    } else {
      // Fallback: Return an object instance of the Buffer class
      if (that === null) {
        that = new Buffer(length);
      }
      that.length = length;
    }

    return that
  }

  /**
   * The Buffer constructor returns instances of `Uint8Array` that have their
   * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
   * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
   * and the `Uint8Array` methods. Square bracket notation works as expected -- it
   * returns a single octet.
   *
   * The `Uint8Array` prototype remains unmodified.
   */

  function Buffer (arg, encodingOrOffset, length) {
    if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
      return new Buffer(arg, encodingOrOffset, length)
    }

    // Common case.
    if (typeof arg === 'number') {
      if (typeof encodingOrOffset === 'string') {
        throw new Error(
          'If encoding is specified then the first argument must be a string'
        )
      }
      return allocUnsafe(this, arg)
    }
    return from(this, arg, encodingOrOffset, length)
  }

  Buffer.poolSize = 8192; // not used by this implementation

  // TODO: Legacy, not needed anymore. Remove in next major version.
  Buffer._augment = function (arr) {
    arr.__proto__ = Buffer.prototype;
    return arr
  };

  function from (that, value, encodingOrOffset, length) {
    if (typeof value === 'number') {
      throw new TypeError('"value" argument must not be a number')
    }

    if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
      return fromArrayBuffer(that, value, encodingOrOffset, length)
    }

    if (typeof value === 'string') {
      return fromString(that, value, encodingOrOffset)
    }

    return fromObject(that, value)
  }

  /**
   * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
   * if value is a number.
   * Buffer.from(str[, encoding])
   * Buffer.from(array)
   * Buffer.from(buffer)
   * Buffer.from(arrayBuffer[, byteOffset[, length]])
   **/
  Buffer.from = function (value, encodingOrOffset, length) {
    return from(null, value, encodingOrOffset, length)
  };

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    Buffer.prototype.__proto__ = Uint8Array.prototype;
    Buffer.__proto__ = Uint8Array;
  }

  function assertSize (size) {
    if (typeof size !== 'number') {
      throw new TypeError('"size" argument must be a number')
    } else if (size < 0) {
      throw new RangeError('"size" argument must not be negative')
    }
  }

  function alloc (that, size, fill, encoding) {
    assertSize(size);
    if (size <= 0) {
      return createBuffer(that, size)
    }
    if (fill !== undefined) {
      // Only pay attention to encoding if it's a string. This
      // prevents accidentally sending in a number that would
      // be interpretted as a start offset.
      return typeof encoding === 'string'
        ? createBuffer(that, size).fill(fill, encoding)
        : createBuffer(that, size).fill(fill)
    }
    return createBuffer(that, size)
  }

  /**
   * Creates a new filled Buffer instance.
   * alloc(size[, fill[, encoding]])
   **/
  Buffer.alloc = function (size, fill, encoding) {
    return alloc(null, size, fill, encoding)
  };

  function allocUnsafe (that, size) {
    assertSize(size);
    that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);
    if (!Buffer.TYPED_ARRAY_SUPPORT) {
      for (var i = 0; i < size; ++i) {
        that[i] = 0;
      }
    }
    return that
  }

  /**
   * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
   * */
  Buffer.allocUnsafe = function (size) {
    return allocUnsafe(null, size)
  };
  /**
   * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
   */
  Buffer.allocUnsafeSlow = function (size) {
    return allocUnsafe(null, size)
  };

  function fromString (that, string, encoding) {
    if (typeof encoding !== 'string' || encoding === '') {
      encoding = 'utf8';
    }

    if (!Buffer.isEncoding(encoding)) {
      throw new TypeError('"encoding" must be a valid string encoding')
    }

    var length = byteLength(string, encoding) | 0;
    that = createBuffer(that, length);

    var actual = that.write(string, encoding);

    if (actual !== length) {
      // Writing a hex string, for example, that contains invalid characters will
      // cause everything after the first invalid character to be ignored. (e.g.
      // 'abxxcd' will be treated as 'ab')
      that = that.slice(0, actual);
    }

    return that
  }

  function fromArrayLike (that, array) {
    var length = array.length < 0 ? 0 : checked(array.length) | 0;
    that = createBuffer(that, length);
    for (var i = 0; i < length; i += 1) {
      that[i] = array[i] & 255;
    }
    return that
  }

  function fromArrayBuffer (that, array, byteOffset, length) {

    if (byteOffset < 0 || array.byteLength < byteOffset) {
      throw new RangeError('\'offset\' is out of bounds')
    }

    if (array.byteLength < byteOffset + (length || 0)) {
      throw new RangeError('\'length\' is out of bounds')
    }

    if (byteOffset === undefined && length === undefined) {
      array = new Uint8Array(array);
    } else if (length === undefined) {
      array = new Uint8Array(array, byteOffset);
    } else {
      array = new Uint8Array(array, byteOffset, length);
    }

    if (Buffer.TYPED_ARRAY_SUPPORT) {
      // Return an augmented `Uint8Array` instance, for best performance
      that = array;
      that.__proto__ = Buffer.prototype;
    } else {
      // Fallback: Return an object instance of the Buffer class
      that = fromArrayLike(that, array);
    }
    return that
  }

  function fromObject (that, obj) {
    if (internalIsBuffer(obj)) {
      var len = checked(obj.length) | 0;
      that = createBuffer(that, len);

      if (that.length === 0) {
        return that
      }

      obj.copy(that, 0, 0, len);
      return that
    }

    if (obj) {
      if ((typeof ArrayBuffer !== 'undefined' &&
          obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
        if (typeof obj.length !== 'number' || isnan(obj.length)) {
          return createBuffer(that, 0)
        }
        return fromArrayLike(that, obj)
      }

      if (obj.type === 'Buffer' && isArray(obj.data)) {
        return fromArrayLike(that, obj.data)
      }
    }

    throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
  }

  function checked (length) {
    // Note: cannot use `length < kMaxLength()` here because that fails when
    // length is NaN (which is otherwise coerced to zero.)
    if (length >= kMaxLength()) {
      throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                           'size: 0x' + kMaxLength().toString(16) + ' bytes')
    }
    return length | 0
  }
  Buffer.isBuffer = isBuffer;
  function internalIsBuffer (b) {
    return !!(b != null && b._isBuffer)
  }

  Buffer.compare = function compare (a, b) {
    if (!internalIsBuffer(a) || !internalIsBuffer(b)) {
      throw new TypeError('Arguments must be Buffers')
    }

    if (a === b) return 0

    var x = a.length;
    var y = b.length;

    for (var i = 0, len = Math.min(x, y); i < len; ++i) {
      if (a[i] !== b[i]) {
        x = a[i];
        y = b[i];
        break
      }
    }

    if (x < y) return -1
    if (y < x) return 1
    return 0
  };

  Buffer.isEncoding = function isEncoding (encoding) {
    switch (String(encoding).toLowerCase()) {
      case 'hex':
      case 'utf8':
      case 'utf-8':
      case 'ascii':
      case 'latin1':
      case 'binary':
      case 'base64':
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return true
      default:
        return false
    }
  };

  Buffer.concat = function concat (list, length) {
    if (!isArray(list)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }

    if (list.length === 0) {
      return Buffer.alloc(0)
    }

    var i;
    if (length === undefined) {
      length = 0;
      for (i = 0; i < list.length; ++i) {
        length += list[i].length;
      }
    }

    var buffer = Buffer.allocUnsafe(length);
    var pos = 0;
    for (i = 0; i < list.length; ++i) {
      var buf = list[i];
      if (!internalIsBuffer(buf)) {
        throw new TypeError('"list" argument must be an Array of Buffers')
      }
      buf.copy(buffer, pos);
      pos += buf.length;
    }
    return buffer
  };

  function byteLength (string, encoding) {
    if (internalIsBuffer(string)) {
      return string.length
    }
    if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
        (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
      return string.byteLength
    }
    if (typeof string !== 'string') {
      string = '' + string;
    }

    var len = string.length;
    if (len === 0) return 0

    // Use a for loop to avoid recursion
    var loweredCase = false;
    for (;;) {
      switch (encoding) {
        case 'ascii':
        case 'latin1':
        case 'binary':
          return len
        case 'utf8':
        case 'utf-8':
        case undefined:
          return utf8ToBytes(string).length
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return len * 2
        case 'hex':
          return len >>> 1
        case 'base64':
          return base64ToBytes(string).length
        default:
          if (loweredCase) return utf8ToBytes(string).length // assume utf8
          encoding = ('' + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer.byteLength = byteLength;

  function slowToString (encoding, start, end) {
    var loweredCase = false;

    // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
    // property of a typed array.

    // This behaves neither like String nor Uint8Array in that we set start/end
    // to their upper/lower bounds if the value passed is out of range.
    // undefined is handled specially as per ECMA-262 6th Edition,
    // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
    if (start === undefined || start < 0) {
      start = 0;
    }
    // Return early if start > this.length. Done here to prevent potential uint32
    // coercion fail below.
    if (start > this.length) {
      return ''
    }

    if (end === undefined || end > this.length) {
      end = this.length;
    }

    if (end <= 0) {
      return ''
    }

    // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
    end >>>= 0;
    start >>>= 0;

    if (end <= start) {
      return ''
    }

    if (!encoding) encoding = 'utf8';

    while (true) {
      switch (encoding) {
        case 'hex':
          return hexSlice(this, start, end)

        case 'utf8':
        case 'utf-8':
          return utf8Slice(this, start, end)

        case 'ascii':
          return asciiSlice(this, start, end)

        case 'latin1':
        case 'binary':
          return latin1Slice(this, start, end)

        case 'base64':
          return base64Slice(this, start, end)

        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return utf16leSlice(this, start, end)

        default:
          if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
          encoding = (encoding + '').toLowerCase();
          loweredCase = true;
      }
    }
  }

  // The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
  // Buffer instances.
  Buffer.prototype._isBuffer = true;

  function swap (b, n, m) {
    var i = b[n];
    b[n] = b[m];
    b[m] = i;
  }

  Buffer.prototype.swap16 = function swap16 () {
    var len = this.length;
    if (len % 2 !== 0) {
      throw new RangeError('Buffer size must be a multiple of 16-bits')
    }
    for (var i = 0; i < len; i += 2) {
      swap(this, i, i + 1);
    }
    return this
  };

  Buffer.prototype.swap32 = function swap32 () {
    var len = this.length;
    if (len % 4 !== 0) {
      throw new RangeError('Buffer size must be a multiple of 32-bits')
    }
    for (var i = 0; i < len; i += 4) {
      swap(this, i, i + 3);
      swap(this, i + 1, i + 2);
    }
    return this
  };

  Buffer.prototype.swap64 = function swap64 () {
    var len = this.length;
    if (len % 8 !== 0) {
      throw new RangeError('Buffer size must be a multiple of 64-bits')
    }
    for (var i = 0; i < len; i += 8) {
      swap(this, i, i + 7);
      swap(this, i + 1, i + 6);
      swap(this, i + 2, i + 5);
      swap(this, i + 3, i + 4);
    }
    return this
  };

  Buffer.prototype.toString = function toString () {
    var length = this.length | 0;
    if (length === 0) return ''
    if (arguments.length === 0) return utf8Slice(this, 0, length)
    return slowToString.apply(this, arguments)
  };

  Buffer.prototype.equals = function equals (b) {
    if (!internalIsBuffer(b)) throw new TypeError('Argument must be a Buffer')
    if (this === b) return true
    return Buffer.compare(this, b) === 0
  };

  Buffer.prototype.inspect = function inspect () {
    var str = '';
    var max = INSPECT_MAX_BYTES;
    if (this.length > 0) {
      str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
      if (this.length > max) str += ' ... ';
    }
    return '<Buffer ' + str + '>'
  };

  Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
    if (!internalIsBuffer(target)) {
      throw new TypeError('Argument must be a Buffer')
    }

    if (start === undefined) {
      start = 0;
    }
    if (end === undefined) {
      end = target ? target.length : 0;
    }
    if (thisStart === undefined) {
      thisStart = 0;
    }
    if (thisEnd === undefined) {
      thisEnd = this.length;
    }

    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
      throw new RangeError('out of range index')
    }

    if (thisStart >= thisEnd && start >= end) {
      return 0
    }
    if (thisStart >= thisEnd) {
      return -1
    }
    if (start >= end) {
      return 1
    }

    start >>>= 0;
    end >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;

    if (this === target) return 0

    var x = thisEnd - thisStart;
    var y = end - start;
    var len = Math.min(x, y);

    var thisCopy = this.slice(thisStart, thisEnd);
    var targetCopy = target.slice(start, end);

    for (var i = 0; i < len; ++i) {
      if (thisCopy[i] !== targetCopy[i]) {
        x = thisCopy[i];
        y = targetCopy[i];
        break
      }
    }

    if (x < y) return -1
    if (y < x) return 1
    return 0
  };

  // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
  // OR the last index of `val` in `buffer` at offset <= `byteOffset`.
  //
  // Arguments:
  // - buffer - a Buffer to search
  // - val - a string, Buffer, or number
  // - byteOffset - an index into `buffer`; will be clamped to an int32
  // - encoding - an optional encoding, relevant is val is a string
  // - dir - true for indexOf, false for lastIndexOf
  function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
    // Empty buffer means no match
    if (buffer.length === 0) return -1

    // Normalize byteOffset
    if (typeof byteOffset === 'string') {
      encoding = byteOffset;
      byteOffset = 0;
    } else if (byteOffset > 0x7fffffff) {
      byteOffset = 0x7fffffff;
    } else if (byteOffset < -0x80000000) {
      byteOffset = -0x80000000;
    }
    byteOffset = +byteOffset;  // Coerce to Number.
    if (isNaN(byteOffset)) {
      // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
      byteOffset = dir ? 0 : (buffer.length - 1);
    }

    // Normalize byteOffset: negative offsets start from the end of the buffer
    if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
    if (byteOffset >= buffer.length) {
      if (dir) return -1
      else byteOffset = buffer.length - 1;
    } else if (byteOffset < 0) {
      if (dir) byteOffset = 0;
      else return -1
    }

    // Normalize val
    if (typeof val === 'string') {
      val = Buffer.from(val, encoding);
    }

    // Finally, search either indexOf (if dir is true) or lastIndexOf
    if (internalIsBuffer(val)) {
      // Special case: looking for empty string/buffer always fails
      if (val.length === 0) {
        return -1
      }
      return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
    } else if (typeof val === 'number') {
      val = val & 0xFF; // Search for a byte value [0-255]
      if (Buffer.TYPED_ARRAY_SUPPORT &&
          typeof Uint8Array.prototype.indexOf === 'function') {
        if (dir) {
          return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
        } else {
          return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
        }
      }
      return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
    }

    throw new TypeError('val must be string, number or Buffer')
  }

  function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
    var indexSize = 1;
    var arrLength = arr.length;
    var valLength = val.length;

    if (encoding !== undefined) {
      encoding = String(encoding).toLowerCase();
      if (encoding === 'ucs2' || encoding === 'ucs-2' ||
          encoding === 'utf16le' || encoding === 'utf-16le') {
        if (arr.length < 2 || val.length < 2) {
          return -1
        }
        indexSize = 2;
        arrLength /= 2;
        valLength /= 2;
        byteOffset /= 2;
      }
    }

    function read (buf, i) {
      if (indexSize === 1) {
        return buf[i]
      } else {
        return buf.readUInt16BE(i * indexSize)
      }
    }

    var i;
    if (dir) {
      var foundIndex = -1;
      for (i = byteOffset; i < arrLength; i++) {
        if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
          if (foundIndex === -1) foundIndex = i;
          if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
        } else {
          if (foundIndex !== -1) i -= i - foundIndex;
          foundIndex = -1;
        }
      }
    } else {
      if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
      for (i = byteOffset; i >= 0; i--) {
        var found = true;
        for (var j = 0; j < valLength; j++) {
          if (read(arr, i + j) !== read(val, j)) {
            found = false;
            break
          }
        }
        if (found) return i
      }
    }

    return -1
  }

  Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1
  };

  Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
  };

  Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
  };

  function hexWrite (buf, string, offset, length) {
    offset = Number(offset) || 0;
    var remaining = buf.length - offset;
    if (!length) {
      length = remaining;
    } else {
      length = Number(length);
      if (length > remaining) {
        length = remaining;
      }
    }

    // must be an even number of digits
    var strLen = string.length;
    if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

    if (length > strLen / 2) {
      length = strLen / 2;
    }
    for (var i = 0; i < length; ++i) {
      var parsed = parseInt(string.substr(i * 2, 2), 16);
      if (isNaN(parsed)) return i
      buf[offset + i] = parsed;
    }
    return i
  }

  function utf8Write (buf, string, offset, length) {
    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
  }

  function asciiWrite (buf, string, offset, length) {
    return blitBuffer(asciiToBytes(string), buf, offset, length)
  }

  function latin1Write (buf, string, offset, length) {
    return asciiWrite(buf, string, offset, length)
  }

  function base64Write (buf, string, offset, length) {
    return blitBuffer(base64ToBytes(string), buf, offset, length)
  }

  function ucs2Write (buf, string, offset, length) {
    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
  }

  Buffer.prototype.write = function write (string, offset, length, encoding) {
    // Buffer#write(string)
    if (offset === undefined) {
      encoding = 'utf8';
      length = this.length;
      offset = 0;
    // Buffer#write(string, encoding)
    } else if (length === undefined && typeof offset === 'string') {
      encoding = offset;
      length = this.length;
      offset = 0;
    // Buffer#write(string, offset[, length][, encoding])
    } else if (isFinite(offset)) {
      offset = offset | 0;
      if (isFinite(length)) {
        length = length | 0;
        if (encoding === undefined) encoding = 'utf8';
      } else {
        encoding = length;
        length = undefined;
      }
    // legacy write(string, encoding, offset, length) - remove in v0.13
    } else {
      throw new Error(
        'Buffer.write(string, encoding, offset[, length]) is no longer supported'
      )
    }

    var remaining = this.length - offset;
    if (length === undefined || length > remaining) length = remaining;

    if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
      throw new RangeError('Attempt to write outside buffer bounds')
    }

    if (!encoding) encoding = 'utf8';

    var loweredCase = false;
    for (;;) {
      switch (encoding) {
        case 'hex':
          return hexWrite(this, string, offset, length)

        case 'utf8':
        case 'utf-8':
          return utf8Write(this, string, offset, length)

        case 'ascii':
          return asciiWrite(this, string, offset, length)

        case 'latin1':
        case 'binary':
          return latin1Write(this, string, offset, length)

        case 'base64':
          // Warning: maxLength not taken into account in base64Write
          return base64Write(this, string, offset, length)

        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return ucs2Write(this, string, offset, length)

        default:
          if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
          encoding = ('' + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  };

  Buffer.prototype.toJSON = function toJSON () {
    return {
      type: 'Buffer',
      data: Array.prototype.slice.call(this._arr || this, 0)
    }
  };

  function base64Slice (buf, start, end) {
    if (start === 0 && end === buf.length) {
      return fromByteArray(buf)
    } else {
      return fromByteArray(buf.slice(start, end))
    }
  }

  function utf8Slice (buf, start, end) {
    end = Math.min(buf.length, end);
    var res = [];

    var i = start;
    while (i < end) {
      var firstByte = buf[i];
      var codePoint = null;
      var bytesPerSequence = (firstByte > 0xEF) ? 4
        : (firstByte > 0xDF) ? 3
        : (firstByte > 0xBF) ? 2
        : 1;

      if (i + bytesPerSequence <= end) {
        var secondByte, thirdByte, fourthByte, tempCodePoint;

        switch (bytesPerSequence) {
          case 1:
            if (firstByte < 0x80) {
              codePoint = firstByte;
            }
            break
          case 2:
            secondByte = buf[i + 1];
            if ((secondByte & 0xC0) === 0x80) {
              tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F);
              if (tempCodePoint > 0x7F) {
                codePoint = tempCodePoint;
              }
            }
            break
          case 3:
            secondByte = buf[i + 1];
            thirdByte = buf[i + 2];
            if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
              tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F);
              if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
                codePoint = tempCodePoint;
              }
            }
            break
          case 4:
            secondByte = buf[i + 1];
            thirdByte = buf[i + 2];
            fourthByte = buf[i + 3];
            if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
              tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F);
              if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
                codePoint = tempCodePoint;
              }
            }
        }
      }

      if (codePoint === null) {
        // we did not generate a valid codePoint so insert a
        // replacement char (U+FFFD) and advance only 1 byte
        codePoint = 0xFFFD;
        bytesPerSequence = 1;
      } else if (codePoint > 0xFFFF) {
        // encode to utf16 (surrogate pair dance)
        codePoint -= 0x10000;
        res.push(codePoint >>> 10 & 0x3FF | 0xD800);
        codePoint = 0xDC00 | codePoint & 0x3FF;
      }

      res.push(codePoint);
      i += bytesPerSequence;
    }

    return decodeCodePointsArray(res)
  }

  // Based on http://stackoverflow.com/a/22747272/680742, the browser with
  // the lowest limit is Chrome, with 0x10000 args.
  // We go 1 magnitude less, for safety
  var MAX_ARGUMENTS_LENGTH = 0x1000;

  function decodeCodePointsArray (codePoints) {
    var len = codePoints.length;
    if (len <= MAX_ARGUMENTS_LENGTH) {
      return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
    }

    // Decode in chunks to avoid "call stack size exceeded".
    var res = '';
    var i = 0;
    while (i < len) {
      res += String.fromCharCode.apply(
        String,
        codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
      );
    }
    return res
  }

  function asciiSlice (buf, start, end) {
    var ret = '';
    end = Math.min(buf.length, end);

    for (var i = start; i < end; ++i) {
      ret += String.fromCharCode(buf[i] & 0x7F);
    }
    return ret
  }

  function latin1Slice (buf, start, end) {
    var ret = '';
    end = Math.min(buf.length, end);

    for (var i = start; i < end; ++i) {
      ret += String.fromCharCode(buf[i]);
    }
    return ret
  }

  function hexSlice (buf, start, end) {
    var len = buf.length;

    if (!start || start < 0) start = 0;
    if (!end || end < 0 || end > len) end = len;

    var out = '';
    for (var i = start; i < end; ++i) {
      out += toHex(buf[i]);
    }
    return out
  }

  function utf16leSlice (buf, start, end) {
    var bytes = buf.slice(start, end);
    var res = '';
    for (var i = 0; i < bytes.length; i += 2) {
      res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
    }
    return res
  }

  Buffer.prototype.slice = function slice (start, end) {
    var len = this.length;
    start = ~~start;
    end = end === undefined ? len : ~~end;

    if (start < 0) {
      start += len;
      if (start < 0) start = 0;
    } else if (start > len) {
      start = len;
    }

    if (end < 0) {
      end += len;
      if (end < 0) end = 0;
    } else if (end > len) {
      end = len;
    }

    if (end < start) end = start;

    var newBuf;
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      newBuf = this.subarray(start, end);
      newBuf.__proto__ = Buffer.prototype;
    } else {
      var sliceLen = end - start;
      newBuf = new Buffer(sliceLen, undefined);
      for (var i = 0; i < sliceLen; ++i) {
        newBuf[i] = this[i + start];
      }
    }

    return newBuf
  };

  /*
   * Need to make sure that buffer isn't trying to write out of bounds.
   */
  function checkOffset (offset, ext, length) {
    if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
    if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
  }

  Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);

    var val = this[offset];
    var mul = 1;
    var i = 0;
    while (++i < byteLength && (mul *= 0x100)) {
      val += this[offset + i] * mul;
    }

    return val
  };

  Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) {
      checkOffset(offset, byteLength, this.length);
    }

    var val = this[offset + --byteLength];
    var mul = 1;
    while (byteLength > 0 && (mul *= 0x100)) {
      val += this[offset + --byteLength] * mul;
    }

    return val
  };

  Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 1, this.length);
    return this[offset]
  };

  Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] | (this[offset + 1] << 8)
  };

  Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 2, this.length);
    return (this[offset] << 8) | this[offset + 1]
  };

  Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);

    return ((this[offset]) |
        (this[offset + 1] << 8) |
        (this[offset + 2] << 16)) +
        (this[offset + 3] * 0x1000000)
  };

  Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);

    return (this[offset] * 0x1000000) +
      ((this[offset + 1] << 16) |
      (this[offset + 2] << 8) |
      this[offset + 3])
  };

  Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);

    var val = this[offset];
    var mul = 1;
    var i = 0;
    while (++i < byteLength && (mul *= 0x100)) {
      val += this[offset + i] * mul;
    }
    mul *= 0x80;

    if (val >= mul) val -= Math.pow(2, 8 * byteLength);

    return val
  };

  Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);

    var i = byteLength;
    var mul = 1;
    var val = this[offset + --i];
    while (i > 0 && (mul *= 0x100)) {
      val += this[offset + --i] * mul;
    }
    mul *= 0x80;

    if (val >= mul) val -= Math.pow(2, 8 * byteLength);

    return val
  };

  Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 1, this.length);
    if (!(this[offset] & 0x80)) return (this[offset])
    return ((0xff - this[offset] + 1) * -1)
  };

  Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 2, this.length);
    var val = this[offset] | (this[offset + 1] << 8);
    return (val & 0x8000) ? val | 0xFFFF0000 : val
  };

  Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 2, this.length);
    var val = this[offset + 1] | (this[offset] << 8);
    return (val & 0x8000) ? val | 0xFFFF0000 : val
  };

  Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);

    return (this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16) |
      (this[offset + 3] << 24)
  };

  Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);

    return (this[offset] << 24) |
      (this[offset + 1] << 16) |
      (this[offset + 2] << 8) |
      (this[offset + 3])
  };

  Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);
    return read(this, offset, true, 23, 4)
  };

  Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);
    return read(this, offset, false, 23, 4)
  };

  Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 8, this.length);
    return read(this, offset, true, 52, 8)
  };

  Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 8, this.length);
    return read(this, offset, false, 52, 8)
  };

  function checkInt (buf, value, offset, ext, max, min) {
    if (!internalIsBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
    if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
    if (offset + ext > buf.length) throw new RangeError('Index out of range')
  }

  Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) {
      var maxBytes = Math.pow(2, 8 * byteLength) - 1;
      checkInt(this, value, offset, byteLength, maxBytes, 0);
    }

    var mul = 1;
    var i = 0;
    this[offset] = value & 0xFF;
    while (++i < byteLength && (mul *= 0x100)) {
      this[offset + i] = (value / mul) & 0xFF;
    }

    return offset + byteLength
  };

  Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) {
      var maxBytes = Math.pow(2, 8 * byteLength) - 1;
      checkInt(this, value, offset, byteLength, maxBytes, 0);
    }

    var i = byteLength - 1;
    var mul = 1;
    this[offset + i] = value & 0xFF;
    while (--i >= 0 && (mul *= 0x100)) {
      this[offset + i] = (value / mul) & 0xFF;
    }

    return offset + byteLength
  };

  Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
    if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
    this[offset] = (value & 0xff);
    return offset + 1
  };

  function objectWriteUInt16 (buf, value, offset, littleEndian) {
    if (value < 0) value = 0xffff + value + 1;
    for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
      buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
        (littleEndian ? i : 1 - i) * 8;
    }
  }

  Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value & 0xff);
      this[offset + 1] = (value >>> 8);
    } else {
      objectWriteUInt16(this, value, offset, true);
    }
    return offset + 2
  };

  Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value >>> 8);
      this[offset + 1] = (value & 0xff);
    } else {
      objectWriteUInt16(this, value, offset, false);
    }
    return offset + 2
  };

  function objectWriteUInt32 (buf, value, offset, littleEndian) {
    if (value < 0) value = 0xffffffff + value + 1;
    for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
      buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff;
    }
  }

  Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset + 3] = (value >>> 24);
      this[offset + 2] = (value >>> 16);
      this[offset + 1] = (value >>> 8);
      this[offset] = (value & 0xff);
    } else {
      objectWriteUInt32(this, value, offset, true);
    }
    return offset + 4
  };

  Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value >>> 24);
      this[offset + 1] = (value >>> 16);
      this[offset + 2] = (value >>> 8);
      this[offset + 3] = (value & 0xff);
    } else {
      objectWriteUInt32(this, value, offset, false);
    }
    return offset + 4
  };

  Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) {
      var limit = Math.pow(2, 8 * byteLength - 1);

      checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }

    var i = 0;
    var mul = 1;
    var sub = 0;
    this[offset] = value & 0xFF;
    while (++i < byteLength && (mul *= 0x100)) {
      if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
        sub = 1;
      }
      this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
    }

    return offset + byteLength
  };

  Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) {
      var limit = Math.pow(2, 8 * byteLength - 1);

      checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }

    var i = byteLength - 1;
    var mul = 1;
    var sub = 0;
    this[offset + i] = value & 0xFF;
    while (--i >= 0 && (mul *= 0x100)) {
      if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
        sub = 1;
      }
      this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
    }

    return offset + byteLength
  };

  Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
    if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
    if (value < 0) value = 0xff + value + 1;
    this[offset] = (value & 0xff);
    return offset + 1
  };

  Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value & 0xff);
      this[offset + 1] = (value >>> 8);
    } else {
      objectWriteUInt16(this, value, offset, true);
    }
    return offset + 2
  };

  Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value >>> 8);
      this[offset + 1] = (value & 0xff);
    } else {
      objectWriteUInt16(this, value, offset, false);
    }
    return offset + 2
  };

  Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value & 0xff);
      this[offset + 1] = (value >>> 8);
      this[offset + 2] = (value >>> 16);
      this[offset + 3] = (value >>> 24);
    } else {
      objectWriteUInt32(this, value, offset, true);
    }
    return offset + 4
  };

  Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
    if (value < 0) value = 0xffffffff + value + 1;
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value >>> 24);
      this[offset + 1] = (value >>> 16);
      this[offset + 2] = (value >>> 8);
      this[offset + 3] = (value & 0xff);
    } else {
      objectWriteUInt32(this, value, offset, false);
    }
    return offset + 4
  };

  function checkIEEE754 (buf, value, offset, ext, max, min) {
    if (offset + ext > buf.length) throw new RangeError('Index out of range')
    if (offset < 0) throw new RangeError('Index out of range')
  }

  function writeFloat (buf, value, offset, littleEndian, noAssert) {
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 4);
    }
    write(buf, value, offset, littleEndian, 23, 4);
    return offset + 4
  }

  Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
    return writeFloat(this, value, offset, true, noAssert)
  };

  Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
    return writeFloat(this, value, offset, false, noAssert)
  };

  function writeDouble (buf, value, offset, littleEndian, noAssert) {
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 8);
    }
    write(buf, value, offset, littleEndian, 52, 8);
    return offset + 8
  }

  Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
    return writeDouble(this, value, offset, true, noAssert)
  };

  Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
    return writeDouble(this, value, offset, false, noAssert)
  };

  // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
  Buffer.prototype.copy = function copy (target, targetStart, start, end) {
    if (!start) start = 0;
    if (!end && end !== 0) end = this.length;
    if (targetStart >= target.length) targetStart = target.length;
    if (!targetStart) targetStart = 0;
    if (end > 0 && end < start) end = start;

    // Copy 0 bytes; we're done
    if (end === start) return 0
    if (target.length === 0 || this.length === 0) return 0

    // Fatal error conditions
    if (targetStart < 0) {
      throw new RangeError('targetStart out of bounds')
    }
    if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
    if (end < 0) throw new RangeError('sourceEnd out of bounds')

    // Are we oob?
    if (end > this.length) end = this.length;
    if (target.length - targetStart < end - start) {
      end = target.length - targetStart + start;
    }

    var len = end - start;
    var i;

    if (this === target && start < targetStart && targetStart < end) {
      // descending copy from end
      for (i = len - 1; i >= 0; --i) {
        target[i + targetStart] = this[i + start];
      }
    } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
      // ascending copy from start
      for (i = 0; i < len; ++i) {
        target[i + targetStart] = this[i + start];
      }
    } else {
      Uint8Array.prototype.set.call(
        target,
        this.subarray(start, start + len),
        targetStart
      );
    }

    return len
  };

  // Usage:
  //    buffer.fill(number[, offset[, end]])
  //    buffer.fill(buffer[, offset[, end]])
  //    buffer.fill(string[, offset[, end]][, encoding])
  Buffer.prototype.fill = function fill (val, start, end, encoding) {
    // Handle string cases:
    if (typeof val === 'string') {
      if (typeof start === 'string') {
        encoding = start;
        start = 0;
        end = this.length;
      } else if (typeof end === 'string') {
        encoding = end;
        end = this.length;
      }
      if (val.length === 1) {
        var code = val.charCodeAt(0);
        if (code < 256) {
          val = code;
        }
      }
      if (encoding !== undefined && typeof encoding !== 'string') {
        throw new TypeError('encoding must be a string')
      }
      if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
        throw new TypeError('Unknown encoding: ' + encoding)
      }
    } else if (typeof val === 'number') {
      val = val & 255;
    }

    // Invalid ranges are not set to a default, so can range check early.
    if (start < 0 || this.length < start || this.length < end) {
      throw new RangeError('Out of range index')
    }

    if (end <= start) {
      return this
    }

    start = start >>> 0;
    end = end === undefined ? this.length : end >>> 0;

    if (!val) val = 0;

    var i;
    if (typeof val === 'number') {
      for (i = start; i < end; ++i) {
        this[i] = val;
      }
    } else {
      var bytes = internalIsBuffer(val)
        ? val
        : utf8ToBytes(new Buffer(val, encoding).toString());
      var len = bytes.length;
      for (i = 0; i < end - start; ++i) {
        this[i + start] = bytes[i % len];
      }
    }

    return this
  };

  // HELPER FUNCTIONS
  // ================

  var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;

  function base64clean (str) {
    // Node strips out invalid characters like \n and \t from the string, base64-js does not
    str = stringtrim(str).replace(INVALID_BASE64_RE, '');
    // Node converts strings with length < 2 to ''
    if (str.length < 2) return ''
    // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
    while (str.length % 4 !== 0) {
      str = str + '=';
    }
    return str
  }

  function stringtrim (str) {
    if (str.trim) return str.trim()
    return str.replace(/^\s+|\s+$/g, '')
  }

  function toHex (n) {
    if (n < 16) return '0' + n.toString(16)
    return n.toString(16)
  }

  function utf8ToBytes (string, units) {
    units = units || Infinity;
    var codePoint;
    var length = string.length;
    var leadSurrogate = null;
    var bytes = [];

    for (var i = 0; i < length; ++i) {
      codePoint = string.charCodeAt(i);

      // is surrogate component
      if (codePoint > 0xD7FF && codePoint < 0xE000) {
        // last char was a lead
        if (!leadSurrogate) {
          // no lead yet
          if (codePoint > 0xDBFF) {
            // unexpected trail
            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
            continue
          } else if (i + 1 === length) {
            // unpaired lead
            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
            continue
          }

          // valid lead
          leadSurrogate = codePoint;

          continue
        }

        // 2 leads in a row
        if (codePoint < 0xDC00) {
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          leadSurrogate = codePoint;
          continue
        }

        // valid surrogate pair
        codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
      } else if (leadSurrogate) {
        // valid bmp char, but last char was a lead
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
      }

      leadSurrogate = null;

      // encode utf8
      if (codePoint < 0x80) {
        if ((units -= 1) < 0) break
        bytes.push(codePoint);
      } else if (codePoint < 0x800) {
        if ((units -= 2) < 0) break
        bytes.push(
          codePoint >> 0x6 | 0xC0,
          codePoint & 0x3F | 0x80
        );
      } else if (codePoint < 0x10000) {
        if ((units -= 3) < 0) break
        bytes.push(
          codePoint >> 0xC | 0xE0,
          codePoint >> 0x6 & 0x3F | 0x80,
          codePoint & 0x3F | 0x80
        );
      } else if (codePoint < 0x110000) {
        if ((units -= 4) < 0) break
        bytes.push(
          codePoint >> 0x12 | 0xF0,
          codePoint >> 0xC & 0x3F | 0x80,
          codePoint >> 0x6 & 0x3F | 0x80,
          codePoint & 0x3F | 0x80
        );
      } else {
        throw new Error('Invalid code point')
      }
    }

    return bytes
  }

  function asciiToBytes (str) {
    var byteArray = [];
    for (var i = 0; i < str.length; ++i) {
      // Node's code seems to be doing this and not & 0x7F..
      byteArray.push(str.charCodeAt(i) & 0xFF);
    }
    return byteArray
  }

  function utf16leToBytes (str, units) {
    var c, hi, lo;
    var byteArray = [];
    for (var i = 0; i < str.length; ++i) {
      if ((units -= 2) < 0) break

      c = str.charCodeAt(i);
      hi = c >> 8;
      lo = c % 256;
      byteArray.push(lo);
      byteArray.push(hi);
    }

    return byteArray
  }


  function base64ToBytes (str) {
    return toByteArray(base64clean(str))
  }

  function blitBuffer (src, dst, offset, length) {
    for (var i = 0; i < length; ++i) {
      if ((i + offset >= dst.length) || (i >= src.length)) break
      dst[i + offset] = src[i];
    }
    return i
  }

  function isnan (val) {
    return val !== val // eslint-disable-line no-self-compare
  }


  // the following is from is-buffer, also by Feross Aboukhadijeh and with same lisence
  // The _isBuffer check is for Safari 5-7 support, because it's missing
  // Object.prototype.constructor. Remove this eventually
  function isBuffer(obj) {
    return obj != null && (!!obj._isBuffer || isFastBuffer(obj) || isSlowBuffer(obj))
  }

  function isFastBuffer (obj) {
    return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
  }

  // For Node v0.10 support. Remove this eventually.
  function isSlowBuffer (obj) {
    return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isFastBuffer(obj.slice(0, 0))
  }

  class CsvError extends Error {
    constructor(code, message, options, ...contexts) {
      if(Array.isArray(message)) message = message.join(' ').trim();
      super(message);
      if(Error.captureStackTrace !== undefined){
        Error.captureStackTrace(this, CsvError);
      }
      this.code = code;
      for(const context of contexts){
        for(const key in context){
          const value = context[key];
          this[key] = isBuffer(value) ? value.toString(options.encoding) : value == null ? value : JSON.parse(JSON.stringify(value));
        }
      }
    }
  }

  const is_object = function(obj){
    return (typeof obj === 'object' && obj !== null && !Array.isArray(obj));
  };

  const normalize_columns_array = function(columns){
    const normalizedColumns = [];
    for(let i = 0, l = columns.length; i < l; i++){
      const column = columns[i];
      if(column === undefined || column === null || column === false){
        normalizedColumns[i] = { disabled: true };
      }else if(typeof column === 'string'){
        normalizedColumns[i] = { name: column };
      }else if(is_object(column)){
        if(typeof column.name !== 'string'){
          throw new CsvError('CSV_OPTION_COLUMNS_MISSING_NAME', [
            'Option columns missing name:',
            `property "name" is required at position ${i}`,
            'when column is an object literal'
          ]);
        }
        normalizedColumns[i] = column;
      }else {
        throw new CsvError('CSV_INVALID_COLUMN_DEFINITION', [
          'Invalid column definition:',
          'expect a string or a literal object,',
          `got ${JSON.stringify(column)} at position ${i}`
        ]);
      }
    }
    return normalizedColumns;
  };

  class ResizeableBuffer{
    constructor(size=100){
      this.size = size;
      this.length = 0;
      this.buf = Buffer.allocUnsafe(size);
    }
    prepend(val){
      if(isBuffer(val)){
        const length = this.length + val.length;
        if(length >= this.size){
          this.resize();
          if(length >= this.size){
            throw Error('INVALID_BUFFER_STATE');
          }
        }
        const buf = this.buf;
        this.buf = Buffer.allocUnsafe(this.size);
        val.copy(this.buf, 0);
        buf.copy(this.buf, val.length);
        this.length += val.length;
      }else {
        const length = this.length++;
        if(length === this.size){
          this.resize();
        }
        const buf = this.clone();
        this.buf[0] = val;
        buf.copy(this.buf,1, 0, length);
      }
    }
    append(val){
      const length = this.length++;
      if(length === this.size){
        this.resize();
      }
      this.buf[length] = val;
    }
    clone(){
      return Buffer.from(this.buf.slice(0, this.length));
    }
    resize(){
      const length = this.length;
      this.size = this.size * 2;
      const buf = Buffer.allocUnsafe(this.size);
      this.buf.copy(buf,0, 0, length);
      this.buf = buf;
    }
    toString(encoding){
      if(encoding){
        return this.buf.slice(0, this.length).toString(encoding);
      }else {
        return Uint8Array.prototype.slice.call(this.buf.slice(0, this.length));
      }
    }
    toJSON(){
      return this.toString('utf8');
    }
    reset(){
      this.length = 0;
    }
  }

  // white space characters
  // https://en.wikipedia.org/wiki/Whitespace_character
  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions/Character_Classes#Types
  // \f\n\r\t\v\u00a0\u1680\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff
  const np = 12;
  const cr$1 = 13; // `\r`, carriage return, 0x0D in hexadécimal, 13 in decimal
  const nl$1 = 10; // `\n`, newline, 0x0A in hexadecimal, 10 in decimal
  const space = 32;
  const tab = 9;

  const init_state = function(options){
    return {
      bomSkipped: false,
      bufBytesStart: 0,
      castField: options.cast_function,
      commenting: false,
      // Current error encountered by a record
      error: undefined,
      enabled: options.from_line === 1,
      escaping: false,
      escapeIsQuote: isBuffer(options.escape) && isBuffer(options.quote) && Buffer.compare(options.escape, options.quote) === 0,
      // columns can be `false`, `true`, `Array`
      expectedRecordLength: Array.isArray(options.columns) ? options.columns.length : undefined,
      field: new ResizeableBuffer(20),
      firstLineToHeaders: options.cast_first_line_to_header,
      needMoreDataSize: Math.max(
        // Skip if the remaining buffer smaller than comment
        options.comment !== null ? options.comment.length : 0,
        // Skip if the remaining buffer can be delimiter
        ...options.delimiter.map((delimiter) => delimiter.length),
        // Skip if the remaining buffer can be escape sequence
        options.quote !== null ? options.quote.length : 0,
      ),
      previousBuf: undefined,
      quoting: false,
      stop: false,
      rawBuffer: new ResizeableBuffer(100),
      record: [],
      recordHasError: false,
      record_length: 0,
      recordDelimiterMaxLength: options.record_delimiter.length === 0 ? 0 : Math.max(...options.record_delimiter.map((v) => v.length)),
      trimChars: [Buffer.from(' ', options.encoding)[0], Buffer.from('\t', options.encoding)[0]],
      wasQuoting: false,
      wasRowDelimiter: false,
      timchars: [
        Buffer.from(Buffer.from([cr$1], 'utf8').toString(), options.encoding),
        Buffer.from(Buffer.from([nl$1], 'utf8').toString(), options.encoding),
        Buffer.from(Buffer.from([np], 'utf8').toString(), options.encoding),
        Buffer.from(Buffer.from([space], 'utf8').toString(), options.encoding),
        Buffer.from(Buffer.from([tab], 'utf8').toString(), options.encoding),
      ]
    };
  };

  const underscore = function(str){
    return str.replace(/([A-Z])/g, function(_, match){
      return '_' + match.toLowerCase();
    });
  };

  const normalize_options = function(opts){
    const options = {};
    // Merge with user options
    for(const opt in opts){
      options[underscore(opt)] = opts[opt];
    }
    // Normalize option `encoding`
    // Note: defined first because other options depends on it
    // to convert chars/strings into buffers.
    if(options.encoding === undefined || options.encoding === true){
      options.encoding = 'utf8';
    }else if(options.encoding === null || options.encoding === false){
      options.encoding = null;
    }else if(typeof options.encoding !== 'string' && options.encoding !== null){
      throw new CsvError('CSV_INVALID_OPTION_ENCODING', [
        'Invalid option encoding:',
        'encoding must be a string or null to return a buffer,',
        `got ${JSON.stringify(options.encoding)}`
      ], options);
    }
    // Normalize option `bom`
    if(options.bom === undefined || options.bom === null || options.bom === false){
      options.bom = false;
    }else if(options.bom !== true){
      throw new CsvError('CSV_INVALID_OPTION_BOM', [
        'Invalid option bom:', 'bom must be true,',
        `got ${JSON.stringify(options.bom)}`
      ], options);
    }
    // Normalize option `cast`
    options.cast_function = null;
    if(options.cast === undefined || options.cast === null || options.cast === false || options.cast === ''){
      options.cast = undefined;
    }else if(typeof options.cast === 'function'){
      options.cast_function = options.cast;
      options.cast = true;
    }else if(options.cast !== true){
      throw new CsvError('CSV_INVALID_OPTION_CAST', [
        'Invalid option cast:', 'cast must be true or a function,',
        `got ${JSON.stringify(options.cast)}`
      ], options);
    }
    // Normalize option `cast_date`
    if(options.cast_date === undefined || options.cast_date === null || options.cast_date === false || options.cast_date === ''){
      options.cast_date = false;
    }else if(options.cast_date === true){
      options.cast_date = function(value){
        const date = Date.parse(value);
        return !isNaN(date) ? new Date(date) : value;
      };
    }else if (typeof options.cast_date !== 'function'){
      throw new CsvError('CSV_INVALID_OPTION_CAST_DATE', [
        'Invalid option cast_date:', 'cast_date must be true or a function,',
        `got ${JSON.stringify(options.cast_date)}`
      ], options);
    }
    // Normalize option `columns`
    options.cast_first_line_to_header = null;
    if(options.columns === true){
      // Fields in the first line are converted as-is to columns
      options.cast_first_line_to_header = undefined;
    }else if(typeof options.columns === 'function'){
      options.cast_first_line_to_header = options.columns;
      options.columns = true;
    }else if(Array.isArray(options.columns)){
      options.columns = normalize_columns_array(options.columns);
    }else if(options.columns === undefined || options.columns === null || options.columns === false){
      options.columns = false;
    }else {
      throw new CsvError('CSV_INVALID_OPTION_COLUMNS', [
        'Invalid option columns:',
        'expect an array, a function or true,',
        `got ${JSON.stringify(options.columns)}`
      ], options);
    }
    // Normalize option `group_columns_by_name`
    if(options.group_columns_by_name === undefined || options.group_columns_by_name === null || options.group_columns_by_name === false){
      options.group_columns_by_name = false;
    }else if(options.group_columns_by_name !== true){
      throw new CsvError('CSV_INVALID_OPTION_GROUP_COLUMNS_BY_NAME', [
        'Invalid option group_columns_by_name:',
        'expect an boolean,',
        `got ${JSON.stringify(options.group_columns_by_name)}`
      ], options);
    }else if(options.columns === false){
      throw new CsvError('CSV_INVALID_OPTION_GROUP_COLUMNS_BY_NAME', [
        'Invalid option group_columns_by_name:',
        'the `columns` mode must be activated.'
      ], options);
    }
    // Normalize option `comment`
    if(options.comment === undefined || options.comment === null || options.comment === false || options.comment === ''){
      options.comment = null;
    }else {
      if(typeof options.comment === 'string'){
        options.comment = Buffer.from(options.comment, options.encoding);
      }
      if(!isBuffer(options.comment)){
        throw new CsvError('CSV_INVALID_OPTION_COMMENT', [
          'Invalid option comment:',
          'comment must be a buffer or a string,',
          `got ${JSON.stringify(options.comment)}`
        ], options);
      }
    }
    // Normalize option `comment_no_infix`
    if(options.comment_no_infix === undefined || options.comment_no_infix === null || options.comment_no_infix === false){
      options.comment_no_infix = false;
    }else if(options.comment_no_infix !== true){
      throw new CsvError('CSV_INVALID_OPTION_COMMENT', [
        'Invalid option comment_no_infix:',
        'value must be a boolean,',
        `got ${JSON.stringify(options.comment_no_infix)}`
      ], options);
    }
    // Normalize option `delimiter`
    const delimiter_json = JSON.stringify(options.delimiter);
    if(!Array.isArray(options.delimiter)) options.delimiter = [options.delimiter];
    if(options.delimiter.length === 0){
      throw new CsvError('CSV_INVALID_OPTION_DELIMITER', [
        'Invalid option delimiter:',
        'delimiter must be a non empty string or buffer or array of string|buffer,',
        `got ${delimiter_json}`
      ], options);
    }
    options.delimiter = options.delimiter.map(function(delimiter){
      if(delimiter === undefined || delimiter === null || delimiter === false){
        return Buffer.from(',', options.encoding);
      }
      if(typeof delimiter === 'string'){
        delimiter = Buffer.from(delimiter, options.encoding);
      }
      if(!isBuffer(delimiter) || delimiter.length === 0){
        throw new CsvError('CSV_INVALID_OPTION_DELIMITER', [
          'Invalid option delimiter:',
          'delimiter must be a non empty string or buffer or array of string|buffer,',
          `got ${delimiter_json}`
        ], options);
      }
      return delimiter;
    });
    // Normalize option `escape`
    if(options.escape === undefined || options.escape === true){
      options.escape = Buffer.from('"', options.encoding);
    }else if(typeof options.escape === 'string'){
      options.escape = Buffer.from(options.escape, options.encoding);
    }else if (options.escape === null || options.escape === false){
      options.escape = null;
    }
    if(options.escape !== null){
      if(!isBuffer(options.escape)){
        throw new Error(`Invalid Option: escape must be a buffer, a string or a boolean, got ${JSON.stringify(options.escape)}`);
      }
    }
    // Normalize option `from`
    if(options.from === undefined || options.from === null){
      options.from = 1;
    }else {
      if(typeof options.from === 'string' && /\d+/.test(options.from)){
        options.from = parseInt(options.from);
      }
      if(Number.isInteger(options.from)){
        if(options.from < 0){
          throw new Error(`Invalid Option: from must be a positive integer, got ${JSON.stringify(opts.from)}`);
        }
      }else {
        throw new Error(`Invalid Option: from must be an integer, got ${JSON.stringify(options.from)}`);
      }
    }
    // Normalize option `from_line`
    if(options.from_line === undefined || options.from_line === null){
      options.from_line = 1;
    }else {
      if(typeof options.from_line === 'string' && /\d+/.test(options.from_line)){
        options.from_line = parseInt(options.from_line);
      }
      if(Number.isInteger(options.from_line)){
        if(options.from_line <= 0){
          throw new Error(`Invalid Option: from_line must be a positive integer greater than 0, got ${JSON.stringify(opts.from_line)}`);
        }
      }else {
        throw new Error(`Invalid Option: from_line must be an integer, got ${JSON.stringify(opts.from_line)}`);
      }
    }
    // Normalize options `ignore_last_delimiters`
    if(options.ignore_last_delimiters === undefined || options.ignore_last_delimiters === null){
      options.ignore_last_delimiters = false;
    }else if(typeof options.ignore_last_delimiters === 'number'){
      options.ignore_last_delimiters = Math.floor(options.ignore_last_delimiters);
      if(options.ignore_last_delimiters === 0){
        options.ignore_last_delimiters = false;
      }
    }else if(typeof options.ignore_last_delimiters !== 'boolean'){
      throw new CsvError('CSV_INVALID_OPTION_IGNORE_LAST_DELIMITERS', [
        'Invalid option `ignore_last_delimiters`:',
        'the value must be a boolean value or an integer,',
        `got ${JSON.stringify(options.ignore_last_delimiters)}`
      ], options);
    }
    if(options.ignore_last_delimiters === true && options.columns === false){
      throw new CsvError('CSV_IGNORE_LAST_DELIMITERS_REQUIRES_COLUMNS', [
        'The option `ignore_last_delimiters`',
        'requires the activation of the `columns` option'
      ], options);
    }
    // Normalize option `info`
    if(options.info === undefined || options.info === null || options.info === false){
      options.info = false;
    }else if(options.info !== true){
      throw new Error(`Invalid Option: info must be true, got ${JSON.stringify(options.info)}`);
    }
    // Normalize option `max_record_size`
    if(options.max_record_size === undefined || options.max_record_size === null || options.max_record_size === false){
      options.max_record_size = 0;
    }else if(Number.isInteger(options.max_record_size) && options.max_record_size >= 0);else if(typeof options.max_record_size === 'string' && /\d+/.test(options.max_record_size)){
      options.max_record_size = parseInt(options.max_record_size);
    }else {
      throw new Error(`Invalid Option: max_record_size must be a positive integer, got ${JSON.stringify(options.max_record_size)}`);
    }
    // Normalize option `objname`
    if(options.objname === undefined || options.objname === null || options.objname === false){
      options.objname = undefined;
    }else if(isBuffer(options.objname)){
      if(options.objname.length === 0){
        throw new Error(`Invalid Option: objname must be a non empty buffer`);
      }
      if(options.encoding === null);else {
        options.objname = options.objname.toString(options.encoding);
      }
    }else if(typeof options.objname === 'string'){
      if(options.objname.length === 0){
        throw new Error(`Invalid Option: objname must be a non empty string`);
      }
      // Great, nothing to do
    }else if(typeof options.objname === 'number');else {
      throw new Error(`Invalid Option: objname must be a string or a buffer, got ${options.objname}`);
    }
    if(options.objname !== undefined){
      if(typeof options.objname === 'number'){
        if(options.columns !== false){
          throw Error('Invalid Option: objname index cannot be combined with columns or be defined as a field');
        }
      }else { // A string or a buffer
        if(options.columns === false){
          throw Error('Invalid Option: objname field must be combined with columns or be defined as an index');
        }
      }
    }
    // Normalize option `on_record`
    if(options.on_record === undefined || options.on_record === null){
      options.on_record = undefined;
    }else if(typeof options.on_record !== 'function'){
      throw new CsvError('CSV_INVALID_OPTION_ON_RECORD', [
        'Invalid option `on_record`:',
        'expect a function,',
        `got ${JSON.stringify(options.on_record)}`
      ], options);
    }
    // Normalize option `on_skip`
    // options.on_skip ??= (err, chunk) => {
    //   this.emit('skip', err, chunk);
    // };
    if(options.on_skip !== undefined && options.on_skip !== null && typeof options.on_skip !== 'function'){
      throw new Error(`Invalid Option: on_skip must be a function, got ${JSON.stringify(options.on_skip)}`);
    }
    // Normalize option `quote`
    if(options.quote === null || options.quote === false || options.quote === ''){
      options.quote = null;
    }else {
      if(options.quote === undefined || options.quote === true){
        options.quote = Buffer.from('"', options.encoding);
      }else if(typeof options.quote === 'string'){
        options.quote = Buffer.from(options.quote, options.encoding);
      }
      if(!isBuffer(options.quote)){
        throw new Error(`Invalid Option: quote must be a buffer or a string, got ${JSON.stringify(options.quote)}`);
      }
    }
    // Normalize option `raw`
    if(options.raw === undefined || options.raw === null || options.raw === false){
      options.raw = false;
    }else if(options.raw !== true){
      throw new Error(`Invalid Option: raw must be true, got ${JSON.stringify(options.raw)}`);
    }
    // Normalize option `record_delimiter`
    if(options.record_delimiter === undefined){
      options.record_delimiter = [];
    }else if(typeof options.record_delimiter === 'string' || isBuffer(options.record_delimiter)){
      if(options.record_delimiter.length === 0){
        throw new CsvError('CSV_INVALID_OPTION_RECORD_DELIMITER', [
          'Invalid option `record_delimiter`:',
          'value must be a non empty string or buffer,',
          `got ${JSON.stringify(options.record_delimiter)}`
        ], options);
      }
      options.record_delimiter = [options.record_delimiter];
    }else if(!Array.isArray(options.record_delimiter)){
      throw new CsvError('CSV_INVALID_OPTION_RECORD_DELIMITER', [
        'Invalid option `record_delimiter`:',
        'value must be a string, a buffer or array of string|buffer,',
        `got ${JSON.stringify(options.record_delimiter)}`
      ], options);
    }
    options.record_delimiter = options.record_delimiter.map(function(rd, i){
      if(typeof rd !== 'string' && ! isBuffer(rd)){
        throw new CsvError('CSV_INVALID_OPTION_RECORD_DELIMITER', [
          'Invalid option `record_delimiter`:',
          'value must be a string, a buffer or array of string|buffer',
          `at index ${i},`,
          `got ${JSON.stringify(rd)}`
        ], options);
      }else if(rd.length === 0){
        throw new CsvError('CSV_INVALID_OPTION_RECORD_DELIMITER', [
          'Invalid option `record_delimiter`:',
          'value must be a non empty string or buffer',
          `at index ${i},`,
          `got ${JSON.stringify(rd)}`
        ], options);
      }
      if(typeof rd === 'string'){
        rd = Buffer.from(rd, options.encoding);
      }
      return rd;
    });
    // Normalize option `relax_column_count`
    if(typeof options.relax_column_count === 'boolean');else if(options.relax_column_count === undefined || options.relax_column_count === null){
      options.relax_column_count = false;
    }else {
      throw new Error(`Invalid Option: relax_column_count must be a boolean, got ${JSON.stringify(options.relax_column_count)}`);
    }
    if(typeof options.relax_column_count_less === 'boolean');else if(options.relax_column_count_less === undefined || options.relax_column_count_less === null){
      options.relax_column_count_less = false;
    }else {
      throw new Error(`Invalid Option: relax_column_count_less must be a boolean, got ${JSON.stringify(options.relax_column_count_less)}`);
    }
    if(typeof options.relax_column_count_more === 'boolean');else if(options.relax_column_count_more === undefined || options.relax_column_count_more === null){
      options.relax_column_count_more = false;
    }else {
      throw new Error(`Invalid Option: relax_column_count_more must be a boolean, got ${JSON.stringify(options.relax_column_count_more)}`);
    }
    // Normalize option `relax_quotes`
    if(typeof options.relax_quotes === 'boolean');else if(options.relax_quotes === undefined || options.relax_quotes === null){
      options.relax_quotes = false;
    }else {
      throw new Error(`Invalid Option: relax_quotes must be a boolean, got ${JSON.stringify(options.relax_quotes)}`);
    }
    // Normalize option `skip_empty_lines`
    if(typeof options.skip_empty_lines === 'boolean');else if(options.skip_empty_lines === undefined || options.skip_empty_lines === null){
      options.skip_empty_lines = false;
    }else {
      throw new Error(`Invalid Option: skip_empty_lines must be a boolean, got ${JSON.stringify(options.skip_empty_lines)}`);
    }
    // Normalize option `skip_records_with_empty_values`
    if(typeof options.skip_records_with_empty_values === 'boolean');else if(options.skip_records_with_empty_values === undefined || options.skip_records_with_empty_values === null){
      options.skip_records_with_empty_values = false;
    }else {
      throw new Error(`Invalid Option: skip_records_with_empty_values must be a boolean, got ${JSON.stringify(options.skip_records_with_empty_values)}`);
    }
    // Normalize option `skip_records_with_error`
    if(typeof options.skip_records_with_error === 'boolean');else if(options.skip_records_with_error === undefined || options.skip_records_with_error === null){
      options.skip_records_with_error = false;
    }else {
      throw new Error(`Invalid Option: skip_records_with_error must be a boolean, got ${JSON.stringify(options.skip_records_with_error)}`);
    }
    // Normalize option `rtrim`
    if(options.rtrim === undefined || options.rtrim === null || options.rtrim === false){
      options.rtrim = false;
    }else if(options.rtrim !== true){
      throw new Error(`Invalid Option: rtrim must be a boolean, got ${JSON.stringify(options.rtrim)}`);
    }
    // Normalize option `ltrim`
    if(options.ltrim === undefined || options.ltrim === null || options.ltrim === false){
      options.ltrim = false;
    }else if(options.ltrim !== true){
      throw new Error(`Invalid Option: ltrim must be a boolean, got ${JSON.stringify(options.ltrim)}`);
    }
    // Normalize option `trim`
    if(options.trim === undefined || options.trim === null || options.trim === false){
      options.trim = false;
    }else if(options.trim !== true){
      throw new Error(`Invalid Option: trim must be a boolean, got ${JSON.stringify(options.trim)}`);
    }
    // Normalize options `trim`, `ltrim` and `rtrim`
    if(options.trim === true && opts.ltrim !== false){
      options.ltrim = true;
    }else if(options.ltrim !== true){
      options.ltrim = false;
    }
    if(options.trim === true && opts.rtrim !== false){
      options.rtrim = true;
    }else if(options.rtrim !== true){
      options.rtrim = false;
    }
    // Normalize option `to`
    if(options.to === undefined || options.to === null){
      options.to = -1;
    }else {
      if(typeof options.to === 'string' && /\d+/.test(options.to)){
        options.to = parseInt(options.to);
      }
      if(Number.isInteger(options.to)){
        if(options.to <= 0){
          throw new Error(`Invalid Option: to must be a positive integer greater than 0, got ${JSON.stringify(opts.to)}`);
        }
      }else {
        throw new Error(`Invalid Option: to must be an integer, got ${JSON.stringify(opts.to)}`);
      }
    }
    // Normalize option `to_line`
    if(options.to_line === undefined || options.to_line === null){
      options.to_line = -1;
    }else {
      if(typeof options.to_line === 'string' && /\d+/.test(options.to_line)){
        options.to_line = parseInt(options.to_line);
      }
      if(Number.isInteger(options.to_line)){
        if(options.to_line <= 0){
          throw new Error(`Invalid Option: to_line must be a positive integer greater than 0, got ${JSON.stringify(opts.to_line)}`);
        }
      }else {
        throw new Error(`Invalid Option: to_line must be an integer, got ${JSON.stringify(opts.to_line)}`);
      }
    }
    return options;
  };

  const isRecordEmpty = function(record){
    return record.every((field) => field == null || field.toString && field.toString().trim() === '');
  };

  const cr = 13; // `\r`, carriage return, 0x0D in hexadécimal, 13 in decimal
  const nl = 10; // `\n`, newline, 0x0A in hexadecimal, 10 in decimal

  const boms = {
    // Note, the following are equals:
    // Buffer.from("\ufeff")
    // Buffer.from([239, 187, 191])
    // Buffer.from('EFBBBF', 'hex')
    'utf8': Buffer.from([239, 187, 191]),
    // Note, the following are equals:
    // Buffer.from "\ufeff", 'utf16le
    // Buffer.from([255, 254])
    'utf16le': Buffer.from([255, 254])
  };

  const transform = function(original_options = {}) {
    const info = {
      bytes: 0,
      comment_lines: 0,
      empty_lines: 0,
      invalid_field_length: 0,
      lines: 1,
      records: 0
    };
    const options = normalize_options(original_options);
    return {
      info: info,
      original_options: original_options,
      options: options,
      state: init_state(options),
      __needMoreData: function(i, bufLen, end){
        if(end) return false;
        const {encoding, escape, quote} = this.options;
        const {quoting, needMoreDataSize, recordDelimiterMaxLength} = this.state;
        const numOfCharLeft = bufLen - i - 1;
        const requiredLength = Math.max(
          needMoreDataSize,
          // Skip if the remaining buffer smaller than record delimiter
          // If "record_delimiter" is yet to be discovered:
          // 1. It is equals to `[]` and "recordDelimiterMaxLength" equals `0`
          // 2. We set the length to windows line ending in the current encoding
          // Note, that encoding is known from user or bom discovery at that point
          // recordDelimiterMaxLength,
          recordDelimiterMaxLength === 0 ? Buffer.from('\r\n', encoding).length : recordDelimiterMaxLength,
          // Skip if remaining buffer can be an escaped quote
          quoting ? ((escape === null ? 0 : escape.length) + quote.length) : 0,
          // Skip if remaining buffer can be record delimiter following the closing quote
          quoting ? (quote.length + recordDelimiterMaxLength) : 0,
        );
        return numOfCharLeft < requiredLength;
      },
      // Central parser implementation
      parse: function(nextBuf, end, push, close){
        const {bom, comment_no_infix, encoding, from_line, ltrim, max_record_size,raw, relax_quotes, rtrim, skip_empty_lines, to, to_line} = this.options;
        let {comment, escape, quote, record_delimiter} = this.options;
        const {bomSkipped, previousBuf, rawBuffer, escapeIsQuote} = this.state;
        let buf;
        if(previousBuf === undefined){
          if(nextBuf === undefined){
            // Handle empty string
            close();
            return;
          }else {
            buf = nextBuf;
          }
        }else if(previousBuf !== undefined && nextBuf === undefined){
          buf = previousBuf;
        }else {
          buf = Buffer.concat([previousBuf, nextBuf]);
        }
        // Handle UTF BOM
        if(bomSkipped === false){
          if(bom === false){
            this.state.bomSkipped = true;
          }else if(buf.length < 3){
            // No enough data
            if(end === false){
              // Wait for more data
              this.state.previousBuf = buf;
              return;
            }
          }else {
            for(const encoding in boms){
              if(boms[encoding].compare(buf, 0, boms[encoding].length) === 0){
                // Skip BOM
                const bomLength = boms[encoding].length;
                this.state.bufBytesStart += bomLength;
                buf = buf.slice(bomLength);
                // Renormalize original options with the new encoding
                this.options = normalize_options({...this.original_options, encoding: encoding});
                // Options will re-evaluate the Buffer with the new encoding
                ({comment, escape, quote } = this.options);
                break;
              }
            }
            this.state.bomSkipped = true;
          }
        }
        const bufLen = buf.length;
        let pos;
        for(pos = 0; pos < bufLen; pos++){
          // Ensure we get enough space to look ahead
          // There should be a way to move this out of the loop
          if(this.__needMoreData(pos, bufLen, end)){
            break;
          }
          if(this.state.wasRowDelimiter === true){
            this.info.lines++;
            this.state.wasRowDelimiter = false;
          }
          if(to_line !== -1 && this.info.lines > to_line){
            this.state.stop = true;
            close();
            return;
          }
          // Auto discovery of record_delimiter, unix, mac and windows supported
          if(this.state.quoting === false && record_delimiter.length === 0){
            const record_delimiterCount = this.__autoDiscoverRecordDelimiter(buf, pos);
            if(record_delimiterCount){
              record_delimiter = this.options.record_delimiter;
            }
          }
          const chr = buf[pos];
          if(raw === true){
            rawBuffer.append(chr);
          }
          if((chr === cr || chr === nl) && this.state.wasRowDelimiter === false){
            this.state.wasRowDelimiter = true;
          }
          // Previous char was a valid escape char
          // treat the current char as a regular char
          if(this.state.escaping === true){
            this.state.escaping = false;
          }else {
            // Escape is only active inside quoted fields
            // We are quoting, the char is an escape chr and there is a chr to escape
            // if(escape !== null && this.state.quoting === true && chr === escape && pos + 1 < bufLen){
            if(escape !== null && this.state.quoting === true && this.__isEscape(buf, pos, chr) && pos + escape.length < bufLen){
              if(escapeIsQuote){
                if(this.__isQuote(buf, pos+escape.length)){
                  this.state.escaping = true;
                  pos += escape.length - 1;
                  continue;
                }
              }else {
                this.state.escaping = true;
                pos += escape.length - 1;
                continue;
              }
            }
            // Not currently escaping and chr is a quote
            // TODO: need to compare bytes instead of single char
            if(this.state.commenting === false && this.__isQuote(buf, pos)){
              if(this.state.quoting === true){
                const nextChr = buf[pos+quote.length];
                const isNextChrTrimable = rtrim && this.__isCharTrimable(buf, pos+quote.length);
                const isNextChrComment = comment !== null && this.__compareBytes(comment, buf, pos+quote.length, nextChr);
                const isNextChrDelimiter = this.__isDelimiter(buf, pos+quote.length, nextChr);
                const isNextChrRecordDelimiter = record_delimiter.length === 0 ? this.__autoDiscoverRecordDelimiter(buf, pos+quote.length) : this.__isRecordDelimiter(nextChr, buf, pos+quote.length);
                // Escape a quote
                // Treat next char as a regular character
                if(escape !== null && this.__isEscape(buf, pos, chr) && this.__isQuote(buf, pos + escape.length)){
                  pos += escape.length - 1;
                }else if(!nextChr || isNextChrDelimiter || isNextChrRecordDelimiter || isNextChrComment || isNextChrTrimable){
                  this.state.quoting = false;
                  this.state.wasQuoting = true;
                  pos += quote.length - 1;
                  continue;
                }else if(relax_quotes === false){
                  const err = this.__error(
                    new CsvError('CSV_INVALID_CLOSING_QUOTE', [
                      'Invalid Closing Quote:',
                      `got "${String.fromCharCode(nextChr)}"`,
                      `at line ${this.info.lines}`,
                      'instead of delimiter, record delimiter, trimable character',
                      '(if activated) or comment',
                    ], this.options, this.__infoField())
                  );
                  if(err !== undefined) return err;
                }else {
                  this.state.quoting = false;
                  this.state.wasQuoting = true;
                  this.state.field.prepend(quote);
                  pos += quote.length - 1;
                }
              }else {
                if(this.state.field.length !== 0){
                  // In relax_quotes mode, treat opening quote preceded by chrs as regular
                  if(relax_quotes === false){
                    const info = this.__infoField();
                    const bom = Object.keys(boms).map(b => boms[b].equals(this.state.field.toString()) ? b : false).filter(Boolean)[0];
                    const err = this.__error(
                      new CsvError('INVALID_OPENING_QUOTE', [
                        'Invalid Opening Quote:',
                        `a quote is found on field ${JSON.stringify(info.column)} at line ${info.lines}, value is ${JSON.stringify(this.state.field.toString(encoding))}`,
                        bom ? `(${bom} bom)` : undefined
                      ], this.options, info, {
                        field: this.state.field,
                      })
                    );
                    if(err !== undefined) return err;
                  }
                }else {
                  this.state.quoting = true;
                  pos += quote.length - 1;
                  continue;
                }
              }
            }
            if(this.state.quoting === false){
              const recordDelimiterLength = this.__isRecordDelimiter(chr, buf, pos);
              if(recordDelimiterLength !== 0){
                // Do not emit comments which take a full line
                const skipCommentLine = this.state.commenting && (this.state.wasQuoting === false && this.state.record.length === 0 && this.state.field.length === 0);
                if(skipCommentLine){
                  this.info.comment_lines++;
                  // Skip full comment line
                }else {
                  // Activate records emition if above from_line
                  if(this.state.enabled === false && this.info.lines + (this.state.wasRowDelimiter === true ? 1: 0) >= from_line){
                    this.state.enabled = true;
                    this.__resetField();
                    this.__resetRecord();
                    pos += recordDelimiterLength - 1;
                    continue;
                  }
                  // Skip if line is empty and skip_empty_lines activated
                  if(skip_empty_lines === true && this.state.wasQuoting === false && this.state.record.length === 0 && this.state.field.length === 0){
                    this.info.empty_lines++;
                    pos += recordDelimiterLength - 1;
                    continue;
                  }
                  this.info.bytes = this.state.bufBytesStart + pos;
                  const errField = this.__onField();
                  if(errField !== undefined) return errField;
                  this.info.bytes = this.state.bufBytesStart + pos + recordDelimiterLength;
                  const errRecord = this.__onRecord(push);
                  if(errRecord !== undefined) return errRecord;
                  if(to !== -1 && this.info.records >= to){
                    this.state.stop = true;
                    close();
                    return;
                  }
                }
                this.state.commenting = false;
                pos += recordDelimiterLength - 1;
                continue;
              }
              if(this.state.commenting){
                continue;
              }
              if(comment !== null && (comment_no_infix === false || (this.state.record.length === 0 && this.state.field.length === 0))) {
                const commentCount = this.__compareBytes(comment, buf, pos, chr);
                if(commentCount !== 0){
                  this.state.commenting = true;
                  continue;
                }
              }
              const delimiterLength = this.__isDelimiter(buf, pos, chr);
              if(delimiterLength !== 0){
                this.info.bytes = this.state.bufBytesStart + pos;
                const errField = this.__onField();
                if(errField !== undefined) return errField;
                pos += delimiterLength - 1;
                continue;
              }
            }
          }
          if(this.state.commenting === false){
            if(max_record_size !== 0 && this.state.record_length + this.state.field.length > max_record_size){
              return this.__error(
                new CsvError('CSV_MAX_RECORD_SIZE', [
                  'Max Record Size:',
                  'record exceed the maximum number of tolerated bytes',
                  `of ${max_record_size}`,
                  `at line ${this.info.lines}`,
                ], this.options, this.__infoField())
              );
            }
          }
          const lappend = ltrim === false || this.state.quoting === true || this.state.field.length !== 0 || !this.__isCharTrimable(buf, pos);
          // rtrim in non quoting is handle in __onField
          const rappend = rtrim === false || this.state.wasQuoting === false;
          if(lappend === true && rappend === true){
            this.state.field.append(chr);
          }else if(rtrim === true && !this.__isCharTrimable(buf, pos)){
            return this.__error(
              new CsvError('CSV_NON_TRIMABLE_CHAR_AFTER_CLOSING_QUOTE', [
                'Invalid Closing Quote:',
                'found non trimable byte after quote',
                `at line ${this.info.lines}`,
              ], this.options, this.__infoField())
            );
          }else {
            if(lappend === false){
              pos += this.__isCharTrimable(buf, pos) - 1;
            }
            continue;
          }
        }
        if(end === true){
          // Ensure we are not ending in a quoting state
          if(this.state.quoting === true){
            const err = this.__error(
              new CsvError('CSV_QUOTE_NOT_CLOSED', [
                'Quote Not Closed:',
                `the parsing is finished with an opening quote at line ${this.info.lines}`,
              ], this.options, this.__infoField())
            );
            if(err !== undefined) return err;
          }else {
            // Skip last line if it has no characters
            if(this.state.wasQuoting === true || this.state.record.length !== 0 || this.state.field.length !== 0){
              this.info.bytes = this.state.bufBytesStart + pos;
              const errField = this.__onField();
              if(errField !== undefined) return errField;
              const errRecord = this.__onRecord(push);
              if(errRecord !== undefined) return errRecord;
            }else if(this.state.wasRowDelimiter === true){
              this.info.empty_lines++;
            }else if(this.state.commenting === true){
              this.info.comment_lines++;
            }
          }
        }else {
          this.state.bufBytesStart += pos;
          this.state.previousBuf = buf.slice(pos);
        }
        if(this.state.wasRowDelimiter === true){
          this.info.lines++;
          this.state.wasRowDelimiter = false;
        }
      },
      __onRecord: function(push){
        const {columns, group_columns_by_name, encoding, info, from, relax_column_count, relax_column_count_less, relax_column_count_more, raw, skip_records_with_empty_values} = this.options;
        const {enabled, record} = this.state;
        if(enabled === false){
          return this.__resetRecord();
        }
        // Convert the first line into column names
        const recordLength = record.length;
        if(columns === true){
          if(skip_records_with_empty_values === true && isRecordEmpty(record)){
            this.__resetRecord();
            return;
          }
          return this.__firstLineToColumns(record);
        }
        if(columns === false && this.info.records === 0){
          this.state.expectedRecordLength = recordLength;
        }
        if(recordLength !== this.state.expectedRecordLength){
          const err = columns === false ?
            new CsvError('CSV_RECORD_INCONSISTENT_FIELDS_LENGTH', [
              'Invalid Record Length:',
              `expect ${this.state.expectedRecordLength},`,
              `got ${recordLength} on line ${this.info.lines}`,
            ], this.options, this.__infoField(), {
              record: record,
            })
            :
            new CsvError('CSV_RECORD_INCONSISTENT_COLUMNS', [
              'Invalid Record Length:',
              `columns length is ${columns.length},`, // rename columns
              `got ${recordLength} on line ${this.info.lines}`,
            ], this.options, this.__infoField(), {
              record: record,
            });
          if(relax_column_count === true ||
            (relax_column_count_less === true && recordLength < this.state.expectedRecordLength) ||
            (relax_column_count_more === true && recordLength > this.state.expectedRecordLength)){
            this.info.invalid_field_length++;
            this.state.error = err;
          // Error is undefined with skip_records_with_error
          }else {
            const finalErr = this.__error(err);
            if(finalErr) return finalErr;
          }
        }
        if(skip_records_with_empty_values === true && isRecordEmpty(record)){
          this.__resetRecord();
          return;
        }
        if(this.state.recordHasError === true){
          this.__resetRecord();
          this.state.recordHasError = false;
          return;
        }
        this.info.records++;
        if(from === 1 || this.info.records >= from){
          const {objname} = this.options;
          // With columns, records are object
          if(columns !== false){
            const obj = {};
            // Transform record array to an object
            for(let i = 0, l = record.length; i < l; i++){
              if(columns[i] === undefined || columns[i].disabled) continue;
              // Turn duplicate columns into an array
              if (group_columns_by_name === true && obj[columns[i].name] !== undefined) {
                if (Array.isArray(obj[columns[i].name])) {
                  obj[columns[i].name] = obj[columns[i].name].concat(record[i]);
                } else {
                  obj[columns[i].name] = [obj[columns[i].name], record[i]];
                }
              } else {
                obj[columns[i].name] = record[i];
              }
            }
            // Without objname (default)
            if(raw === true || info === true){
              const extRecord = Object.assign(
                {record: obj},
                (raw === true ? {raw: this.state.rawBuffer.toString(encoding)}: {}),
                (info === true ? {info: this.__infoRecord()}: {})
              );
              const err = this.__push(
                objname === undefined ? extRecord : [obj[objname], extRecord]
                , push);
              if(err){
                return err;
              }
            }else {
              const err = this.__push(
                objname === undefined ? obj : [obj[objname], obj]
                , push);
              if(err){
                return err;
              }
            }
          // Without columns, records are array
          }else {
            if(raw === true || info === true){
              const extRecord = Object.assign(
                {record: record},
                raw === true ? {raw: this.state.rawBuffer.toString(encoding)}: {},
                info === true ? {info: this.__infoRecord()}: {}
              );
              const err = this.__push(
                objname === undefined ? extRecord : [record[objname], extRecord]
                , push);
              if(err){
                return err;
              }
            }else {
              const err = this.__push(
                objname === undefined ? record : [record[objname], record]
                , push);
              if(err){
                return err;
              }
            }
          }
        }
        this.__resetRecord();
      },
      __firstLineToColumns: function(record){
        const {firstLineToHeaders} = this.state;
        try{
          const headers = firstLineToHeaders === undefined ? record : firstLineToHeaders.call(null, record);
          if(!Array.isArray(headers)){
            return this.__error(
              new CsvError('CSV_INVALID_COLUMN_MAPPING', [
                'Invalid Column Mapping:',
                'expect an array from column function,',
                `got ${JSON.stringify(headers)}`
              ], this.options, this.__infoField(), {
                headers: headers,
              })
            );
          }
          const normalizedHeaders = normalize_columns_array(headers);
          this.state.expectedRecordLength = normalizedHeaders.length;
          this.options.columns = normalizedHeaders;
          this.__resetRecord();
          return;
        }catch(err){
          return err;
        }
      },
      __resetRecord: function(){
        if(this.options.raw === true){
          this.state.rawBuffer.reset();
        }
        this.state.error = undefined;
        this.state.record = [];
        this.state.record_length = 0;
      },
      __onField: function(){
        const {cast, encoding, rtrim, max_record_size} = this.options;
        const {enabled, wasQuoting} = this.state;
        // Short circuit for the from_line options
        if(enabled === false){
          return this.__resetField();
        }
        let field = this.state.field.toString(encoding);
        if(rtrim === true && wasQuoting === false){
          field = field.trimRight();
        }
        if(cast === true){
          const [err, f] = this.__cast(field);
          if(err !== undefined) return err;
          field = f;
        }
        this.state.record.push(field);
        // Increment record length if record size must not exceed a limit
        if(max_record_size !== 0 && typeof field === 'string'){
          this.state.record_length += field.length;
        }
        this.__resetField();
      },
      __resetField: function(){
        this.state.field.reset();
        this.state.wasQuoting = false;
      },
      __push: function(record, push){
        const {on_record} = this.options;
        if(on_record !== undefined){
          const info = this.__infoRecord();
          try{
            record = on_record.call(null, record, info);
          }catch(err){
            return err;
          }
          if(record === undefined || record === null){ return; }
        }
        push(record);
      },
      // Return a tuple with the error and the casted value
      __cast: function(field){
        const {columns, relax_column_count} = this.options;
        const isColumns = Array.isArray(columns);
        // Dont loose time calling cast
        // because the final record is an object
        // and this field can't be associated to a key present in columns
        if(isColumns === true && relax_column_count && this.options.columns.length <= this.state.record.length){
          return [undefined, undefined];
        }
        if(this.state.castField !== null){
          try{
            const info = this.__infoField();
            return [undefined, this.state.castField.call(null, field, info)];
          }catch(err){
            return [err];
          }
        }
        if(this.__isFloat(field)){
          return [undefined, parseFloat(field)];
        }else if(this.options.cast_date !== false){
          const info = this.__infoField();
          return [undefined, this.options.cast_date.call(null, field, info)];
        }
        return [undefined, field];
      },
      // Helper to test if a character is a space or a line delimiter
      __isCharTrimable: function(buf, pos){
        const isTrim = (buf, pos) => {
          const {timchars} = this.state;
          loop1: for(let i = 0; i < timchars.length; i++){
            const timchar = timchars[i];
            for(let j = 0; j < timchar.length; j++){
              if(timchar[j] !== buf[pos+j]) continue loop1;
            }
            return timchar.length;
          }
          return 0;
        };
        return isTrim(buf, pos);
      },
      // Keep it in case we implement the `cast_int` option
      // __isInt(value){
      //   // return Number.isInteger(parseInt(value))
      //   // return !isNaN( parseInt( obj ) );
      //   return /^(\-|\+)?[1-9][0-9]*$/.test(value)
      // }
      __isFloat: function(value){
        return (value - parseFloat(value) + 1) >= 0; // Borrowed from jquery
      },
      __compareBytes: function(sourceBuf, targetBuf, targetPos, firstByte){
        if(sourceBuf[0] !== firstByte) return 0;
        const sourceLength = sourceBuf.length;
        for(let i = 1; i < sourceLength; i++){
          if(sourceBuf[i] !== targetBuf[targetPos+i]) return 0;
        }
        return sourceLength;
      },
      __isDelimiter: function(buf, pos, chr){
        const {delimiter, ignore_last_delimiters} = this.options;
        if(ignore_last_delimiters === true && this.state.record.length === this.options.columns.length - 1){
          return 0;
        }else if(ignore_last_delimiters !== false && typeof ignore_last_delimiters === 'number' && this.state.record.length === ignore_last_delimiters - 1){
          return 0;
        }
        loop1: for(let i = 0; i < delimiter.length; i++){
          const del = delimiter[i];
          if(del[0] === chr){
            for(let j = 1; j < del.length; j++){
              if(del[j] !== buf[pos+j]) continue loop1;
            }
            return del.length;
          }
        }
        return 0;
      },
      __isRecordDelimiter: function(chr, buf, pos){
        const {record_delimiter} = this.options;
        const recordDelimiterLength = record_delimiter.length;
        loop1: for(let i = 0; i < recordDelimiterLength; i++){
          const rd = record_delimiter[i];
          const rdLength = rd.length;
          if(rd[0] !== chr){
            continue;
          }
          for(let j = 1; j < rdLength; j++){
            if(rd[j] !== buf[pos+j]){
              continue loop1;
            }
          }
          return rd.length;
        }
        return 0;
      },
      __isEscape: function(buf, pos, chr){
        const {escape} = this.options;
        if(escape === null) return false;
        const l = escape.length;
        if(escape[0] === chr){
          for(let i = 0; i < l; i++){
            if(escape[i] !== buf[pos+i]){
              return false;
            }
          }
          return true;
        }
        return false;
      },
      __isQuote: function(buf, pos){
        const {quote} = this.options;
        if(quote === null) return false;
        const l = quote.length;
        for(let i = 0; i < l; i++){
          if(quote[i] !== buf[pos+i]){
            return false;
          }
        }
        return true;
      },
      __autoDiscoverRecordDelimiter: function(buf, pos){
        const { encoding } = this.options;
        // Note, we don't need to cache this information in state,
        // It is only called on the first line until we find out a suitable
        // record delimiter.
        const rds = [
          // Important, the windows line ending must be before mac os 9
          Buffer.from('\r\n', encoding),
          Buffer.from('\n', encoding),
          Buffer.from('\r', encoding),
        ];
        loop: for(let i = 0; i < rds.length; i++){
          const l = rds[i].length;
          for(let j = 0; j < l; j++){
            if(rds[i][j] !== buf[pos + j]){
              continue loop;
            }
          }
          this.options.record_delimiter.push(rds[i]);
          this.state.recordDelimiterMaxLength = rds[i].length;
          return rds[i].length;
        }
        return 0;
      },
      __error: function(msg){
        const {encoding, raw, skip_records_with_error} = this.options;
        const err = typeof msg === 'string' ? new Error(msg) : msg;
        if(skip_records_with_error){
          this.state.recordHasError = true;
          if(this.options.on_skip !== undefined){
            this.options.on_skip(err, raw ? this.state.rawBuffer.toString(encoding) : undefined);
          }
          // this.emit('skip', err, raw ? this.state.rawBuffer.toString(encoding) : undefined);
          return undefined;
        }else {
          return err;
        }
      },
      __infoDataSet: function(){
        return {
          ...this.info,
          columns: this.options.columns
        };
      },
      __infoRecord: function(){
        const {columns, raw, encoding} = this.options;
        return {
          ...this.__infoDataSet(),
          error: this.state.error,
          header: columns === true,
          index: this.state.record.length,
          raw: raw ? this.state.rawBuffer.toString(encoding) : undefined
        };
      },
      __infoField: function(){
        const {columns} = this.options;
        const isColumns = Array.isArray(columns);
        return {
          ...this.__infoRecord(),
          column: isColumns === true ?
            (columns.length > this.state.record.length ?
              columns[this.state.record.length].name :
              null
            ) :
            this.state.record.length,
          quoting: this.state.wasQuoting,
        };
      }
    };
  };

  const parse = function(data, opts={}){
    if(typeof data === 'string'){
      data = Buffer.from(data);
    }
    const records = opts && opts.objname ? {} : [];
    const parser = transform(opts);
    const push = (record) => {
      if(parser.options.objname === undefined)
        records.push(record);
      else {
        records[record[0]] = record[1];
      }
    };
    const close = () => {};
    const err1 = parser.parse(data, false, push, close);
    if(err1 !== undefined) throw err1;
    const err2 = parser.parse(undefined, true, push, close);
    if(err2 !== undefined) throw err2;
    return records;
  };

  
/*
https://csv.js.org/parse/

The MIT License (MIT)

Copyright (c) 2010 Adaltas

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

*/

      class DatasetEmbed {

    static bindToCodeBlocks () {
      const maybe_csv_blocks = document.querySelectorAll('pre > code[class^=language-csv]');
      const maybe_json_blocks = document.querySelectorAll('pre > code[class^=language-json]');
      [...maybe_csv_blocks, ...maybe_json_blocks].forEach((maybe_block) => {
        const [format, name] = maybe_block.className.replace('language-','').split('=');
        if (['csv','json'].includes(format) && name) {
          new DatasetEmbed(maybe_block, format, name);
        }
      });
    }

    constructor (el, format, name) {
      this.el = el;
      const raw = el.textContent;
      let value;
      if (format === "csv") {
        value = parseCSV(raw);
      } else if (format === "json") {
        value = JSON.parse(raw);
      }
      this.variable = new Variable(name, value, { is_dataset: true });

      this._format = format;
      this._name = name;
      this.els = {};
      this._renderInitial();
      registerEmbed(this);
    }

    _renderInitial () {
      const old_el = this.el;
      const raw_initial = this.el.textContent;
      this.el = document.createElement('div');
      this.el.classList.add('DatasetEmbed');
      old_el.parentNode.parentNode.insertBefore(this.el, old_el.parentNode);
      old_el.parentNode.remove();
      this.els.data = document.createElement('div');
      this.els.data.classList.add('_Data');
      this.els.data.textContent = raw_initial;
      this.el.appendChild(this.els.data);
      this.els.config = document.createElement('div');
      this.els.config.classList.add('_Config');
      this.els.config.textContent = `[${this._format}] ${ this._name }`;
      this.el.appendChild(this.els.config);
      this._editor = new CodeEditor(this.els.data, this._format);
      this._editor.onChange(this._handleChange.bind(this));
    }

    _handleChange () {
      const val = this._editor.getValue();
      if (this._format === "json") {
        this.variable.setValue(JSON.parse(val));
      } else if (this._format === "csv") {
        this.variable.setValue(parseCSV(val));
      }
    }

  }

  function parseCSV (raw) {
    return parse(raw, {
      columns: true,
      skip_empty_lines: true,
      cast_date: true,
      cast: (value, context) => {
        const as_num = Number(value);
        if (!Number.isNaN(as_num)) {
          return as_num;
        }
        return value;
      },
    });
  }

  function activateElements () {
    const form_fields = [
      ...document.querySelectorAll('input[name]'),
      ...document.querySelectorAll('select[name]'),
    ];
    form_fields.forEach(el => {
      new FormElement(el);
    });

    const elements = document.querySelectorAll('.js-amd-element');
    Array.from(elements).forEach((el) => {
      const config = el.dataset.config;
      if (RangeElement.config_pattern.test(config)) {
        new RangeElement(el);
      } else if (StringElement.config_pattern.test(config)) {
        new StringElement(el);
      } else if (SwitchElement.config_pattern.test(config)) {
        new SwitchElement(el);
      // } else if (SequenceElement.config_pattern.test(config)) {
      } else {
        console.warn('Unknown config format', config);
      }
    });
  }

  async function activateEmbeds () {
    // const ChartEmbed = await import("./ChartEmbed.js");
    const embeds = document.querySelectorAll('.js-amd-embed');
    Array.from(embeds).forEach((el) => {
      const config = el.dataset.config;
      if (ChartEmbed.config_pattern.test(config)) {
        new ChartEmbed(el);
      }
    });
  }

  async function activateCodeBlocks () {
    // const Executor = await import("./Executor.js");
    const executor = new Executor(__amd_meta__);

    const codeblocks = document.querySelectorAll('pre');
    Array.from(codeblocks).forEach((block_el) => {
      const code_el = block_el.children[0];
      if (code_el && code_el.classList && !code_el.className) {
        executor.addBlock({
          el: code_el,
        });
      }
    });
    executor.run();
  }


  function setUpViewSource () {
    document.body.dataset.show_source = false;
    const el = document.getElementById("activemd_raw_source");
    const raw_source = decodeURIComponent(el.textContent);
    el.textContent = raw_source;
    const controls = document.createElement('nav');
    controls.setAttribute('id', 'activemd_controls');
    controls.innerHTML = `
    <a id="activemd_controls_view_source" href="#view-source">View Source</a>
    <a id="activemd_controls_hide_source" href="#">Hide Source</a>
    <a id="activemd_controls_download_source" href="#">Download</a>
    <a href="https://activemarkdown.alecperkins.net" rel="noreferrer">About</a>
  `;
    const view_source_el = controls.querySelector('#activemd_controls_view_source');
    view_source_el.addEventListener('click', (e) => {
      document.body.dataset.show_source = true;
    });
    const hide_source_el = controls.querySelector('#activemd_controls_hide_source');
    hide_source_el.addEventListener('click', (e) => {
      document.body.dataset.show_source = false;
    });
    const download_source_el = controls.querySelector('#activemd_controls_download_source');
    const file = new Blob([raw_source], {
      type: 'text/markdown',
    });
    download_source_el.setAttribute('href', URL.createObjectURL(file));
    download_source_el.setAttribute('download', decodeURIComponent(document.body.dataset.filename));
    document.body.prepend(controls);

    if (window.location.hash === '#view-source') {
      document.body.dataset.show_source = true;
    }
  }

  function setUpDatasets () {
    DatasetEmbed.bindToCodeBlocks();
  }

  function setUpHeaderLinks () {
    const header_els = document.querySelectorAll('h1, h2, h3, h4, h5, h6');
    Array.from(header_els).forEach(el => {
      const link_el = document.createElement('a');
      link_el.href = `#${ el.id }`;
      link_el.classList.add('_Link');
      link_el.textContent = '#';
      link_el.setAttribute('aria-description', `Link to ${ el.textContent } heading`);
      const wrapper_el = document.createElement('div');
      wrapper_el.classList.add('SectionHeader');
      wrapper_el.appendChild(link_el);
      el.parentNode.insertBefore(wrapper_el, el);
      wrapper_el.appendChild(el);
      // el.remove();
    });
  }
  function main () {
    setUpHeaderLinks();
    {
      setUpDatasets();
    }
    activateElements();
    {
      activateEmbeds();
    }
    {
      activateCodeBlocks();
    }
    setUpViewSource();
    document.body.dataset.activemd = true;
  }

  main();

})();
  </script>
  
</body>
</html>
