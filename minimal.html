<!doctype html>
<html>
<head>
<!--
This file was generated by Active Markdown, v0.4.2 - https://activemarkdown.alecperkins.net

minimal.md - 2024-09-06T22:13:38.604Z
-->
  <title>minimal.md</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <style>
:root {
  --color-active-highlight: rgb(209, 180, 237);
  --color-inactive-highlight: rgb(239, 225, 255);
  --color-tag-bg: rgb(209, 180, 237);
  --color-tag-border: rgba(96,88,57,1);
  --color-code-bg: rgba(245,245,245,1);
  --color-border: rgba(200,200,200,1);
  --radius: 4px;
  --color-doc-bg: rgba(250,250,248,1);
  --color-chart-bg: white;
  --color-element-decoration: rebeccapurple;
  --color-readonly-element-decoration: rgb(190, 140, 240);
  --color-text: rgba(5,5,10,1);
  --gutter: 1rem;
  --font-sans: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
  --font-mono: Consolas,Monaco,Andale Mono,Ubuntu Mono,monospace;
  --color-table-odd: rgba(255,255,255,1);
  --color-table-even: rgba(245,245,250,1);
}

/* @media (prefers-color-scheme: dark) {
  :root {
    --color-active-highlight: yellow;
    --color-tag-bg: rgba(96,88,57,1);
    --color-tag-border: rgba(247,230,143,1);
    --color-doc-bg: rgba(5,5,10,1);
    --color-chart-bg: black;
    --color-element-decoration: #d8d0f6;
    --color-text: rgba(250,250,248,1);
  }
} */

html,
body {
  padding: 0;
  background-color: var(--color-doc-bg);
}

body {
  color: var(--color-text);
  font-family: var(--font-sans);
  &[data-dragging_x="true"] {
    cursor: col-resize;
  }
}

main {
  line-height : 1.35;
  max-width: 690px;
  margin: 0 auto;
  padding-left: var(--gutter);
  padding-right: var(--gutter);
}

hr {
  margin      : 2rem 0;
  border      : 0;
  border-top  : 1px solid var(--color-border);
}

h1, h2, h3, h4, h5, h6 {
  margin-top: 0;
}
p, h1, h2, h3, h4, h5, h6, blockquote {
  code {
    font-size           : 0.8em;
    background-color    : var(--color-code-bg);
    border              : 1px solid var(--color-border);
    border-radius       : var(--radius);
    padding             : 0 0.2em;
    font-family         : var(--font-mono);
  }
}


table {
  width           : 100%;
  max-height      : 80vh;
  overflow        : scroll;
  border          : 1px solid var(--color-border);
  border-spacing  : 0;
  border-radius   : var(--radius);
  td, th {
    padding: 0.5em 1em;
  }
  p {
    margin: 0;
  }
  tbody {
    tr:nth-of-type(odd) {
      td {
        background: var(--color-table-odd);
      }
    }
    tr:nth-of-type(even) {
      td {
        background: var(--color-table-even);
      }
    }

  }
  th {
    font-size: 0.8em;
    /* background-color: $light_border_color; */
  }

}

blockquote {
  border-left: 2px solid var(--color-text);
  margin-left: 2px;
  padding-left: var(--gutter);
}

.BaseElement {
  position: relative;
  text-decoration-style: dotted;
  text-decoration-line: underline;
  text-decoration-thickness: 0.1em;
  text-decoration-color: var(--color-element-decoration);

  &[data-is_active="false"] {
    background-color    : unset;
    transition-duration : 1s;
    transition-property : background-color;
  }
  &[data-is_active="true"] {
    background-color    : var(--color-active-highlight);
  }

  ._Name {
    display: none;
    position: absolute;
    bottom: calc(100% - 0.2em);
    left: 0;
    background-color: var(--color-tag-bg);
    border: 0.5px solid var(--color-tag-border);
    border-radius: var(--radius);
    font-size: 0.6em;
    font-family: var(--font-mono);
    font-weight: 500;
    font-style: normal;
    padding: 0.2em;
  }
  &:hover,
  &:focus {
    ._Name {
      display: block;
    }
  }
}

.StringElement {
  cursor          : text;
  text-decoration-color: var(--color-readonly-element-decoration);
}
.RangeElement {
  cursor          : col-resize;
  &:hover,
  &:focus {
    background-color: var(--color-inactive-highlight);
  }
  &[data-is_active="true"] {
    background-color: var(--color-active-highlight);
    ._Indicator {
      background-color: var(--color-element-decoration);
    }
  }
  ._Indicator {
    position: absolute;
    top: calc(100% - 1px);
    left: 0px;
    background-color: var(--color-readonly-element-decoration);
    height: 0.1em;
    display: inline-block;
  }
}
.SwitchElement {
  cursor          : pointer;
  margin-left     : 0.25em;

  ._Indicator {
    position: absolute;
    right: 100%;
  }

  &[aria-pressed="true"] {
    ._Indicator {
      color: rgb(0, 128, 102);
      top: -0.2em;
    }
  }
  &[aria-pressed="false"] {
    ._Indicator {
      color: rgb(255, 72, 0);
      top: 0.1em;
    }
  }
  &[aria-pressed="mixed"] {
    ._Indicator {
      color: grey;
      top: -0.05em;
    }
  }

}

.DatasetEmbed {
  position: relative;
  --editor__bg: white !important;
  ._Data {
    width: 100%;
    max-height: 392px; /* ensure the last line is cut off, as a hint to scroll */
    overflow: scroll;
    background-color: var(--color-chart-bg);
    white-space: pre;
    border-radius: 6px;
  }
  ._Config {
    display: none;
    position: absolute;
    bottom: calc(100% - 0.2em);
    left: 0;
    background-color: var(--color-tag-bg);
    border: 0.5px solid var(--color-tag-border);
    border-radius: var(--radius);
    font-size: 0.6em;
    font-family: var(--font-mono);
    font-weight: 500;
    font-style: normal;
    padding: 0.2em;
  }
  &:hover,
  &:focus {
    ._Config {
      display: block;
    }
  }
}
.ChartEmbed {
  border: 1px solid #ccc;
  display: inline-block;
  height: 400px;
  width: 100%;
  position: relative;
  ._Canvas {
    background-color: var(--color-chart-bg);
    height: 100%;
    width: 100%;
  }
  ._Config {
    display: none;
    position: absolute;
    bottom: calc(100% - 0.2em);
    left: 0;
    background-color: var(--color-tag-bg);
    border: 0.5px solid var(--color-tag-border);
    border-radius: var(--radius);
    font-size: 0.6em;
    font-family: var(--font-mono);
    font-weight: 500;
    font-style: normal;
    padding: 0.2em;
  }
  &:hover,
  &:focus {
    ._Config {
      display: block;
    }
  }
}

.prism-code-editor {
  font-size: 0.8rem;
}

.CodeEditor {
  display: inline-block;
  max-width: 50em;
  width: 100%;
}


#activemd_raw_source {
  background-color: white;
  color: black;
  border: 1px solid var(--color-border);
  padding: 0.5rem;
  display: none;
  position: absolute;
  left: 0.5rem;
  right: 0.5rem;
  top: 1rem;
  height: 92vh;
  overflow: scroll;
}
#activemd_controls_hide_source {
  display: none;
}
#activemd_controls {
  text-align: center;
  font-size: 0.7rem;
  border-bottom: 1px solid var(--color-border);
}

body[data-show_source="true"] {
  position: relative;
  overflow: hidden;
  #activemd_active_doc {
    visibility: hidden;
    pointer-events: none;
  }
  #activemd_raw_source {
    display: block;
  }
  #activemd_controls_hide_source {
    display: inline;
  }
  #activemd_controls_view_source {
    display: none;
  }
  #activemd_controls_download_source {

  }
}

.ActiveCodeBlock {
  border: 1px solid #ccc;
}

.SectionHeader {
  position: relative;
  margin-top: 1rem;
  ._Link {
    position: absolute;
    right: 100%;
    margin-right: 0.35em;
    top: 50%;
    margin-top: -0.65em;
    opacity: 0.5;
    text-decoration: none;
    &:hover {
      opacity: 1;
    }
  }
}</style>
</head>
<body data-activemd="false" data-filename="minimal.md">
  <main id="activemd_active_doc"><p>Just a basic range <span class="js-amd-element" data-config="range: ..">2.</span> with reactivity <span class="js-amd-element" data-config="range">2.</span>.</p>
</main>
  <textarea disabled id="activemd_raw_source">%0AJust%20a%20basic%20range%20%5B2.%5D%7Brange%3A%20..%7D%20with%20reactivity%20%5B2.%5D%7Brange%7D.%0A%0A</textarea>
  <script>
  /*
  Active Markdown is released under the MIT license.

  Copyright 2024 Alec Perkins <mail@alecperkins.me>

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.


  */
    const __amd_meta__ = JSON.parse(decodeURIComponent('%7B%7D'));
    (function () {
  'use strict';

  class DragManager {
    constructor () {
      this._window = window;
      this._body_el = document.body;
      this._reset();

      this._boundDrag = this._drag.bind(this);
      this._boundStop = this._stop.bind(this);
    }

    /**
     * Private: reset the drag manager and related document styles (cursor).
      Returns nothing.
     */
    _reset () {
      this.is_dragging = false;
      if (this._direction !== null) {
        this._body_el.dataset[`dragging_${ this._direction }`] = false;
      }
      this._dragging_target = null;
      this._drag_start_x = null;
      this._drag_start_y = null;
      this._direction = null;
    }
    /*
    Private: prepare the mouse position information for the handlers.

    cur_x - the integer current x position of the cursor
    cur_y - the integer current y position of the cursor

    Returns an object with the initial coordinates, and the change in position.
    */
    _assembleUI (cur_x, cur_y) {
      return {
        x_start : this._drag_start_x,
        y_start : this._drag_start_y,
        x_delta : cur_x - this._drag_start_x,
        y_delta : cur_y - this._drag_start_y,
      };
    }


    /*
    Public: initiate a drag operation for a given view.

    e           - the jQuery.Event from the initial mousedown event
    view        - the BaseElementView of the element starting the drag
    direction   - the String direction of the drag: 'x', 'y', or 'both'

    Returns nothing.
    */
    start (e, view, direction) {
      this._is_dragging = true;
      const { pageX, pageY } = e;
      this._direction = direction;
      this._drag_start_x = pageX;
      this._drag_start_y = pageY;
      this._dragging_target = view;
      this._window.addEventListener('mousemove', this._boundDrag);
      this._window.addEventListener('mouseup', this._boundStop);
      this._window.addEventListener('touchmove', this._boundDrag);
      this._window.addEventListener('touchend', this._boundStop);
      this._body_el.dataset[`dragging_${ this._direction }`] = true;
    }

    _drag (e) {
      const { pageX, pageY } = e;
      const ui = this._assembleUI(pageX, pageY);
      this._dragging_target.onDrag?.(ui);
    }

    _stop (e) {
      this._window.removeEventListener('mousemove', this._boundDrag);
      this._window.removeEventListener('mouseup', this._boundStop);
      if (this._dragging_target != null) {
        const { pageX, pageY } = e;
        const ui = this._assembleUI(pageX, pageY);
        this._dragging_target.stopDragging?.(ui);
        this._reset();
      }
    }
  }

  const doc_variables = {};
  const doc_elements = {};
  const doc_embeds = {};

  const drag_manager = new DragManager(document, window);

  let latest_id = 1;
  function generateId () {
    latest_id += 1;
    return latest_id.toString(36);
  }

  function registerElement (element) {
    const id = generateId();
    element.el.dataset.activemd_id = id;
    doc_elements[id] = element;
  }


  window.ActiveMarkdown = {
    variables: doc_variables,
    elements: doc_elements,
    embeds: doc_embeds,
  };

  /*

  Numbers in Active Markdown are ordinary `Number` values for the most part, but also MAY include various constants from `Math` as a multiplier. For example, `2pi` is equivalent to `2 * Math.PI`, while `0.5e` is equivalent to `0.5 * Math.E`. The constants may be specified without a digit, eg `pi` or `ln2`. Also, they may be specified in lowercase or uppercase, or some combination of the two, if you're into that.
  */
  function parseNumber (val) {
    const constants = ['E', 'PI', 'LN2', 'LN10', 'LOG2E', 'LOG10E', 'SQRT1_2', 'SQRT2'];
    let parsed_val = null;

    // Check the value for each constant, allowing for just a constant
    // with no coefficient.
    for (const c of constants) {
      const r = RegExp(`([+-]?)([\\d\\.]*)${ c }`);
      const group = val.toUpperCase().match(r);

      // If the number matches a constant, generate the equivalent
      // expression and calculate the actual value of the number.
      if (group) {
        const sign = group[1] === '-' ? -1 : 1;
        const mult = group[2] ? (new Number(group[2])) : 1;
        parsed_val = sign * mult * Math[c];
        break
      }

    }

    // If the value is still null, the number didn't have any constants, so
    // just parse it as a regular Number.
    if (parsed_val == null) {
      parsed_val = parseFloat(val);
    }

    return parsed_val
  }

  // The step of a range defaults to 1, but can be specified using the `by` keyword after the min/max. The step is an Active Markdown Number, and can include the constants described above.
  //
  // A range described with `0..10` will have a step of `1`, while `0..10 by 0.1` will have a step of `0.1`, and `0..10 by pi` will have a step of `Math.PI`.
  function parseStep (val) {
    if (val) {
      const as_str = val.replace(' by ','');
      const as_number = parseNumber(as_str);
      // if (Number.isNaN(as_number)) {
      //   return as_str;
      // }
      return as_number;
    }
    return 1;
  }

  // Ranges in Active Markdown work the same as in CoffeeScript; two dots describes an inclusive range, while three dots excludes the tail. (The check here is only if there are two dots or not since the element configuration parsing regex limits the match to `'..'` or `'...'`.)
  function parseInclusivity (dots) {
    return dots.length === 2;
  }

  class Variable {

    static getOrCreate (name, initial_value) {
      if (doc_variables[name]) {
        return doc_variables[name];
      }
      return new Variable(name, initial_value);
    }

    constructor (name, initial_value=undefined, options={}) {
      this.is_dataset = options.is_dataset || false;
      this._element_callbacks = [];
      this._code_block_callbacks = [];
      this._name = name;
      this._value = initial_value;

      if (doc_variables[name]) {
        throw new Error(`Variable name repeated: ${ name }`);
      }

      doc_variables[name] = this;
    }
    onChange (callback, is_code_block=false) {
      if (is_code_block) {
        this._code_block_callbacks.push(callback);
      } else {
        this._element_callbacks.push(callback);
      }
    }
    getName () {
      return this._name;
    }
    getValue () {
      return this._value;
    }
    setValue (value, trigger_elements_only=false) {
      this._value = value;
      this._triggerOnChange(trigger_elements_only);
    }

    _triggerOnChange (trigger_elements_only=false) {
      this._element_callbacks.forEach((callback) => {
        callback(this._value, this._name);
      });
      if (!trigger_elements_only) {
        this._code_block_callbacks.forEach((callback) => {
          callback(this._value, this._name);
        });
      }
    }
  }

  class BaseElement {
    constructor (el) {
      this.el = el;
      this.el.classList.add("BaseElement");
      this.el.setAttribute("tabindex", 0);
      this._active_ping_timeout = null;
      registerElement(this);
    }
    _pingChanged () {
      clearTimeout(this._active_ping_timeout);
      this.el.dataset.is_active = true;
      this._active_ping_timeout = setTimeout(() => {
        this.el.dataset.is_active = false;
      }, 2000);
    }
  }

  class RangeElement extends BaseElement {
    static config_pattern = new RegExp(`
    ^(                      # Variable
      [\\w\\d]+               # - name
    )

      :\\s                   # Delimiter

    (                       # Range min, if any:
      [+|-]?                        # - sign, if any
      (?:[\\d]*[\\.]?[\\d]+)?          # - coefficient, if any
      [102EGILONQPSRT_egilonqpsrt]* # - constant, if any
    )

    (                       # Inclusivity
      [\\.]{2,3}             # - dots
    )

    (                       # Range max, if any:
      [+|-]?                        # - sign, if any
      (?:[\\d]*[\\.]?[\\d]+)?          # - coefficient, if any
      [102EGILONQPSRT_egilonqpsrt]* # - constant, if any
    )

    (                       # Step, if any:
      \\sby\\s                # - by keyword

        (?:                 # - step value
          [+|-]?                        # - sign, if any
          (?:[\\d]*[\\.]?[\\d]+)?          # - coefficient, if any
          [102EGILONQPSRT_egilonqpsrt]* # - constant, if any
        )

    )*$
  `.replace(/#.*\n/g,'').replace(/\s+/g,'')
    );

    /*
    [
        "calories: 10..100 by 10",
        "calories",
        "10",
        "..",
        "100",
        " by 10",
        index: 0,
        input: "calories: 10..100 by 10"
    ]
    */
    static _parseConfig (config_text) {
      const config_match = config_text.match(this.config_pattern);
      if (!config_match) { return null; }

      const [text, var_name, min_str, dots, max_str, step_str] = config_match;
      let min;
      let max;
      let initial_value;

      if (min_str) {
        min = parseNumber(min_str);
      } else {
      min = null;
      }

      if (max_str) {
        max = parseNumber(max_str);
      } else {
        max = null;
      }

      if (min && max) {
        initial_value = (max - min) / 2;
      } else {
        initial_value = 0;
      }

      const config = {
        name        : var_name,
        min         : min,
        max         : max,
        inclusive   : parseInclusivity(dots),
        step        : parseStep(step_str),
        value       : initial_value,
      };
      return config;
    }

    /*
      Private: parse the text content of the element for default value, display
               precision, and additional text.

      text_content - the String text version of the element

      Return the default value for the variable.
    */
    static _parseTextContent (parsed_config, text_content) {
      let default_value     = parsed_config.value;
      let before_text       = '';
      let after_text        = '';
      let display_precision = null;

      /*
          [
            '$200.0 per day',
            '$',
            '200',
            '.',
            '0',
            ' per day',
            index: 0,
            input: '$200.0 per day'
          ]
      */
      const pattern = /([a-zA-Z=:$ ]*)([\-\d]+)(\.?)(\d*)([a-zA-Z=: ]*)/;
      const match_group = text_content.match(pattern);
      if (match_group) {
        const [
          _text,
          before_text_str,
          value_str,
          point_str,
          decimal_str,
          after_text_str,
        ] = match_group;
        before_text = before_text_str;
        after_text = after_text_str;
        default_value = parseFloat([value_str, point_str, decimal_str].join(''));
        if (point_str) {
          display_precision = decimal_str.length;
        }
      }
      return {
        default_value,
        before_text,
        after_text,
        display_precision,
      };
    }

    constructor (el) {
      super(el);
      this.els = {};
      const parsed_config = RangeElement._parseConfig(el.dataset.config);
      const parsed_text = RangeElement._parseTextContent(parsed_config, el.textContent);
      this._before_text = parsed_text.before_text;
      this._after_text = parsed_text.after_text;
      this._display_precision = parsed_text.display_precision;
      this._text_content = el.textContent;
      this.variable = new Variable(parsed_config.name, parsed_text.default_value);
      this.variable.onChange(() => this._renderUpdate());
      this._initial_value = parsed_text.default_value;
      this._config = parsed_config;
      this._renderInitial();
      this._last_click = 0;
      this._drag_manager = drag_manager;
    }

    _renderInitial () {
      this.el.innerHTML = `<ruby><span class="_Value"></span><rp>(</rp><rt class="_Name"></rt><rp>)</rp></ruby><span class="_Indicator" aria-role="hidden"></span>`;
      this.el.classList.add('RangeElement');
      this.el.setAttribute('aria-role', "slider");
      this.el.setAttribute('aria-valuemin', this._config.min);
      this.el.setAttribute('aria-valuemax', this._config.max);
      this.els.value = this.el.querySelector('._Value');
      this.els.name = this.el.querySelector('._Name');
      this.els.name.textContent = this.variable.getName();
      this.els.indicator = this.el.querySelector('._Indicator');
      this._renderUpdate();
      this._bindEvents();
    }

    _bindEvents () {
      this.el.addEventListener('mousedown', this._startDragging.bind(this));
      this.el.addEventListener('touchstart', this._startDragging.bind(this));
      this.el.addEventListener('click', this._reset.bind(this));
      this.el.addEventListener('keydown', this._handleKeydown.bind(this));
    }

    _handleKeydown (e) {
      if (
        e.which === 37 // Left Arrow
        || e.which === 40 // Down Arrow
      ) {
        e.preventDefault();
        this._decrement(e.shiftKey ? this._config.step * 10 : this._config.step);
      } else if (
        e.which === 39 // Right Arrow
        || e.which === 38 // Up Arrow
      ) {
        e.preventDefault();
        this._increment(e.shiftKey ? this._config.step * 10 : this._config.step);
      } else if (
        e.which === 13 // Enter
      ) {
        e.preventDefault();
        this._reset();
      }
    }

    _increment (magnitude) {
      if (!magnitude) {
        magnitude = this._config.step;
      }
      const current_value = this.variable.getValue();
      let new_value = current_value + magnitude;
      if (this._config.max != null) {
        if (this._config.inclusive) {
          if (new_value > this._config.max) {
            new_value = this._config.max;
          }
        } else {
          if (new_value > this._config.max - this._config.step) {
            new_value = this._config.max - this._config.step;
          }
        }
      }
      this.variable.setValue(new_value);
    }

    _decrement (magnitude) {
      if (!magnitude) {
        magnitude = this._config.step;
      }
      const current_value = this.variable.getValue();
      let new_value = current_value - magnitude;
      if (this._config.min != null) {
        if (new_value < this._config.min) {
          new_value = this._config.min;
        }
      }
      this.variable.setValue(new_value);
    }

    _startDragging (e) {
      e.preventDefault();
      this._drag_start_value = this.variable.getValue();
      this._drag_manager.start(e, this, 'x');
      this.el.dataset.is_active = true;
    }

    onDrag ({ x_start, y_start, x_delta, y_delta }) {
      const max = this._config.max;
      const min = this._config.min;
      const step = this._config.step;
      let px_per_step;
      if (max != null && min != null) {
        px_per_step = Math.min((window.innerWidth / (max - min / step)), 25); // Keep the step size close to a comfortable touch target
      } else {
        px_per_step = 25;
      }
      const value_delta = Math.floor(x_delta / px_per_step) * step;
      let new_val = this._drag_start_value + value_delta;

      if (max != null) {
        const inclusive = this._config.inclusive;
        if (
          (inclusive && new_val > max)
          || (!inclusive && new_val >= max)
        ) {
          new_val = max;
          if (!inclusive) {
            new_val -= this._config.step;
          }
        }
      }
      if (min != null && new_val < min) {
        new_val = min;
      }
      if (this.variable.getValue() !== new_val) {
        this.variable.setValue(new_val);
      }
    }

    stopDragging (ui) {
      this.el.dataset.is_active = false;
      this._drag_start_value = null;
    }

    _reset () {
      const now = Date.now();
      if (now - this._last_click < 500) {
        this.variable.setValue(this._initial_value);
      }
      this._last_click = now;
    }

    _renderUpdate () {
      const value = this.variable.getValue();

      if (value === undefined) {
        this.el.setAttribute('aria-valuetext', this._text_content);
        this.els.value.textContent = this._text_content;
        return;
      }

      let display_val;
      if (this._display_precision != null) {
        display_val = value.toFixed(this._display_precision);
      } else {
        display_val = value;
      }
      display_val = `${this._before_text || ''}${ display_val }${ this._after_text || '' }`;
      this.el.setAttribute('aria-valuetext', display_val);
      this.el.setAttribute('aria-valuenow', value);
      this.els.value.textContent = display_val;
      if (this._config.max != null && this._config.min != null) {
        const max = this._config.inclusive ? this._config.max : this._config.max - this._config.step;
        const min = this._config.min;
        const progress = (value - min) / (max - min);
        this.els.indicator.style.width = `${ progress * 100 }%`;
      }
    }

  }

  class StringElement extends BaseElement {
    readonly = true;
    static config_pattern = /(^[\w\d]+$)/;

    static _parseConfig (config_text) {
      const config_match = config_text.match(this.config_pattern);
      if (!config_match) { return null; }
      return {
        name: config_match[1],
      };
    }

    static _parseTextContent (parsed_config, text_content) {
      let default_value     = parsed_config.value;
      let before_text       = '';
      let after_text        = '';
      let display_precision = null;

      /*
          [
            '$200.0 per day',
            '$',
            '200',
            '.',
            '0',
            ' per day',
            index: 0,
            input: '$200.0 per day'
          ]
      */
      const pattern = /([a-zA-Z=:$ ]*)([\-\d]+)(\.?)(\d*)([%a-zA-Z=: ]*)/;
      const match_group = text_content.match(pattern);
      if (match_group) {
        const [
          _text,
          before_text_str,
          value_str,
          point_str,
          decimal_str,
          after_text_str,
        ] = match_group;
        before_text = before_text_str;
        after_text = after_text_str;
        default_value = parseFloat([value_str, point_str, decimal_str].join(''));
        if (point_str) {
          display_precision = decimal_str.length;
        }
      }
      return {
        default_value,
        before_text,
        after_text,
        display_precision,
      };
    }

    constructor (el) {
      super(el);
      this.els = {};
      const parsed_config = StringElement._parseConfig(el.dataset.config);
      const parsed_text = StringElement._parseTextContent(parsed_config, el.textContent);
      this._before_text = parsed_text.before_text;
      this._after_text = parsed_text.after_text;
      this._display_precision = parsed_text.display_precision;
      this._text_content = el.textContent;
      this.variable = Variable.getOrCreate(parsed_config.name);
      this.variable.onChange(() => this._renderUpdate());
      this._renderInitial();
    }

    _renderInitial () {
      this.el.innerHTML = `<ruby><span class="_Value"></span><rp>(</rp><rt class="_Name"></rt><rp>)</rp></ruby>`;
      this.el.classList.add('StringElement');
      this.els.value = this.el.querySelector('._Value');
      this.els.name = this.el.querySelector('._Name');
      this.els.name.textContent = this.variable.getName();
      this._renderUpdate();
    }

    _renderUpdate () {
      let value = this.variable.getValue();
      let display_value;
      if (value === undefined) {
        display_value = this._text_content;
      } else {
        // Automatically format percents
        if (typeof value === "number") {
          if (this._after_text === "%") {
            value = value * 100;
          }
          if (this._display_precision !== null) {
            display_value = value.toFixed(this._display_precision);
          } else {
            const fmt = new Intl.NumberFormat({
              // minimumFractionDigits: this._display_precision || undefined,
              // maximumFractionDigits: this._display_precision || undefined,
            });
            display_value = fmt.format(value);
          }
        } else if (Array.isArray(value)) {
          if (value.length > 0) {
            display_value = value.join(", ");
          } else {
            display_value = this._text_content;
          }
        } else {
          display_value = value.toString();
        }
      }
      display_value = `${ this._before_text || '' }${ display_value }${ this._after_text || '' }`;
      if (this.els.value.textContent !== display_value) {
        this.els.value.textContent = display_value;
        this._pingChanged();
      }
    }
  }

  class SwitchElement extends BaseElement {
    static config_pattern = new RegExp(`
    ^(                      # Variable
      [\\w\\d]+               # - name
    )

    :\\s                   # Delimiter

    (                       # true_label
        [\\w]+
    )

    \\sor\\s                  # or keyword

    (                       # false_label
        [\\w]+
    )$
  `.replace(/#.*\n/g,'').replace(/\s+/g,''));

    static _parseConfig (config_text) {
      const config_match = config_text.match(this.config_pattern);
      if (!config_match) { return null; }
      /*
          [
              "some_flag: on or off",
              "some_flag",
              "on",
              "off",
              index: 0,
              input: "some_flag: on or off"
          ]
      */

      const [
        _text,
        name,
        true_label,
        false_label,
      ] = config_match;

      return {
        name,
        true_label,
        false_label,
      };
    }

    static _parseTextContent (parsed_config, text_content) {
      const { true_label, false_label } = parsed_config;

      function matchLabel (label) {
        const pattern = RegExp(`(.*)${ label }(.*)`);
        const group = text_content.match(pattern);
        return group;
      }

      let default_value = undefined;
      let before_text = '';
      let after_text = '';

      const true_group = matchLabel(true_label);
      if (true_group) {
        default_value = true;
        before_text = true_group[1];
        after_text = true_group[2];
      } else {
        const false_group = matchLabel(false_label);
        if (false_group) {
          default_value = false;
          before_text = false_group[1];
          after_text = false_group[2];
        }
      }
      return {
        default_value,
        before_text,
        after_text,
      };
    }

    constructor (el) {
      super(el);
      this.els = {};
      const parsed_config = SwitchElement._parseConfig(el.dataset.config);
      const parsed_text = SwitchElement._parseTextContent(parsed_config, el.textContent);
      this._true_label = parsed_config.true_label;
      this._false_label = parsed_config.false_label;
      this._before_text = parsed_text.before_text;
      this._after_text = parsed_text.after_text;
      this._text_content = el.textContent;
      this._name = parsed_config.name;
      this.variable = new Variable(parsed_config.name, parsed_text.default_value);
      this.variable.onChange(() => this._renderUpdate());
      this._renderInitial();
    }

    _renderInitial () {
      this.el.innerHTML = `<span class="_Indicator" aria-hidden="true">â€¢</span><ruby><span class="_Value"></span><rp>(</rp><rt class="_Name"></rt><rp>)</rp></ruby>`;
      this.el.classList.add('SwitchElement');
      this.el.setAttribute('aria-role', "button");
      this.els.value = this.el.querySelector("._Value");
      this.els.name = this.el.querySelector("._Name");
      this.els.indicator = this.el.querySelector("._Indicator");
      this.els.name.textContent = this._name;
      this._renderUpdate();
      this._bindEvents();
    }

    _renderUpdate () {
      const value = this.variable.getValue();
      let display_val;
      if (value === true) {
        display_val = this._true_label;
        this.el.setAttribute('aria-pressed', true);
      } else if (value === false) {
        display_val = this._false_label;
        this.el.setAttribute('aria-pressed', false);
      } else {
        display_val = this._text_content;
        this.el.setAttribute('aria-pressed', 'mixed');
      }
      display_val = `${this._before_text || ''}${ display_val }${ this._after_text || '' }`;
      this.els.value.textContent = display_val;
    }

    _bindEvents () {
      this.el.addEventListener('click', this._toggleValue.bind(this));
      this.el.addEventListener('keydown', this._handleKeydown.bind(this));
    }

    _handleKeydown (e) {
      if (
        e.which === 32 // Space
        || e.which === 13 // Enter
      ) {
        e.preventDefault();
        this._toggleValue();
      }
    }

    _toggleValue (e) {
      const current = this.variable.getValue();
      if (current === true) {
        this.variable.setValue(false);
      } else {
        this.variable.setValue(true);
      }
    }
  }

  class FormElement extends BaseElement {
    constructor (el) {
      super(el);
      this.el.classList.add('FormElement');
      const name = this.el.getAttribute('name');
      this._variable = new Variable(name);
      this.el.addEventListener('change', this._triggerUpdate.bind(this));
      this._triggerUpdate({ target: this.el }); // Get the initial value from the markup
    }

    _triggerUpdate (e) {
      if (this.el.options && this.el.multiple) {
        const value = [];
        for (const option of this.el.options) {
          if (option.selected) {
            value.push(option.value);
          }
        }
        this._variable.setValue(value);
      } else {
        this._variable.setValue(e.target.value);
      }

    }
  }

  function activateElements () {
    const form_fields = [
      ...document.querySelectorAll('input[name]'),
      ...document.querySelectorAll('select[name]'),
    ];
    form_fields.forEach(el => {
      new FormElement(el);
    });

    const elements = document.querySelectorAll('.js-amd-element');
    Array.from(elements).forEach((el) => {
      const config = el.dataset.config;
      if (RangeElement.config_pattern.test(config)) {
        new RangeElement(el);
      } else if (StringElement.config_pattern.test(config)) {
        new StringElement(el);
      } else if (SwitchElement.config_pattern.test(config)) {
        new SwitchElement(el);
      // } else if (SequenceElement.config_pattern.test(config)) {
      } else {
        console.warn('Unknown config format', config);
      }
    });
  }


  function setUpViewSource () {
    document.body.dataset.show_source = false;
    const el = document.getElementById("activemd_raw_source");
    const raw_source = decodeURIComponent(el.textContent);
    el.textContent = raw_source;
    const controls = document.createElement('nav');
    controls.setAttribute('id', 'activemd_controls');
    controls.innerHTML = `
    <a id="activemd_controls_view_source" href="#view-source">View Source</a>
    <a id="activemd_controls_hide_source" href="#">Hide Source</a>
    <a id="activemd_controls_download_source" href="#">Download</a>
    <a href="https://activemarkdown.alecperkins.net" rel="noreferrer">About</a>
  `;
    const view_source_el = controls.querySelector('#activemd_controls_view_source');
    view_source_el.addEventListener('click', (e) => {
      document.body.dataset.show_source = true;
    });
    const hide_source_el = controls.querySelector('#activemd_controls_hide_source');
    hide_source_el.addEventListener('click', (e) => {
      document.body.dataset.show_source = false;
    });
    const download_source_el = controls.querySelector('#activemd_controls_download_source');
    const file = new Blob([raw_source], {
      type: 'text/markdown',
    });
    download_source_el.setAttribute('href', URL.createObjectURL(file));
    download_source_el.setAttribute('download', decodeURIComponent(document.body.dataset.filename));
    document.body.prepend(controls);

    if (window.location.hash === '#view-source') {
      document.body.dataset.show_source = true;
    }
  }

  function setUpHeaderLinks () {
    const header_els = document.querySelectorAll('h1, h2, h3, h4, h5, h6');
    Array.from(header_els).forEach(el => {
      const link_el = document.createElement('a');
      link_el.href = `#${ el.id }`;
      link_el.classList.add('_Link');
      link_el.textContent = '#';
      link_el.setAttribute('aria-description', `Link to ${ el.textContent } heading`);
      const wrapper_el = document.createElement('div');
      wrapper_el.classList.add('SectionHeader');
      wrapper_el.appendChild(link_el);
      el.parentNode.insertBefore(wrapper_el, el);
      wrapper_el.appendChild(el);
      // el.remove();
    });
  }
  function main () {
    setUpHeaderLinks();
    activateElements();
    setUpViewSource();
    document.body.dataset.activemd = true;
  }

  main();

})();
  </script>
  
</body>
</html>
