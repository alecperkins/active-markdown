<!doctype html>
<html>
<head>
<!--
This file was generated by Active Markdown, v0.4.2 - https://activemarkdown.alecperkins.net

st-ives.md - 2024-09-06T22:15:56.158Z
-->
  <title>st-ives.md</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <style>
:root {
  --color-active-highlight: rgb(209, 180, 237);
  --color-inactive-highlight: rgb(239, 225, 255);
  --color-tag-bg: rgb(209, 180, 237);
  --color-tag-border: rgba(96,88,57,1);
  --color-code-bg: rgba(245,245,245,1);
  --color-border: rgba(200,200,200,1);
  --radius: 4px;
  --color-doc-bg: rgba(250,250,248,1);
  --color-chart-bg: white;
  --color-element-decoration: rebeccapurple;
  --color-readonly-element-decoration: rgb(190, 140, 240);
  --color-text: rgba(5,5,10,1);
  --gutter: 1rem;
  --font-sans: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
  --font-mono: Consolas,Monaco,Andale Mono,Ubuntu Mono,monospace;
  --color-table-odd: rgba(255,255,255,1);
  --color-table-even: rgba(245,245,250,1);
}

/* @media (prefers-color-scheme: dark) {
  :root {
    --color-active-highlight: yellow;
    --color-tag-bg: rgba(96,88,57,1);
    --color-tag-border: rgba(247,230,143,1);
    --color-doc-bg: rgba(5,5,10,1);
    --color-chart-bg: black;
    --color-element-decoration: #d8d0f6;
    --color-text: rgba(250,250,248,1);
  }
} */

html,
body {
  padding: 0;
  background-color: var(--color-doc-bg);
}

body {
  color: var(--color-text);
  font-family: var(--font-sans);
  &[data-dragging_x="true"] {
    cursor: col-resize;
  }
}

main {
  line-height : 1.35;
  max-width: 690px;
  margin: 0 auto;
  padding-left: var(--gutter);
  padding-right: var(--gutter);
}

hr {
  margin      : 2rem 0;
  border      : 0;
  border-top  : 1px solid var(--color-border);
}

h1, h2, h3, h4, h5, h6 {
  margin-top: 0;
}
p, h1, h2, h3, h4, h5, h6, blockquote {
  code {
    font-size           : 0.8em;
    background-color    : var(--color-code-bg);
    border              : 1px solid var(--color-border);
    border-radius       : var(--radius);
    padding             : 0 0.2em;
    font-family         : var(--font-mono);
  }
}


table {
  width           : 100%;
  max-height      : 80vh;
  overflow        : scroll;
  border          : 1px solid var(--color-border);
  border-spacing  : 0;
  border-radius   : var(--radius);
  td, th {
    padding: 0.5em 1em;
  }
  p {
    margin: 0;
  }
  tbody {
    tr:nth-of-type(odd) {
      td {
        background: var(--color-table-odd);
      }
    }
    tr:nth-of-type(even) {
      td {
        background: var(--color-table-even);
      }
    }

  }
  th {
    font-size: 0.8em;
    /* background-color: $light_border_color; */
  }

}

blockquote {
  border-left: 2px solid var(--color-text);
  margin-left: 2px;
  padding-left: var(--gutter);
}

.BaseElement {
  position: relative;
  text-decoration-style: dotted;
  text-decoration-line: underline;
  text-decoration-thickness: 0.1em;
  text-decoration-color: var(--color-element-decoration);

  &[data-is_active="false"] {
    background-color    : unset;
    transition-duration : 1s;
    transition-property : background-color;
  }
  &[data-is_active="true"] {
    background-color    : var(--color-active-highlight);
  }

  ._Name {
    display: none;
    position: absolute;
    bottom: calc(100% - 0.2em);
    left: 0;
    background-color: var(--color-tag-bg);
    border: 0.5px solid var(--color-tag-border);
    border-radius: var(--radius);
    font-size: 0.6em;
    font-family: var(--font-mono);
    font-weight: 500;
    font-style: normal;
    padding: 0.2em;
  }
  &:hover,
  &:focus {
    ._Name {
      display: block;
    }
  }
}

.StringElement {
  cursor          : text;
  text-decoration-color: var(--color-readonly-element-decoration);
}
.RangeElement {
  cursor          : col-resize;
  &:hover,
  &:focus {
    background-color: var(--color-inactive-highlight);
  }
  &[data-is_active="true"] {
    background-color: var(--color-active-highlight);
    ._Indicator {
      background-color: var(--color-element-decoration);
    }
  }
  ._Indicator {
    position: absolute;
    top: calc(100% - 1px);
    left: 0px;
    background-color: var(--color-readonly-element-decoration);
    height: 0.1em;
    display: inline-block;
  }
}
.SwitchElement {
  cursor          : pointer;
  margin-left     : 0.25em;

  ._Indicator {
    position: absolute;
    right: 100%;
  }

  &[aria-pressed="true"] {
    ._Indicator {
      color: rgb(0, 128, 102);
      top: -0.2em;
    }
  }
  &[aria-pressed="false"] {
    ._Indicator {
      color: rgb(255, 72, 0);
      top: 0.1em;
    }
  }
  &[aria-pressed="mixed"] {
    ._Indicator {
      color: grey;
      top: -0.05em;
    }
  }

}

.DatasetEmbed {
  position: relative;
  --editor__bg: white !important;
  ._Data {
    width: 100%;
    max-height: 392px; /* ensure the last line is cut off, as a hint to scroll */
    overflow: scroll;
    background-color: var(--color-chart-bg);
    white-space: pre;
    border-radius: 6px;
  }
  ._Config {
    display: none;
    position: absolute;
    bottom: calc(100% - 0.2em);
    left: 0;
    background-color: var(--color-tag-bg);
    border: 0.5px solid var(--color-tag-border);
    border-radius: var(--radius);
    font-size: 0.6em;
    font-family: var(--font-mono);
    font-weight: 500;
    font-style: normal;
    padding: 0.2em;
  }
  &:hover,
  &:focus {
    ._Config {
      display: block;
    }
  }
}
.ChartEmbed {
  border: 1px solid #ccc;
  display: inline-block;
  height: 400px;
  width: 100%;
  position: relative;
  ._Canvas {
    background-color: var(--color-chart-bg);
    height: 100%;
    width: 100%;
  }
  ._Config {
    display: none;
    position: absolute;
    bottom: calc(100% - 0.2em);
    left: 0;
    background-color: var(--color-tag-bg);
    border: 0.5px solid var(--color-tag-border);
    border-radius: var(--radius);
    font-size: 0.6em;
    font-family: var(--font-mono);
    font-weight: 500;
    font-style: normal;
    padding: 0.2em;
  }
  &:hover,
  &:focus {
    ._Config {
      display: block;
    }
  }
}

.prism-code-editor {
  font-size: 0.8rem;
}

.CodeEditor {
  display: inline-block;
  max-width: 50em;
  width: 100%;
}


#activemd_raw_source {
  background-color: white;
  color: black;
  border: 1px solid var(--color-border);
  padding: 0.5rem;
  display: none;
  position: absolute;
  left: 0.5rem;
  right: 0.5rem;
  top: 1rem;
  height: 92vh;
  overflow: scroll;
}
#activemd_controls_hide_source {
  display: none;
}
#activemd_controls {
  text-align: center;
  font-size: 0.7rem;
  border-bottom: 1px solid var(--color-border);
}

body[data-show_source="true"] {
  position: relative;
  overflow: hidden;
  #activemd_active_doc {
    visibility: hidden;
    pointer-events: none;
  }
  #activemd_raw_source {
    display: block;
  }
  #activemd_controls_hide_source {
    display: inline;
  }
  #activemd_controls_view_source {
    display: none;
  }
  #activemd_controls_download_source {

  }
}

.ActiveCodeBlock {
  border: 1px solid #ccc;
}

.SectionHeader {
  position: relative;
  margin-top: 1rem;
  ._Link {
    position: absolute;
    right: 100%;
    margin-right: 0.35em;
    top: 50%;
    margin-top: -0.65em;
    opacity: 0.5;
    text-decoration: none;
    &:hover {
      opacity: 1;
    }
  }
}
.prism-code-editor{overflow:auto;display:grid;background:var(--editor__bg);line-height:1.4;--_pse: var(--padding-inline, .75em);--_ns: var(--number-spacing, .75em);--padding-left: var(--_pse);scroll-padding-left:var(--padding-left);-webkit-user-select:none;user-select:none;isolation:isolate;white-space:pre}.show-line-numbers{--padding-left: calc(var(--_pse) + var(--number-width) + var(--_ns));grid:1fr / 0 1fr}.pce-wrapper{margin:.5em 0;position:relative;pointer-events:none;-webkit-text-size-adjust:none;text-size-adjust:none}.prism-code-editor textarea{all:unset;box-sizing:border-box;height:100%;width:100%;color:#0000;-webkit-user-select:auto;user-select:auto;overflow:hidden;pointer-events:auto;padding:0 var(--_pse) 0 var(--padding-left)}.pce-no-selection textarea:focus{z-index:1}.pce-line{padding:0 var(--_pse) 0 0;margin:0 0 0 var(--padding-left);position:relative}.show-line-numbers .pce-line:before{content:attr(data-line);display:inline-block;margin:0 0 0 calc(-1 * var(--padding-left));padding:0 var(--_ns) 0 0;box-sizing:border-box;color:var(--editor__line-number);text-align:end}.show-line-numbers:before{content:"";background:inherit;pointer-events:none}.show-line-numbers:before,.pce-line:before{position:sticky;height:100%;z-index:2;left:0;width:var(--padding-left)}.pce-wrap .pce-line:before{position:absolute}.pce-overlays,div.pce-overlays>*,.pce-no-selection .active-line:after,.active-line.match-highlight:after{content:"";position:absolute;top:0;right:0;bottom:0;left:0}.active-line:after{border:var(--editor__border-highlight);background:var(--editor__bg-highlight);z-index:-2}.pce-wrap{white-space:pre-wrap;word-break:break-word}.selection-matches span{background:var(--editor__bg-selection-match)}.pce-nowrap .active-bracket{display:inline-block}
@media (hover: hover){.prism-code-editor::-webkit-scrollbar-corner,.prism-code-editor::-webkit-scrollbar-track,.prism-code-editor ::-webkit-scrollbar-corner,.prism-code-editor ::-webkit-scrollbar-track{background:#0000}.prism-code-editor::-webkit-scrollbar,.prism-code-editor ::-webkit-scrollbar{height:1em;width:1em}.prism-code-editor::-webkit-scrollbar-thumb,.prism-code-editor ::-webkit-scrollbar-thumb{background:hsla(var(--editor__bg-scrollbar),.36);width:2em;height:2em}.prism-code-editor::-webkit-scrollbar-thumb:hover,.prism-code-editor ::-webkit-scrollbar-thumb:hover{background:hsla(var(--editor__bg-scrollbar),.5)}.prism-code-editor::-webkit-scrollbar-thumb:active,.prism-code-editor ::-webkit-scrollbar-thumb:active{background:hsla(var(--editor__bg-scrollbar),.66)}}
.prism-code-editor{caret-color:#000;font-family:Consolas,Monaco,Andale Mono,Ubuntu Mono,monospace;--editor__bg: #f5f2f0;--widget__border: #bfbfbf;--widget__bg: #edeae8;--widget__color: #444;--widget__color-active: #000;--widget__color-options: #666;--widget__bg-input: #f5f2f0;--widget__bg-hover: #b8b8b84f;--widget__bg-active: #c2dff2;--widget__focus-ring: #0077f0;--search__bg-find: #ea5c0054;--widget__bg-error: #f2dede;--widget__error-ring: #be1100;--editor__bg-highlight: #eae8e6;--editor__bg-selection-match: #b6d5fc80;--editor__line-number: #9d897b;--editor__bg-scrollbar: 24, 7%, 35%;--editor__bg-fold: #424242;--bg-guide-indent: #4b413a33;--pce-ac-icon-class: #d67e00;--pce-ac-icon-enum: #d67e00;--pce-ac-icon-function: #652d90;--pce-ac-icon-interface: #007acc;--pce-ac-icon-variable: #007acc;--pce-ac-match: #0066bf;--pce-tabstop: #0a326433;--pce-invisibles: #3333;color-scheme:light}.prism-code-editor textarea::selection{background:#b6d5fc;color:#0000}.pce-matches .match{--search__bg-find: #c7ada9}.active-line{--editor__line-number: #4d3a2e}.guide-indents .active{--bg-guide-indent: #38322f66}[class*=language-]{color:#000}.token.comment,.token.prolog,.token.doctype,.token.cdata{color:#708090}.token.punctuation,.token.attr-equals{color:#999}.token.namespace{opacity:.7}.token.property,.token.tag,.token.boolean,.token.number,.token.constant,.token.symbol,.token.deleted{color:#905}.token.selector,.token.attr-name,.token.string,.token.char,.token.builtin,.token.inserted{color:#690}.token.operator,.token.entity,.token.url,.language-css .token.string,.style .token.string{color:#9a6e3a}.token.atrule,.token.attr-value,.token.keyword{color:#07a}.token.function,.token.class-name{color:#dd4a68}.token.regex,.language-regex,.token.important,.token.variable{color:#e90}.token.important,.token.bold{font-weight:700}.token.italic{font-style:italic}.token.bracket-level-0,.token.bracket-level-3,.token.bracket-level-6,.token.bracket-level-9{color:#0431fa}.token.bracket-level-1,.token.bracket-level-4,.token.bracket-level-7,.token.bracket-level-10{color:#319331}.token.bracket-level-2,.token.bracket-level-5,.token.bracket-level-8,.token.bracket-level-11{color:#7b3814}.token.bracket-error{color:#ff1212cc}.token.markup-bracket{color:inherit}.active-bracket{box-shadow:inset 0 0 0 1px #b9b9b9,inset 0 0 0 9in #0064001a}.active-tagname,.word-matches span{background:#57575740}
</style>
</head>
<body data-activemd="false" data-filename="st-ives.md">
  <main id="activemd_active_doc"><h2 id="st-ives">St Ives</h2>
<p>An <a href="https://en.wikipedia.org/wiki/As_I_was_going_to_St_Ives">old riddle</a>.</p>
<blockquote>
<p>As <span class="js-amd-element" data-config="solo: I or we">I</span> <span class="js-amd-element" data-config="verb">was</span> going to <strong>St Ives</strong>,<br>I met a man with <span class="js-amd-element" data-config="wives: 1..10">7 wives</span>,<br>Every wife had <span class="js-amd-element" data-config="sacks: 1..10">7 sacks</span>,<br>Every sack had <span class="js-amd-element" data-config="cats: 1..10">7 cats</span>,<br>Every cat had <span class="js-amd-element" data-config="kits: 1..10">7 kits</span>:<br>Kits, cats, sacks, wives,<br>How many were going to St Ives?</p>
</blockquote>
<p>A <em>reasonable</em> guess is <span class="js-amd-element" data-config="first_guess">2752</span>, a sum of the beings the narrator met:</p>
<pre><code>const man   = 1;
total_sacks = wives * sacks;
total_cats  = total_sacks * cats;
total_kits  = total_cats * kits;

first_guess = man + wives + total_cats + total_kits;
</code></pre>
<p>And another guess might follow the second to last line more literally and sum <span class="js-amd-element" data-config="total_kits">2401 kits</span>, <span class="js-amd-element" data-config="total_cats">343 cats</span>, <span class="js-amd-element" data-config="total_sacks">49 sacks</span>, and <span class="js-amd-element" data-config="wives">7 wives</span> for an answer of <span class="js-amd-element" data-config="second_guess">2800</span>:</p>
<pre><code>second_guess = total_kits + total_cats + total_sacks + wives;
</code></pre>
<p>â€¦but the correct answer is <span class="js-amd-element" data-config="answer">1</span>.</p>
<pre><code>if (solo) {
  travelers = 1;
  verb = &#39;was&#39;;
} else {
  travelers = 2;
  verb = &#39;were&#39;;
}

answer = travelers;
</code></pre>
</main>
  <textarea disabled id="activemd_raw_source">%0A%23%23%20St%20Ives%0A%0AAn%20%5Bold%20riddle%5D(https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FAs_I_was_going_to_St_Ives).%0A%0A%3E%20As%20%5BI%5D%7Bsolo%3A%20I%20or%20we%7D%20%5Bwas%5D%7Bverb%7D%20going%20to%20**St%20Ives**%2C%0A%3E%20I%20met%20a%20man%20with%20%5B7%20wives%5D%7Bwives%3A%201..10%7D%2C%0A%3E%20Every%20wife%20had%20%5B7%20sacks%5D%7Bsacks%3A%201..10%7D%2C%0A%3E%20Every%20sack%20had%20%5B7%20cats%5D%7Bcats%3A%201..10%7D%2C%0A%3E%20Every%20cat%20had%20%5B7%20kits%5D%7Bkits%3A%201..10%7D%3A%0A%3E%20Kits%2C%20cats%2C%20sacks%2C%20wives%2C%0A%3E%20How%20many%20were%20going%20to%20St%20Ives%3F%0A%0AA%20_reasonable_%20guess%20is%20%5B2752%5D%7Bfirst_guess%7D%2C%20a%20sum%20of%20the%20beings%20the%20narrator%20met%3A%0A%0A%20%20%20%20const%20man%20%20%20%3D%201%3B%0A%20%20%20%20total_sacks%20%3D%20wives%20*%20sacks%3B%0A%20%20%20%20total_cats%20%20%3D%20total_sacks%20*%20cats%3B%0A%20%20%20%20total_kits%20%20%3D%20total_cats%20*%20kits%3B%0A%0A%20%20%20%20first_guess%20%3D%20man%20%2B%20wives%20%2B%20total_cats%20%2B%20total_kits%3B%0A%0AAnd%20another%20guess%20might%20follow%20the%20second%20to%20last%20line%20more%20literally%20and%20sum%20%5B2401%20kits%5D%7Btotal_kits%7D%2C%20%5B343%20cats%5D%7Btotal_cats%7D%2C%20%5B49%20sacks%5D%7Btotal_sacks%7D%2C%20and%20%5B7%20wives%5D%7Bwives%7D%20for%20an%20answer%20of%20%5B2800%5D%7Bsecond_guess%7D%3A%0A%0A%20%20%20%20second_guess%20%3D%20total_kits%20%2B%20total_cats%20%2B%20total_sacks%20%2B%20wives%3B%0A%0A%E2%80%A6but%20the%20correct%20answer%20is%20%5B1%5D%7Banswer%7D.%0A%0A%20%20%20%20if%20(solo)%20%7B%0A%20%20%20%20%20%20travelers%20%3D%201%3B%0A%20%20%20%20%20%20verb%20%3D%20'was'%3B%0A%20%20%20%20%7D%20else%20%7B%0A%20%20%20%20%20%20travelers%20%3D%202%3B%0A%20%20%20%20%20%20verb%20%3D%20'were'%3B%0A%20%20%20%20%7D%0A%0A%20%20%20%20answer%20%3D%20travelers%3B%0A</textarea>
  <script>
  /*
  Active Markdown is released under the MIT license.

  Copyright 2024 Alec Perkins <mail@alecperkins.me>

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.


  */
    const __amd_meta__ = JSON.parse(decodeURIComponent('%7B%7D'));
    (function () {
  'use strict';

  
      /*
      https://www.npmjs.com/package/prism-code-editor

      MIT License

Copyright (c) 2023 FIameCaster

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

      */
        var plainTextGrammar = {};
  var rest = Symbol();
  var tokenize = Symbol();
  var resolve = (id) => typeof id == "string" ? languages[id] : id;
  var languages = {
    plain: plainTextGrammar,
    plaintext: plainTextGrammar,
    text: plainTextGrammar,
    txt: plainTextGrammar
  };
  var tokenizeText = (text, grammar) => (grammar[tokenize] || withoutTokenizer)(text, grammar);
  var withoutTokenizer = (text, grammar) => {
    var startNode = [text];
    var restGrammar;
    var array = [], i = 0;
    while (restGrammar = resolve(grammar[rest])) {
      delete grammar[rest];
      Object.assign(grammar, restGrammar);
    }
    matchGrammar(text, grammar, startNode, 0);
    while (array[i++] = startNode[0], startNode = startNode[1])
      ;
    return array;
  };
  var closingTag = "</span>";
  var openingTags = "";
  var closingTags = "";
  var highlightTokens = (tokens) => {
    var str = "", l = tokens.length, i = 0;
    while (i < l)
      str += stringify(tokens[i++]);
    return str;
  };
  var stringify = (token) => {
    if (token instanceof Token) {
      var { type, alias, content } = token;
      var prevOpening = openingTags;
      var prevClosing = closingTags;
      var opening = `<span class="token ${type + (alias ? " " + alias : "") + (type == "keyword" && typeof content == "string" ? " keyword-" + content : "")}">`;
      closingTags += closingTag;
      openingTags += opening;
      var contentStr = stringify(content);
      openingTags = prevOpening;
      closingTags = prevClosing;
      return opening + contentStr + closingTag;
    }
    if (typeof token != "string")
      return highlightTokens(token);
    token = token.replace(/&/g, "&amp;").replace(/</g, "&lt;");
    if (closingTags && token.includes("\n")) {
      return token.replace(/\n/g, closingTags + "\n" + openingTags);
    }
    return token;
  };
  var matchGrammar = (text, grammar, startNode, startPos, rematch) => {
    for (var token in grammar) {
      if (grammar[token])
        for (var j = 0, p = grammar[token], patterns = Array.isArray(p) ? p : [p]; j < patterns.length; ++j) {
          if (rematch && rematch[0] == token && rematch[1] == j) {
            return;
          }
          var patternObj = patterns[j];
          var pattern = patternObj.pattern || patternObj;
          var inside = resolve(patternObj.inside);
          var lookbehind = patternObj.lookbehind;
          var greedy = patternObj.greedy && pattern.global;
          var alias = patternObj.alias;
          for (var currentNode = startNode, pos = startPos; currentNode && (!rematch || pos < rematch[2]); pos += currentNode[0].length, currentNode = currentNode[1]) {
            var str = currentNode[0];
            var removeCount = 0;
            var match, lookbehindLength;
            if (str instanceof Token) {
              continue;
            }
            pattern.lastIndex = greedy ? pos : 0;
            match = pattern.exec(greedy ? text : str);
            if (match && lookbehind && match[1]) {
              lookbehindLength = match[1].length;
              match.index += lookbehindLength;
              match[0] = match[0].slice(lookbehindLength);
            }
            if (greedy) {
              if (!match) {
                break;
              }
              if (match[0]) {
                for (var from = match.index, to = from + match[0].length, l; from >= pos + (l = currentNode[0].length); currentNode = currentNode[1], pos += l)
                  ;
                if (currentNode[0] instanceof Token) {
                  continue;
                }
                for (var k = currentNode, p = pos; (p += k[0].length) < to; k = k[1], removeCount++)
                  ;
                str = text.slice(pos, p);
                match.index -= pos;
              }
            }
            if (!(match && match[0])) {
              continue;
            }
            var from = match.index;
            var matchStr = match[0];
            var after = str.slice(from + matchStr.length);
            var reach = pos + str.length;
            var newToken = new Token(token, inside ? tokenizeText(matchStr, inside) : matchStr, matchStr, alias);
            var next = currentNode, i = 0;
            var nestedRematch;
            while (next = next[1], i++ < removeCount)
              ;
            if (after) {
              if (!next || next[0] instanceof Token)
                next = [after, next];
              else
                next[0] = after + next[0];
            }
            pos += from;
            currentNode[0] = from ? str.slice(0, from) : newToken;
            if (from)
              currentNode = currentNode[1] = [newToken, next];
            else
              currentNode[1] = next;
            if (removeCount) {
              matchGrammar(text, grammar, currentNode, pos, nestedRematch = [token, j, reach]);
              reach = nestedRematch[2];
            }
            if (rematch && reach > rematch[2])
              rematch[2] = reach;
          }
        }
    }
  };
  function Token(type, content, matchedStr, alias) {
    this.type = type;
    this.content = content;
    this.alias = alias;
    this.length = matchedStr.length;
  }

  var clikeComment = () => ({
    pattern: /\/\/.*|\/\*[^]*?(?:\*\/|$)/g,
    greedy: true
  });
  var clikeString = () => ({
    pattern: /(["'])(?:\\[^]|(?!\1)[^\\\n])*\1/g,
    greedy: true
  });
  var boolean = /\b(?:false|true)\b/;

  var js = {};
  languages.js = languages.javascript = Object.assign(js, {
    "doc-comment": {
      pattern: /\/\*\*(?!\/)[^]*?(?:\*\/|$)/g,
      greedy: true,
      alias: "comment",
      inside: "jsdoc"
    },
    "comment": clikeComment(),
    "hashbang": {
      pattern: /^#!.*/g,
      greedy: true,
      alias: "comment"
    },
    "template-string": {
      pattern: /`(?:\\[^]|\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})*\}|(?!\$\{)[^\\`])*`/g,
      greedy: true,
      inside: {
        "template-punctuation": {
          pattern: /^`|`$/,
          alias: "string"
        },
        "interpolation": {
          pattern: /((?:^|[^\\])(?:\\\\)*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})*\}/,
          lookbehind: true,
          inside: {
            "interpolation-punctuation": {
              pattern: /^\$\{|\}$/,
              alias: "punctuation"
            },
            [rest]: js
          }
        },
        "string": /[^]+/
      }
    },
    "string-property": {
      pattern: /((?:^|[,{])[ 	]*)(["'])(?:\\[^]|(?!\2)[^\\\n])*\2(?=\s*:)/mg,
      lookbehind: true,
      greedy: true,
      alias: "property"
    },
    "string": clikeString(),
    "regex": {
      pattern: /((?:^|[^$\w\xa0-\uffff"'`.)\]\s]|\b(?:return|yield))\s*)\/(?:(?:\[(?:\\.|[^\\\n\]])*\]|\\.|[^\\\n/[])+\/[dgimyus]{0,7}|(?:\[(?:\\.|[^\\\n[\]]|\[(?:\\.|[^\\\n[\]]|\[(?:\\.|[^\\\n[\]])*\])*\])*\]|\\.|[^\\\n/[])+\/[dgimyus]{0,7}v[dgimyus]{0,7})(?=(?:\s|\/\*(?:[^*]|\*(?!\/))*\*\/)*(?!\/\*|[^()[\]{}.,:;?`\n%&|^!=<>/*+-]))/g,
      lookbehind: true,
      greedy: true,
      inside: {
        "regex-flags": /\w+$/,
        "regex-delimiter": /^\/|\/$/,
        "regex-source": {
          pattern: /.+/,
          alias: "language-regex",
          inside: "regex"
        }
      }
    },
    "class-name": [
      {
        pattern: /(\b(?:class|extends|implements|instanceof|interface|new)\s+)(?!\d)(?:(?!\s)[$\w.\xa0-\uffff])+/,
        lookbehind: true,
        inside: {
          "punctuation": /\./
        }
      },
      {
        pattern: /(^|[^$\w\xa0-\uffff]|\s)(?![a-z\d])(?:(?!\s)[$\w\xa0-\uffff])+(?=\.(?:constructor|prototype)\b)/,
        lookbehind: true
      }
    ],
    // This must be declared before keyword because we use "function" inside the look-forward
    "function-variable": {
      pattern: /#?(?!\d)(?:(?!\s)[$\w\xa0-\uffff])+(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^)]*\))*\)|(?!\d)(?:(?!\s)[$\w\xa0-\uffff])+)\s*=>))/,
      alias: "function",
      inside: {
        "maybe-class-name": /^[A-Z].*/
      }
    },
    "parameter": [
      /(function(?:\s+(?!\d)(?:(?!\s)[$\w\xa0-\uffff])+)?\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\))/,
      /(^|[^$\w\xa0-\uffff]|\s)(?!\d)(?:(?!\s)[$\w\xa0-\uffff])+(?=\s*=>)/,
      /(\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*=>)/,
      /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|continue|default|do|else|finally|for|if|return|switch|throw|try|while|yield|class|const|debugger|delete|enum|extends|function|[gs]et|export|from|import|implements|in|instanceof|interface|let|new|null|of|package|private|protected|public|static|super|this|typeof|undefined|var|void|with)(?![$\w\xa0-\uffff]))(?:(?!\d)(?:(?!\s)[$\w\xa0-\uffff])+\s*)\(\s*|\]\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*\{)/
    ].map((pattern) => ({
      pattern,
      lookbehind: true,
      inside: js
    })),
    "constant": /\b[A-Z](?:[A-Z_]|\dx?)*\b/,
    "keyword": [
      {
        pattern: /(^|[^.]|\.{3}\s*)\b(?:as|assert(?=\s*\{)|export|from(?!\s*[^\s"'])|import)\b/,
        alias: "module",
        lookbehind: true
      },
      {
        pattern: /(^|[^.]|\.{3}\s*)\b(?:await|break|case|catch|continue|default|do|else|finally|for|if|return|switch|throw|try|while|yield)\b/,
        alias: "control-flow",
        lookbehind: true
      },
      {
        pattern: /(^|[^.]|\.{3}\s*)\b(?:async(?!\s*[^\s($\w\xa0-\uffff])|class|const|debugger|delete|enum|extends|function|[gs]et(?!\s*[^\s#[$\w\xa0-\uffff])|implements|in|instanceof|interface|let|new|null|of|package|private|protected|public|static|super|this|typeof|undefined|var|void|with)\b/,
        lookbehind: true
      }
    ],
    "boolean": boolean,
    // Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)
    "function": {
      pattern: /#?(?!\d)(?:(?!\s)[$\w\xa0-\uffff])+(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,
      inside: {
        "maybe-class-name": /^[A-Z].*/
      }
    },
    "number": {
      pattern: /(^|[^$\w])(?:NaN|Infinity|0[bB][01]+(?:_[01]+)*n?|0[oO][0-7]+(?:_[0-7]+)*n?|0[xX][a-fA-F\d]+(?:_[a-fA-F\d]+)*n?|\d+(?:_\d+)*n|(?:\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\.\d+(?:_\d+)*)(?:[Ee][+-]?\d+(?:_\d+)*)?)(?![$\w])/,
      lookbehind: true
    },
    "literal-property": {
      pattern: /([\n,{][ 	]*)(?!\d)(?:(?!\s)[$\w\xa0-\uffff])+(?=\s*:)/,
      lookbehind: true,
      alias: "property"
    },
    "operator": [
      {
        pattern: /=>/,
        alias: "arrow"
      },
      /--|\+\+|(?:\*\*|&&|\|\||[!=]=|>>>?|<<|[%&|^!=<>/*+-]|\?\?)=?|\.{3}|\?(?!\.)|~|:/
    ],
    "property-access": {
      pattern: /(\.\s*)#?(?!\d)(?:(?!\s)[$\w\xa0-\uffff])+/,
      lookbehind: true,
      inside: {
        "maybe-class-name": /^[A-Z].*/
      }
    },
    "maybe-class-name": {
      pattern: /(^|[^$\w\xa0-\uffff])[A-Z][$\w\xa0-\uffff]+/,
      lookbehind: true
    },
    "punctuation": /\?\.|[()[\]{}.,:;]/
  });

  languages.webmanifest = languages.json = {
    "property": {
      pattern: /"(?:\\.|[^\\\n"])*"(?=\s*:)/g,
      greedy: true
    },
    "string": {
      pattern: /"(?:\\.|[^\\\n"])*"/g,
      greedy: true
    },
    "comment": clikeComment(),
    "number": /-?\b\d+(?:\.\d+)?(?:e[+-]?\d+)?\b/i,
    "operator": /:/,
    "punctuation": /[[\]{},]/,
    "boolean": boolean,
    "null": {
      pattern: /\bnull\b/,
      alias: "keyword"
    }
  };

  languages.csv = {
    "value": /[^\n,"]+|"(?:[^"]|"")*"(?!")/,
    "punctuation": /,/
  };

  const createEditor = (container, options, ...extensions) => {
    let language;
    let grammar;
    let prevLines = [];
    let activeLine;
    let value = "";
    let activeLineNumber;
    let removed = false;
    let focused = false;
    let handleSelectionChange = true;
    let tokens = [];
    let readOnly;
    let lineCount = 0;
    const scrollContainer = editorTemplate();
    const wrapper = scrollContainer.firstChild;
    const lines = wrapper.children;
    const overlays = lines[0];
    const textarea = overlays.firstChild;
    const currentOptions = { language: "text", value };
    const currentExtensions = new Set(extensions);
    const listeners = {};
    const setOptions = (options2) => {
      Object.assign(currentOptions, options2);
      value = options2.value ?? value;
      language = currentOptions.language;
      if (!languages[language])
        throw Error(`Language '${language}' has no grammar.`);
      readOnly = !!currentOptions.readOnly;
      scrollContainer.style.tabSize = currentOptions.tabSize || 2;
      textarea.inputMode = readOnly ? "none" : "";
      textarea.setAttribute("aria-readonly", readOnly);
      updateClassName();
      updateExtensions();
      if (grammar != (grammar = languages[language]) || value != textarea.value) {
        focusRelatedTarget();
        textarea.value = value;
        textarea.selectionEnd = 0;
        update();
      }
    };
    const update = () => {
      tokens = tokenizeText(value = textarea.value, grammar);
      dispatchEvent("tokenize", tokens, language, value);
      let newLines = highlightTokens(tokens).split("\n");
      let start = 0;
      let end2 = lineCount;
      let end1 = lineCount = newLines.length;
      while (newLines[start] == prevLines[start] && start < end1)
        ++start;
      while (end1 && newLines[--end1] == prevLines[--end2])
        ;
      if (start == end1 && start == end2)
        lines[start + 1].innerHTML = newLines[start] + "\n";
      else {
        let insertStart = end2 < start ? end2 : start - 1;
        let i = insertStart;
        let newHTML = "";
        while (i < end1)
          newHTML += `<div class=pce-line aria-hidden=true>${newLines[++i]}
</div>`;
        for (i = end1 < start ? end1 : start - 1; i < end2; i++)
          lines[start + 1].remove();
        if (newHTML)
          lines[insertStart + 1].insertAdjacentHTML("afterend", newHTML);
        for (i = insertStart + 1; i < lineCount; )
          lines[++i].setAttribute("data-line", i);
        scrollContainer.style.setProperty(
          "--number-width",
          Math.ceil(Math.log10(lineCount + 1)) + ".001ch"
        );
      }
      dispatchEvent("update", value);
      dispatchSelection(true);
      if (handleSelectionChange)
        setTimeout(setTimeout, 0, () => handleSelectionChange = true);
      prevLines = newLines;
      handleSelectionChange = false;
    };
    const updateExtensions = (newExtensions) => {
      (newExtensions || currentExtensions).forEach((extension) => {
        if (typeof extension == "object") {
          extension.update(self, currentOptions);
          if (newExtensions)
            currentExtensions.add(extension);
        } else {
          extension(self, currentOptions);
          if (!newExtensions)
            currentExtensions.delete(extension);
        }
      });
    };
    const updateClassName = ([start, end] = getInputSelection()) => {
      scrollContainer.className = `prism-code-editor language-${language}${currentOptions.lineNumbers == false ? "" : " show-line-numbers"} pce-${currentOptions.wordWrap ? "" : "no"}wrap${currentOptions.rtl ? " pce-rtl" : ""} pce-${start < end ? "has" : "no"}-selection${focused ? " pce-focus" : ""}${readOnly ? " pce-readonly" : ""}`;
    };
    const getInputSelection = () => [
      textarea.selectionStart,
      textarea.selectionEnd,
      textarea.selectionDirection
    ];
    const keyCommandMap = {
      Escape() {
        textarea.blur();
      }
    };
    const inputCommandMap = {};
    const focusRelatedTarget = () => isWebKit && !focused && addTextareaListener(
      self,
      "focus",
      (e) => {
        let relatedTarget = e.relatedTarget;
        if (relatedTarget)
          relatedTarget.focus();
        else
          textarea.blur();
      },
      { once: true }
    );
    const dispatchEvent = (name, ...args) => {
      listeners[name]?.forEach((handler) => handler.apply(self, args));
      currentOptions["on" + name[0].toUpperCase() + name.slice(1)]?.apply(self, args);
    };
    const dispatchSelection = (force) => {
      if (force || handleSelectionChange) {
        const selection = getInputSelection();
        const newLine = lines[activeLineNumber = numLines(value, 0, selection[selection[2] < "f" ? 0 : 1])];
        if (newLine != activeLine) {
          activeLine?.classList.remove("active-line");
          newLine.classList.add("active-line");
          activeLine = newLine;
        }
        updateClassName(selection);
        dispatchEvent("selectionChange", selection, value);
      }
    };
    const self = {
      scrollContainer,
      wrapper,
      overlays,
      textarea,
      get activeLine() {
        return activeLine;
      },
      get activeLineNumber() {
        return activeLineNumber;
      },
      get value() {
        return value;
      },
      options: currentOptions,
      get focused() {
        return focused;
      },
      get removed() {
        return removed;
      },
      get tokens() {
        return tokens;
      },
      inputCommandMap,
      keyCommandMap,
      extensions: {},
      setOptions,
      update,
      getSelection: getInputSelection,
      setSelection(start, end = start, direction) {
        focusRelatedTarget();
        textarea.setSelectionRange(start, end, direction);
        dispatchSelection(true);
      },
      addExtensions(...extensions2) {
        updateExtensions(extensions2);
      },
      addListener(name, handler) {
        (listeners[name] || (listeners[name] = /* @__PURE__ */ new Set())).add(handler);
      },
      removeListener(name, handler) {
        listeners[name]?.delete(handler);
      },
      remove() {
        scrollContainer.remove();
        removed = true;
      }
    };
    addTextareaListener(self, "keydown", (e) => {
      keyCommandMap[e.key]?.(e, getInputSelection(), value) && preventDefault(e);
    });
    addTextareaListener(self, "beforeinput", (e) => {
      if (readOnly || e.inputType == "insertText" && inputCommandMap[e.data]?.(e, getInputSelection(), value))
        preventDefault(e);
    });
    addTextareaListener(self, "input", update);
    addTextareaListener(self, "blur", () => {
      selectionChange = null;
      focused = false;
      updateClassName();
    });
    addTextareaListener(self, "focus", () => {
      selectionChange = dispatchSelection;
      focused = true;
      updateClassName();
    });
    addTextareaListener(self, "selectionchange", (e) => {
      dispatchSelection();
      preventDefault(e);
    });
    getElement(container)?.append(scrollContainer);
    options && setOptions(options);
    return self;
  };
  const templateEl = /* @__PURE__ */ document.createElement("div");
  const createTemplate = (html) => {
    templateEl.innerHTML = html;
    const node = templateEl.firstChild;
    return () => node.cloneNode(true);
  };
  const addTextareaListener = (editor, type, listener, options) => editor.textarea.addEventListener(type, listener, options);
  const getElement = (el) => typeof el == "string" ? document.querySelector(el) : el;
  const userAgent = navigator.userAgent;
  const isChrome = /Chrome\//.test(userAgent);
  const isWebKit = !isChrome && /AppleWebKit\//.test(userAgent);
  const numLines = (str, start = 0, end = Infinity) => {
    let count = 1;
    for (; (start = str.indexOf("\n", start) + 1) && start <= end; count++)
      ;
    return count;
  };
  const editorTemplate = /* @__PURE__ */ createTemplate(
    "<div><div class=pce-wrapper><div class=pce-overlays><textarea spellcheck=false autocapitalize=off autocomplete=off>"
  );
  const preventDefault = (e) => {
    e.preventDefault();
    e.stopImmediatePropagation();
  };
  let selectionChange;
  document.addEventListener("selectionchange", () => selectionChange?.());

  const matchBrackets = (rainbowBrackets = true, openingBrackets = "([{", closingBrackets = ")]}") => {
    let bracketIndex;
    let sp;
    const stack = [];
    const self = (editor) => {
      editor.extensions.matchBrackets = self;
      editor.addListener("tokenize", matchBrackets2);
      if (rainbowBrackets && editor.tokens[0])
        editor.update();
      else
        matchBrackets2(editor.tokens);
    };
    const brackets = self.brackets = [];
    const pairMap = self.pairs = [];
    const matchBrackets2 = (tokens) => {
      pairMap.length = brackets.length = sp = bracketIndex = 0;
      matchRecursive(tokens, 0);
      if (rainbowBrackets) {
        for (let i = 0, bracket; bracket = brackets[i]; ) {
          let alias = bracket[0].alias;
          bracket[0].alias = (alias ? alias + " " : "") + `bracket-${i++ in pairMap ? "level-" + bracket[2] % 12 : "error"}`;
        }
      }
    };
    const matchRecursive = (tokens, position) => {
      let token;
      let i = 0;
      for (; token = tokens[i++]; ) {
        let length = token.length;
        if (typeof token != "string") {
          let content = token.content;
          if (Array.isArray(content)) {
            matchRecursive(content, position);
          } else if ((token.alias || token.type) == "punctuation") {
            let openingType = testBracket(content, openingBrackets, length - 1);
            let closingType = openingType || testBracket(content, closingBrackets, length - 1);
            if (closingType) {
              brackets[bracketIndex] = [token, position, 0, content, !!openingType, position + length];
              if (openingType)
                stack[sp++] = [bracketIndex, openingType];
              else {
                for (let i2 = sp; i2; ) {
                  let [index, type] = stack[--i2];
                  if (closingType == type) {
                    pairMap[pairMap[bracketIndex] = index] = bracketIndex;
                    brackets[bracketIndex][2] = brackets[index][2] = sp = i2;
                    i2 = 0;
                  }
                }
              }
              bracketIndex++;
            }
          }
        }
        position += length;
      }
    };
    return self;
  };
  const testBracket = (str, brackets, l) => {
    return brackets.indexOf(str[0]) + 1 || l && brackets.indexOf(str[l]) + 1;
  };

  const template = createTemplate(
    "<div class=guide-indents style=left:var(--padding-left);bottom:auto;right:auto> "
  );
  const indentTemplate = createTemplate(
    "<div style=width:1px;position:absolute;background:var(--bg-guide-indent)>"
  );
  const indentGuides = () => {
    let tabSize;
    let prevLength = 0;
    let lineIndentMap;
    let active = -1;
    let currentEditor;
    const lines = [];
    const indents = [];
    const container = template();
    const indentLevels = [];
    const update = (code) => {
      lineIndentMap = [];
      const newIndents = getIndents(code.split("\n"));
      const l = newIndents.length;
      for (let i = 0, prev = [], next = newIndents[0]; next; i++) {
        const style = (lines[i] || (lines[i] = indentTemplate())).style;
        const [top, height, left] = next;
        const old = indents[i];
        next = newIndents[i + 1];
        if (top != old?.[0])
          style.top = top + "00%";
        if (height != old?.[1])
          style.height = height + "00%";
        if (left != old?.[2])
          style.left = left * 100 + "%";
        const isSingleIndent = prev[0] != top && next?.[0] != top, isSingleOutdent = prev[0] + prev[1] != top + height && next?.[0] + next?.[1] != top + height;
        for (let j = -isSingleIndent, l2 = height + isSingleOutdent; j < l2; j++)
          lineIndentMap[j + top] = i;
        prev = indents[i] = newIndents[i];
      }
      for (let i = prevLength; i > l; )
        lines[--i].remove();
      container.append(...lines.slice(prevLength, prevLength = l));
    };
    const updateActive = () => {
      const newActive = lineIndentMap[currentEditor.activeLineNumber - 1] ?? -1;
      if (newActive != active) {
        active > -1 && (lines[active].className = "");
        newActive > -1 && (lines[newActive].className = "active");
      }
      active = newActive;
    };
    const getIndents = (lines2) => {
      const l = lines2.length;
      const stack = [];
      const results = [];
      for (let prevIndent = 0, emptyPos = -1, i = 0, p = 0; ; i++) {
        const last = i == l;
        const indent = last ? 0 : indentLevels[i] = getIndentCount(lines2[i]);
        if (indent < 0) {
          if (emptyPos < 0)
            emptyPos = i;
        } else {
          for (let j = indent; j < prevIndent; j++) {
            stack[j][1] = (emptyPos < 0 || j == indent && !last ? i : emptyPos) - stack[j][0];
          }
          for (let j = prevIndent; j < indent; ) {
            results[p++] = stack[j] = [
              emptyPos < 0 || j > prevIndent ? i : emptyPos,
              0,
              j++ * tabSize
            ];
          }
          emptyPos = -1;
          prevIndent = indent;
        }
        if (last)
          break;
      }
      indentLevels.length = l;
      return results;
    };
    const getIndentCount = (text) => {
      let l = text.search(/\S/);
      let result = 0;
      if (l < 0)
        return l;
      for (let i = 0; i < l; ) {
        result += text[i++] == "	" ? tabSize - result % tabSize : 1;
      }
      return Math.ceil(result / tabSize);
    };
    return {
      lines: container.children,
      indentLevels,
      update(editor, options) {
        if (!currentEditor) {
          currentEditor = editor;
          editor.extensions.indentGuides = this;
          editor.overlays.append(container);
          editor.addListener("update", update);
          editor.addListener("selectionChange", updateActive);
        }
        container.style.display = options.wordWrap ? "none" : "";
        if (tabSize != (tabSize = options.tabSize || 2))
          update(editor.value), updateActive();
      }
    };
  };

  // // index.ts
  // import "prism-code-editor/prism/languages/markup"
  // import "prism-code-editor/prism/languages/css-extras"

  // // Importing styles
  // import "prism-code-editor/layout.css"
  // import "prism-code-editor/scrollbar.css"
  // import "prism-code-editor/themes/github-dark.css"



  // import('./extensions')

  class CodeEditor {
    constructor (el, language="javascript") {
      this.el = el;
      this.el.classList.add('CodeEditor');
      // this.el.setAttribute('contenteditable', true);
      this._callbacks = [];
      const initial_value = this.el.textContent;
      this.el.textContent = '';
      this._editor = createEditor(
        this.el,
        {
          language,
          value: initial_value,
          lineNumbers: false,
          onUpdate: this._triggerChange.bind(this),
        },
        indentGuides(),
        matchBrackets(),
      );
    }
    onChange (callback) {
      this._callbacks.push(callback);
    }

    _triggerChange () {
      this._callbacks.forEach((fn) => {
        fn();
      });
    }

    getValue () {
      return this._editor.value;
    }
  }

  class DragManager {
    constructor () {
      this._window = window;
      this._body_el = document.body;
      this._reset();

      this._boundDrag = this._drag.bind(this);
      this._boundStop = this._stop.bind(this);
    }

    /**
     * Private: reset the drag manager and related document styles (cursor).
      Returns nothing.
     */
    _reset () {
      this.is_dragging = false;
      if (this._direction !== null) {
        this._body_el.dataset[`dragging_${ this._direction }`] = false;
      }
      this._dragging_target = null;
      this._drag_start_x = null;
      this._drag_start_y = null;
      this._direction = null;
    }
    /*
    Private: prepare the mouse position information for the handlers.

    cur_x - the integer current x position of the cursor
    cur_y - the integer current y position of the cursor

    Returns an object with the initial coordinates, and the change in position.
    */
    _assembleUI (cur_x, cur_y) {
      return {
        x_start : this._drag_start_x,
        y_start : this._drag_start_y,
        x_delta : cur_x - this._drag_start_x,
        y_delta : cur_y - this._drag_start_y,
      };
    }


    /*
    Public: initiate a drag operation for a given view.

    e           - the jQuery.Event from the initial mousedown event
    view        - the BaseElementView of the element starting the drag
    direction   - the String direction of the drag: 'x', 'y', or 'both'

    Returns nothing.
    */
    start (e, view, direction) {
      this._is_dragging = true;
      const { pageX, pageY } = e;
      this._direction = direction;
      this._drag_start_x = pageX;
      this._drag_start_y = pageY;
      this._dragging_target = view;
      this._window.addEventListener('mousemove', this._boundDrag);
      this._window.addEventListener('mouseup', this._boundStop);
      this._window.addEventListener('touchmove', this._boundDrag);
      this._window.addEventListener('touchend', this._boundStop);
      this._body_el.dataset[`dragging_${ this._direction }`] = true;
    }

    _drag (e) {
      const { pageX, pageY } = e;
      const ui = this._assembleUI(pageX, pageY);
      this._dragging_target.onDrag?.(ui);
    }

    _stop (e) {
      this._window.removeEventListener('mousemove', this._boundDrag);
      this._window.removeEventListener('mouseup', this._boundStop);
      if (this._dragging_target != null) {
        const { pageX, pageY } = e;
        const ui = this._assembleUI(pageX, pageY);
        this._dragging_target.stopDragging?.(ui);
        this._reset();
      }
    }
  }

  const doc_variables = {};
  const doc_elements = {};
  const doc_embeds = {};

  const drag_manager = new DragManager(document, window);

  let latest_id = 1;
  function generateId () {
    latest_id += 1;
    return latest_id.toString(36);
  }

  function registerElement (element) {
    const id = generateId();
    element.el.dataset.activemd_id = id;
    doc_elements[id] = element;
  }


  window.ActiveMarkdown = {
    variables: doc_variables,
    elements: doc_elements,
    embeds: doc_embeds,
  };

  class Executor {

    constructor (amd_meta) {
      this._amd_meta = amd_meta;
      this._code_blocks = [];
      Object.entries(doc_variables).forEach(([name, variable]) => {
        variable.onChange(this.run.bind(this), true);
      });
    }

    addBlock (block) {
      block.el.classList.add('ActiveCodeBlock');
      block.editor = new CodeEditor(block.el);
      block.editor.onChange(this.run.bind(this));
      this._code_blocks.push(block);
    }

    run () {
      this._execute();
    }

    _execute () {
      if (this._code_blocks.length === 0) {
        return;
      }
      const user_source = this._code_blocks.map(b => b.editor.getValue()).join(';\n'); // ; to guard against poorly placed )s
      const input = {};
      Object.entries(doc_variables).forEach(([name, variable]) => {
        input[name] = variable.getValue();
      });
      const var_list = Object.keys(doc_variables);
      const var_name_spread = var_list.length > 0 ? `{${var_list.join(',')}}` : '{__empty_var_list}';
      const full_source = `
let ${ var_name_spread } = __amd_input;
let meta = __amd_meta;
${user_source}
;return ${var_name_spread};
`;
      let output;
      let fn;
      try {
        fn = Function("__amd_input", "__amd_meta", full_source);
      } catch (error) {
        // Compilation errors are fine since they will happen while editing the code.
        console.debug(error);
        output = {...input};
      }

      if (fn) {
        try {
          output = fn.call(null, {...input}, this._amd_meta);
        } catch (error) {
          console.error(error);
          output = {...input};
        }
      }
      Object.keys(input).forEach((name) => {
        if (doc_variables[name]) {
          const value = output[name];
          doc_variables[name].setValue(value, true);
        } else {
          throw new Error(`Attempted assignment to unknown Document variable: ${name}`);
        }
      });
    }

  }

  /*

  Numbers in Active Markdown are ordinary `Number` values for the most part, but also MAY include various constants from `Math` as a multiplier. For example, `2pi` is equivalent to `2 * Math.PI`, while `0.5e` is equivalent to `0.5 * Math.E`. The constants may be specified without a digit, eg `pi` or `ln2`. Also, they may be specified in lowercase or uppercase, or some combination of the two, if you're into that.
  */
  function parseNumber (val) {
    const constants = ['E', 'PI', 'LN2', 'LN10', 'LOG2E', 'LOG10E', 'SQRT1_2', 'SQRT2'];
    let parsed_val = null;

    // Check the value for each constant, allowing for just a constant
    // with no coefficient.
    for (const c of constants) {
      const r = RegExp(`([+-]?)([\\d\\.]*)${ c }`);
      const group = val.toUpperCase().match(r);

      // If the number matches a constant, generate the equivalent
      // expression and calculate the actual value of the number.
      if (group) {
        const sign = group[1] === '-' ? -1 : 1;
        const mult = group[2] ? (new Number(group[2])) : 1;
        parsed_val = sign * mult * Math[c];
        break
      }

    }

    // If the value is still null, the number didn't have any constants, so
    // just parse it as a regular Number.
    if (parsed_val == null) {
      parsed_val = parseFloat(val);
    }

    return parsed_val
  }

  // The step of a range defaults to 1, but can be specified using the `by` keyword after the min/max. The step is an Active Markdown Number, and can include the constants described above.
  //
  // A range described with `0..10` will have a step of `1`, while `0..10 by 0.1` will have a step of `0.1`, and `0..10 by pi` will have a step of `Math.PI`.
  function parseStep (val) {
    if (val) {
      const as_str = val.replace(' by ','');
      const as_number = parseNumber(as_str);
      // if (Number.isNaN(as_number)) {
      //   return as_str;
      // }
      return as_number;
    }
    return 1;
  }

  // Ranges in Active Markdown work the same as in CoffeeScript; two dots describes an inclusive range, while three dots excludes the tail. (The check here is only if there are two dots or not since the element configuration parsing regex limits the match to `'..'` or `'...'`.)
  function parseInclusivity (dots) {
    return dots.length === 2;
  }

  class Variable {

    static getOrCreate (name, initial_value) {
      if (doc_variables[name]) {
        return doc_variables[name];
      }
      return new Variable(name, initial_value);
    }

    constructor (name, initial_value=undefined, options={}) {
      this.is_dataset = options.is_dataset || false;
      this._element_callbacks = [];
      this._code_block_callbacks = [];
      this._name = name;
      this._value = initial_value;

      if (doc_variables[name]) {
        throw new Error(`Variable name repeated: ${ name }`);
      }

      doc_variables[name] = this;
    }
    onChange (callback, is_code_block=false) {
      if (is_code_block) {
        this._code_block_callbacks.push(callback);
      } else {
        this._element_callbacks.push(callback);
      }
    }
    getName () {
      return this._name;
    }
    getValue () {
      return this._value;
    }
    setValue (value, trigger_elements_only=false) {
      this._value = value;
      this._triggerOnChange(trigger_elements_only);
    }

    _triggerOnChange (trigger_elements_only=false) {
      this._element_callbacks.forEach((callback) => {
        callback(this._value, this._name);
      });
      if (!trigger_elements_only) {
        this._code_block_callbacks.forEach((callback) => {
          callback(this._value, this._name);
        });
      }
    }
  }

  class BaseElement {
    constructor (el) {
      this.el = el;
      this.el.classList.add("BaseElement");
      this.el.setAttribute("tabindex", 0);
      this._active_ping_timeout = null;
      registerElement(this);
    }
    _pingChanged () {
      clearTimeout(this._active_ping_timeout);
      this.el.dataset.is_active = true;
      this._active_ping_timeout = setTimeout(() => {
        this.el.dataset.is_active = false;
      }, 2000);
    }
  }

  class RangeElement extends BaseElement {
    static config_pattern = new RegExp(`
    ^(                      # Variable
      [\\w\\d]+               # - name
    )

      :\\s                   # Delimiter

    (                       # Range min, if any:
      [+|-]?                        # - sign, if any
      (?:[\\d]*[\\.]?[\\d]+)?          # - coefficient, if any
      [102EGILONQPSRT_egilonqpsrt]* # - constant, if any
    )

    (                       # Inclusivity
      [\\.]{2,3}             # - dots
    )

    (                       # Range max, if any:
      [+|-]?                        # - sign, if any
      (?:[\\d]*[\\.]?[\\d]+)?          # - coefficient, if any
      [102EGILONQPSRT_egilonqpsrt]* # - constant, if any
    )

    (                       # Step, if any:
      \\sby\\s                # - by keyword

        (?:                 # - step value
          [+|-]?                        # - sign, if any
          (?:[\\d]*[\\.]?[\\d]+)?          # - coefficient, if any
          [102EGILONQPSRT_egilonqpsrt]* # - constant, if any
        )

    )*$
  `.replace(/#.*\n/g,'').replace(/\s+/g,'')
    );

    /*
    [
        "calories: 10..100 by 10",
        "calories",
        "10",
        "..",
        "100",
        " by 10",
        index: 0,
        input: "calories: 10..100 by 10"
    ]
    */
    static _parseConfig (config_text) {
      const config_match = config_text.match(this.config_pattern);
      if (!config_match) { return null; }

      const [text, var_name, min_str, dots, max_str, step_str] = config_match;
      let min;
      let max;
      let initial_value;

      if (min_str) {
        min = parseNumber(min_str);
      } else {
      min = null;
      }

      if (max_str) {
        max = parseNumber(max_str);
      } else {
        max = null;
      }

      if (min && max) {
        initial_value = (max - min) / 2;
      } else {
        initial_value = 0;
      }

      const config = {
        name        : var_name,
        min         : min,
        max         : max,
        inclusive   : parseInclusivity(dots),
        step        : parseStep(step_str),
        value       : initial_value,
      };
      return config;
    }

    /*
      Private: parse the text content of the element for default value, display
               precision, and additional text.

      text_content - the String text version of the element

      Return the default value for the variable.
    */
    static _parseTextContent (parsed_config, text_content) {
      let default_value     = parsed_config.value;
      let before_text       = '';
      let after_text        = '';
      let display_precision = null;

      /*
          [
            '$200.0 per day',
            '$',
            '200',
            '.',
            '0',
            ' per day',
            index: 0,
            input: '$200.0 per day'
          ]
      */
      const pattern = /([a-zA-Z=:$ ]*)([\-\d]+)(\.?)(\d*)([a-zA-Z=: ]*)/;
      const match_group = text_content.match(pattern);
      if (match_group) {
        const [
          _text,
          before_text_str,
          value_str,
          point_str,
          decimal_str,
          after_text_str,
        ] = match_group;
        before_text = before_text_str;
        after_text = after_text_str;
        default_value = parseFloat([value_str, point_str, decimal_str].join(''));
        if (point_str) {
          display_precision = decimal_str.length;
        }
      }
      return {
        default_value,
        before_text,
        after_text,
        display_precision,
      };
    }

    constructor (el) {
      super(el);
      this.els = {};
      const parsed_config = RangeElement._parseConfig(el.dataset.config);
      const parsed_text = RangeElement._parseTextContent(parsed_config, el.textContent);
      this._before_text = parsed_text.before_text;
      this._after_text = parsed_text.after_text;
      this._display_precision = parsed_text.display_precision;
      this._text_content = el.textContent;
      this.variable = new Variable(parsed_config.name, parsed_text.default_value);
      this.variable.onChange(() => this._renderUpdate());
      this._initial_value = parsed_text.default_value;
      this._config = parsed_config;
      this._renderInitial();
      this._last_click = 0;
      this._drag_manager = drag_manager;
    }

    _renderInitial () {
      this.el.innerHTML = `<ruby><span class="_Value"></span><rp>(</rp><rt class="_Name"></rt><rp>)</rp></ruby><span class="_Indicator" aria-role="hidden"></span>`;
      this.el.classList.add('RangeElement');
      this.el.setAttribute('aria-role', "slider");
      this.el.setAttribute('aria-valuemin', this._config.min);
      this.el.setAttribute('aria-valuemax', this._config.max);
      this.els.value = this.el.querySelector('._Value');
      this.els.name = this.el.querySelector('._Name');
      this.els.name.textContent = this.variable.getName();
      this.els.indicator = this.el.querySelector('._Indicator');
      this._renderUpdate();
      this._bindEvents();
    }

    _bindEvents () {
      this.el.addEventListener('mousedown', this._startDragging.bind(this));
      this.el.addEventListener('touchstart', this._startDragging.bind(this));
      this.el.addEventListener('click', this._reset.bind(this));
      this.el.addEventListener('keydown', this._handleKeydown.bind(this));
    }

    _handleKeydown (e) {
      if (
        e.which === 37 // Left Arrow
        || e.which === 40 // Down Arrow
      ) {
        e.preventDefault();
        this._decrement(e.shiftKey ? this._config.step * 10 : this._config.step);
      } else if (
        e.which === 39 // Right Arrow
        || e.which === 38 // Up Arrow
      ) {
        e.preventDefault();
        this._increment(e.shiftKey ? this._config.step * 10 : this._config.step);
      } else if (
        e.which === 13 // Enter
      ) {
        e.preventDefault();
        this._reset();
      }
    }

    _increment (magnitude) {
      if (!magnitude) {
        magnitude = this._config.step;
      }
      const current_value = this.variable.getValue();
      let new_value = current_value + magnitude;
      if (this._config.max != null) {
        if (this._config.inclusive) {
          if (new_value > this._config.max) {
            new_value = this._config.max;
          }
        } else {
          if (new_value > this._config.max - this._config.step) {
            new_value = this._config.max - this._config.step;
          }
        }
      }
      this.variable.setValue(new_value);
    }

    _decrement (magnitude) {
      if (!magnitude) {
        magnitude = this._config.step;
      }
      const current_value = this.variable.getValue();
      let new_value = current_value - magnitude;
      if (this._config.min != null) {
        if (new_value < this._config.min) {
          new_value = this._config.min;
        }
      }
      this.variable.setValue(new_value);
    }

    _startDragging (e) {
      e.preventDefault();
      this._drag_start_value = this.variable.getValue();
      this._drag_manager.start(e, this, 'x');
      this.el.dataset.is_active = true;
    }

    onDrag ({ x_start, y_start, x_delta, y_delta }) {
      const max = this._config.max;
      const min = this._config.min;
      const step = this._config.step;
      let px_per_step;
      if (max != null && min != null) {
        px_per_step = Math.min((window.innerWidth / (max - min / step)), 25); // Keep the step size close to a comfortable touch target
      } else {
        px_per_step = 25;
      }
      const value_delta = Math.floor(x_delta / px_per_step) * step;
      let new_val = this._drag_start_value + value_delta;

      if (max != null) {
        const inclusive = this._config.inclusive;
        if (
          (inclusive && new_val > max)
          || (!inclusive && new_val >= max)
        ) {
          new_val = max;
          if (!inclusive) {
            new_val -= this._config.step;
          }
        }
      }
      if (min != null && new_val < min) {
        new_val = min;
      }
      if (this.variable.getValue() !== new_val) {
        this.variable.setValue(new_val);
      }
    }

    stopDragging (ui) {
      this.el.dataset.is_active = false;
      this._drag_start_value = null;
    }

    _reset () {
      const now = Date.now();
      if (now - this._last_click < 500) {
        this.variable.setValue(this._initial_value);
      }
      this._last_click = now;
    }

    _renderUpdate () {
      const value = this.variable.getValue();

      if (value === undefined) {
        this.el.setAttribute('aria-valuetext', this._text_content);
        this.els.value.textContent = this._text_content;
        return;
      }

      let display_val;
      if (this._display_precision != null) {
        display_val = value.toFixed(this._display_precision);
      } else {
        display_val = value;
      }
      display_val = `${this._before_text || ''}${ display_val }${ this._after_text || '' }`;
      this.el.setAttribute('aria-valuetext', display_val);
      this.el.setAttribute('aria-valuenow', value);
      this.els.value.textContent = display_val;
      if (this._config.max != null && this._config.min != null) {
        const max = this._config.inclusive ? this._config.max : this._config.max - this._config.step;
        const min = this._config.min;
        const progress = (value - min) / (max - min);
        this.els.indicator.style.width = `${ progress * 100 }%`;
      }
    }

  }

  class StringElement extends BaseElement {
    readonly = true;
    static config_pattern = /(^[\w\d]+$)/;

    static _parseConfig (config_text) {
      const config_match = config_text.match(this.config_pattern);
      if (!config_match) { return null; }
      return {
        name: config_match[1],
      };
    }

    static _parseTextContent (parsed_config, text_content) {
      let default_value     = parsed_config.value;
      let before_text       = '';
      let after_text        = '';
      let display_precision = null;

      /*
          [
            '$200.0 per day',
            '$',
            '200',
            '.',
            '0',
            ' per day',
            index: 0,
            input: '$200.0 per day'
          ]
      */
      const pattern = /([a-zA-Z=:$ ]*)([\-\d]+)(\.?)(\d*)([%a-zA-Z=: ]*)/;
      const match_group = text_content.match(pattern);
      if (match_group) {
        const [
          _text,
          before_text_str,
          value_str,
          point_str,
          decimal_str,
          after_text_str,
        ] = match_group;
        before_text = before_text_str;
        after_text = after_text_str;
        default_value = parseFloat([value_str, point_str, decimal_str].join(''));
        if (point_str) {
          display_precision = decimal_str.length;
        }
      }
      return {
        default_value,
        before_text,
        after_text,
        display_precision,
      };
    }

    constructor (el) {
      super(el);
      this.els = {};
      const parsed_config = StringElement._parseConfig(el.dataset.config);
      const parsed_text = StringElement._parseTextContent(parsed_config, el.textContent);
      this._before_text = parsed_text.before_text;
      this._after_text = parsed_text.after_text;
      this._display_precision = parsed_text.display_precision;
      this._text_content = el.textContent;
      this.variable = Variable.getOrCreate(parsed_config.name);
      this.variable.onChange(() => this._renderUpdate());
      this._renderInitial();
    }

    _renderInitial () {
      this.el.innerHTML = `<ruby><span class="_Value"></span><rp>(</rp><rt class="_Name"></rt><rp>)</rp></ruby>`;
      this.el.classList.add('StringElement');
      this.els.value = this.el.querySelector('._Value');
      this.els.name = this.el.querySelector('._Name');
      this.els.name.textContent = this.variable.getName();
      this._renderUpdate();
    }

    _renderUpdate () {
      let value = this.variable.getValue();
      let display_value;
      if (value === undefined) {
        display_value = this._text_content;
      } else {
        // Automatically format percents
        if (typeof value === "number") {
          if (this._after_text === "%") {
            value = value * 100;
          }
          if (this._display_precision !== null) {
            display_value = value.toFixed(this._display_precision);
          } else {
            const fmt = new Intl.NumberFormat({
              // minimumFractionDigits: this._display_precision || undefined,
              // maximumFractionDigits: this._display_precision || undefined,
            });
            display_value = fmt.format(value);
          }
        } else if (Array.isArray(value)) {
          if (value.length > 0) {
            display_value = value.join(", ");
          } else {
            display_value = this._text_content;
          }
        } else {
          display_value = value.toString();
        }
      }
      display_value = `${ this._before_text || '' }${ display_value }${ this._after_text || '' }`;
      if (this.els.value.textContent !== display_value) {
        this.els.value.textContent = display_value;
        this._pingChanged();
      }
    }
  }

  class SwitchElement extends BaseElement {
    static config_pattern = new RegExp(`
    ^(                      # Variable
      [\\w\\d]+               # - name
    )

    :\\s                   # Delimiter

    (                       # true_label
        [\\w]+
    )

    \\sor\\s                  # or keyword

    (                       # false_label
        [\\w]+
    )$
  `.replace(/#.*\n/g,'').replace(/\s+/g,''));

    static _parseConfig (config_text) {
      const config_match = config_text.match(this.config_pattern);
      if (!config_match) { return null; }
      /*
          [
              "some_flag: on or off",
              "some_flag",
              "on",
              "off",
              index: 0,
              input: "some_flag: on or off"
          ]
      */

      const [
        _text,
        name,
        true_label,
        false_label,
      ] = config_match;

      return {
        name,
        true_label,
        false_label,
      };
    }

    static _parseTextContent (parsed_config, text_content) {
      const { true_label, false_label } = parsed_config;

      function matchLabel (label) {
        const pattern = RegExp(`(.*)${ label }(.*)`);
        const group = text_content.match(pattern);
        return group;
      }

      let default_value = undefined;
      let before_text = '';
      let after_text = '';

      const true_group = matchLabel(true_label);
      if (true_group) {
        default_value = true;
        before_text = true_group[1];
        after_text = true_group[2];
      } else {
        const false_group = matchLabel(false_label);
        if (false_group) {
          default_value = false;
          before_text = false_group[1];
          after_text = false_group[2];
        }
      }
      return {
        default_value,
        before_text,
        after_text,
      };
    }

    constructor (el) {
      super(el);
      this.els = {};
      const parsed_config = SwitchElement._parseConfig(el.dataset.config);
      const parsed_text = SwitchElement._parseTextContent(parsed_config, el.textContent);
      this._true_label = parsed_config.true_label;
      this._false_label = parsed_config.false_label;
      this._before_text = parsed_text.before_text;
      this._after_text = parsed_text.after_text;
      this._text_content = el.textContent;
      this._name = parsed_config.name;
      this.variable = new Variable(parsed_config.name, parsed_text.default_value);
      this.variable.onChange(() => this._renderUpdate());
      this._renderInitial();
    }

    _renderInitial () {
      this.el.innerHTML = `<span class="_Indicator" aria-hidden="true">â€¢</span><ruby><span class="_Value"></span><rp>(</rp><rt class="_Name"></rt><rp>)</rp></ruby>`;
      this.el.classList.add('SwitchElement');
      this.el.setAttribute('aria-role', "button");
      this.els.value = this.el.querySelector("._Value");
      this.els.name = this.el.querySelector("._Name");
      this.els.indicator = this.el.querySelector("._Indicator");
      this.els.name.textContent = this._name;
      this._renderUpdate();
      this._bindEvents();
    }

    _renderUpdate () {
      const value = this.variable.getValue();
      let display_val;
      if (value === true) {
        display_val = this._true_label;
        this.el.setAttribute('aria-pressed', true);
      } else if (value === false) {
        display_val = this._false_label;
        this.el.setAttribute('aria-pressed', false);
      } else {
        display_val = this._text_content;
        this.el.setAttribute('aria-pressed', 'mixed');
      }
      display_val = `${this._before_text || ''}${ display_val }${ this._after_text || '' }`;
      this.els.value.textContent = display_val;
    }

    _bindEvents () {
      this.el.addEventListener('click', this._toggleValue.bind(this));
      this.el.addEventListener('keydown', this._handleKeydown.bind(this));
    }

    _handleKeydown (e) {
      if (
        e.which === 32 // Space
        || e.which === 13 // Enter
      ) {
        e.preventDefault();
        this._toggleValue();
      }
    }

    _toggleValue (e) {
      const current = this.variable.getValue();
      if (current === true) {
        this.variable.setValue(false);
      } else {
        this.variable.setValue(true);
      }
    }
  }

  class FormElement extends BaseElement {
    constructor (el) {
      super(el);
      this.el.classList.add('FormElement');
      const name = this.el.getAttribute('name');
      this._variable = new Variable(name);
      this.el.addEventListener('change', this._triggerUpdate.bind(this));
      this._triggerUpdate({ target: this.el }); // Get the initial value from the markup
    }

    _triggerUpdate (e) {
      if (this.el.options && this.el.multiple) {
        const value = [];
        for (const option of this.el.options) {
          if (option.selected) {
            value.push(option.value);
          }
        }
        this._variable.setValue(value);
      } else {
        this._variable.setValue(e.target.value);
      }

    }
  }

  function activateElements () {
    const form_fields = [
      ...document.querySelectorAll('input[name]'),
      ...document.querySelectorAll('select[name]'),
    ];
    form_fields.forEach(el => {
      new FormElement(el);
    });

    const elements = document.querySelectorAll('.js-amd-element');
    Array.from(elements).forEach((el) => {
      const config = el.dataset.config;
      if (RangeElement.config_pattern.test(config)) {
        new RangeElement(el);
      } else if (StringElement.config_pattern.test(config)) {
        new StringElement(el);
      } else if (SwitchElement.config_pattern.test(config)) {
        new SwitchElement(el);
      // } else if (SequenceElement.config_pattern.test(config)) {
      } else {
        console.warn('Unknown config format', config);
      }
    });
  }

  async function activateCodeBlocks () {
    // const Executor = await import("./Executor.js");
    const executor = new Executor(__amd_meta__);

    const codeblocks = document.querySelectorAll('pre');
    Array.from(codeblocks).forEach((block_el) => {
      const code_el = block_el.children[0];
      if (code_el && code_el.classList && !code_el.className) {
        executor.addBlock({
          el: code_el,
        });
      }
    });
    executor.run();
  }


  function setUpViewSource () {
    document.body.dataset.show_source = false;
    const el = document.getElementById("activemd_raw_source");
    const raw_source = decodeURIComponent(el.textContent);
    el.textContent = raw_source;
    const controls = document.createElement('nav');
    controls.setAttribute('id', 'activemd_controls');
    controls.innerHTML = `
    <a id="activemd_controls_view_source" href="#view-source">View Source</a>
    <a id="activemd_controls_hide_source" href="#">Hide Source</a>
    <a id="activemd_controls_download_source" href="#">Download</a>
    <a href="https://activemarkdown.alecperkins.net" rel="noreferrer">About</a>
  `;
    const view_source_el = controls.querySelector('#activemd_controls_view_source');
    view_source_el.addEventListener('click', (e) => {
      document.body.dataset.show_source = true;
    });
    const hide_source_el = controls.querySelector('#activemd_controls_hide_source');
    hide_source_el.addEventListener('click', (e) => {
      document.body.dataset.show_source = false;
    });
    const download_source_el = controls.querySelector('#activemd_controls_download_source');
    const file = new Blob([raw_source], {
      type: 'text/markdown',
    });
    download_source_el.setAttribute('href', URL.createObjectURL(file));
    download_source_el.setAttribute('download', decodeURIComponent(document.body.dataset.filename));
    document.body.prepend(controls);

    if (window.location.hash === '#view-source') {
      document.body.dataset.show_source = true;
    }
  }

  function setUpHeaderLinks () {
    const header_els = document.querySelectorAll('h1, h2, h3, h4, h5, h6');
    Array.from(header_els).forEach(el => {
      const link_el = document.createElement('a');
      link_el.href = `#${ el.id }`;
      link_el.classList.add('_Link');
      link_el.textContent = '#';
      link_el.setAttribute('aria-description', `Link to ${ el.textContent } heading`);
      const wrapper_el = document.createElement('div');
      wrapper_el.classList.add('SectionHeader');
      wrapper_el.appendChild(link_el);
      el.parentNode.insertBefore(wrapper_el, el);
      wrapper_el.appendChild(el);
      // el.remove();
    });
  }
  function main () {
    setUpHeaderLinks();
    activateElements();
    {
      activateCodeBlocks();
    }
    setUpViewSource();
    document.body.dataset.activemd = true;
  }

  main();

})();
  </script>
  
</body>
</html>
